[
  
  {
    "title": "rustlings 学习和答案",
    "url": "/posts/rustlings/",
    "categories": "Rust",
    "tags": "rustlings",
    "date": "2024-07-08 16:26:00 +0800",
    





    "snippet": "前言  去年年中对rust进行了一个大概的学习，然后完成了rustlings的笔记，最后改写了我的两个简单的java项目。今年回首，又感觉比较陌生了，所以准备在此记录一下rustlings的题解和一些笔记。相关资料  Rust The Book  Rust By Example  rustlings  Rust Course  jiangkerLove/rustlingsIntro  Rust uses the print! and println! macros to print text to the console.intro2.ts打印写错了，改为println!(\"Hello world!\");printrust的打印是不换行的print!()以及换行的println!()，这两个都是宏函数Further information  Hello World  Formatted printVariables  In Rust, variables are immutable by default. When a variable is immutable, once a value is bound to a name, you can’t change that value. You can make them mutable by adding mut in front of the variable name.variables1没有声明变量，所以增加letlet x = 5;variables2没有指定默认值，这里的变量类型申明是可以省略的。let x: i32 = 0;variables3也是没有指定默认值let x: i32 = 10;variables4这里涉及到变量的修改，因为rust变量默认是不可变的，所以增加修饰符mutlet mut x = 3;variables5因为这里变量已经赋值并且不可变，而且还是&amp;str类型，题目也要求不可以对此修改，所以可以考虑利用变量再利用的特性，直接重新申明一次，之前的对象会被回收，不可再使用。let number = 3;variables6const申明的是编译时确定值的不可变常亮，需要显示的指定类型，所以增加类型即可const NUMBER: i32 = 3;Further information  Variables and MutabilityFunctions  Here, you’ll learn how to write functions and how the Rust compiler can help you debug errors evenin more complex code.functions1这里因为调用了没有申明的函数，所以直接申明就可以了，注意rust的函数和c不同，在使用之前或者之后都是OK的fn call_me(){}functions2方法定义参数是，需要显示的指定参数的类型fn call_me(num: i32) {    for i in 0..num {        println!(\"Ring! Call number {}\", i + 1);    }}functions3对需要参数的方法调用时，必须要指定参数call_me(3);function4有返回值时，需要显示的申明返回值类型。因为这里返回的是if表达式，并且函数的最后一个表达式的值可以被隐式地返回，省略return关键字，省略分号意味着这个表达式的值将成为函数的返回值。fn sale_price(price: i64) -&gt; i64{    if is_even(price) {         price - 10    } else {        price - 3    }}function5同理，这里作为返回值，需要省略分号，增加return也是不行的。fn square(num: i32) -&gt; i32 {    num * num}Further information  How Functions WorkIf  if, the most basic (but still surprisingly versatile!) type of control flow, is what you’ll learn here.if1这里主要是写比较逻辑，返回最大值，因为是返回表达式的值，所以都不需要分号fn bigger(a: i32, b: i32) -&gt; i32 {    if a &gt; b { a } else { b }}if2这里主要是else if如何使用fn foo_if_fizz(fizzish: &amp;str) -&gt; &amp;str {    if fizzish == \"fizz\" {        \"foo\"    } else if fizzish == \"fuzz\"{        \"bar\"    } else {        \"baz\"    }}if3if表达式的所有分支必须返回相同类型的值.fn animal_habitat(animal: &amp;str) -&gt; &amp;str {    // TODO: Fix the compiler error in the statement below.    let identifier = if animal == \"crab\" {        1    } else if animal == \"gopher\" {        2    } else if animal == \"snake\" {        3    } else {        4    };    // Don't change the expression below!    if identifier == 1 {        \"Beach\"    } else if identifier == 2 {        \"Burrow\"    } else if identifier == 3 {        \"Desert\"    } else {        \"Unknown\"    }}Further information  Control Flow - if expressionsquiz1这是前面一部分的总结，需要定义一个方法满足条件fn calculate_price_of_apples(num: i32) -&gt; i32 { if num &lt;= 40 { num * 2 } else { num } }Primitive Types  Rust has a couple of basic types that are directly implemented into the compiler. In this section, we’ll go through the most important ones.primitive_types1需要定义一个新的完整变量let is_evening: bool = false;if is_evening {    println!(\"Good evening!\");}primitive_types2也是定义一个变量，随意就行let your_character = '1';primitive_types3定义一个长度超过100的arrlet a = \"12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\";primitive_types4这里需要从原来的数组中获取一个片段出来let nice_slice = &amp;a[1..4];注意这里用到了&amp;符号，表示这是创建一个引用出来，指向的是原来的片段；可能有人要问了，为什么要在数组或向量的切片操作中使用&amp;符号呢？这是因为：      借用数据： Rust 中的切片操作返回的类型是一个引用，而不是数据本身。这意味着切片并不会拷贝整个数据，而只是提供了一个指向原始数据特定部分的引用。这种做法可以避免不必要的内存分配和数据复制。        所有权和借用规则： Rust的所有权系统要求在操作数据时要么拥有数据的所有权，要么借用数据的引用。使用&amp;符号创建的切片引用，表明我们只是借用了原始数据的一部分，而不是拥有整个数据。        性能和内存： 借用数据比复制数据更高效，特别是当处理大量数据时。通过使用引用，可以避免在堆上分配新的内存空间，从而提高程序的性能和内存效率。  那么还有人要问了，能不能写成拷贝的形式呢 ? 那就得比较麻烦一点了，需要先创建数组，然后再拷贝过去。let mut nice_slice = [0; 3];let slice = &amp;a[1..4];nice_slice.copy_from_slice(slice);primitive_types5解构提取元祖的数据let (name, age) = cat;这里可以看到编译器提示类型，但是类型不能写到里面，得写到后面let (name, age): (&amp;str, f32) = cat;primitive_types6解构获取元祖中的某一个元素。let second: i32 = numbers.1;Further information  Data Types  The Slice TypeVectors  Vectors are one of the most-used Rust data structures. In other programminglanguages, they’d simply be called Arrays, but since Rust operates on abit of a lower level, an array in Rust is stored on the stack (meaning itcan’t grow or shrink, and the size needs to be known at compile time),and a Vector is stored in the heap (where these restrictions do not apply).Vectors are a bit of a later chapter in the book, but we think that they’reuseful enough to talk about them a bit earlier. We shall be talking aboutthe other useful data structure, hash maps, later.vecs1这里规定了返回值类型，需要把Array转换成Vecfn array_and_vec() -&gt; ([i32; 4], Vec&lt;i32&gt;) {    let a = [10, 20, 30, 40]; // Array    let v = a.to_vec();    (a, v)}vecs2观察单测，可以发现其实都是想返回乘2之后的数据，关键就在怎么写，其中还给了一个例子，可以参考fn vec_loop(input: &amp;[i32]) -&gt; Vec&lt;i32&gt; {    let mut output = Vec::new();    for element in input {        output.push(element * 2)    }    output}fn vec_map(input: &amp;[i32]) -&gt; Vec&lt;i32&gt; {    input        .iter()        .map(|element| {            element * 2        })        .collect()}Further information  Storing Lists of Values with Vectors  iter_mut  mapMove Semantics  These exercises are adapted from pnkfelix’s Rust Tutorial – Thank you Felix!!!move_semantics1这里主要是传入的是不可变对象，然后需要向其添加元素，所以需要进行所有权转换fn fill_vec(vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {    let mut vec = vec;    vec.push(88);    vec}#[cfg(test)]mod tests {    use super::*;    #[test]    fn move_semantics1() {        let vec0 = vec![22, 44, 66];        let vec1 = fill_vec(vec0);        assert_eq!(vec1, vec![22, 44, 66, 88]);    }}在这里vec0已经把所有权传给了fill_vec方法，后续就不能再继续使用了，然后看看fill_vec函数的作用在 Rust 中，函数参数的传递有两种方式：按值传递（move）和按引用传递（borrow）。按值传递（move）在 Rust 中，对于不可变的数据结构（比如基本数据类型和不可变引用），函数参数默认是按值传递的。这意味着当你调用函数时，函数会获取参数的所有权，也就是将参数的所有权转移给函数，称为 move。在函数内部对参数的修改不会影响原始的数据。解释 fill_vec 函数的行为：  参数传递：fn fill_vec(vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; 定义了一个函数 fill_vec，它接收一个 Vec&lt;i32&gt; 类型的参数 vec。这里的 vec 是按值传递的，即函数调用时会发生所有权的转移。  函数内部操作：let mut vec = vec; 在函数内部，通过 let mut vec = vec; 将参数 vec 的所有权转移给了函数内部的新变量 vec。这一步实际上是一个 move 操作，导致原始的 vec 参数被移动（所有权被转移），在函数返回后不再有效。  修改操作：vec.push(88); 在函数内部，通过 vec.push(88); 向 vec 中添加了一个新元素 88。  返回值：vec 在函数末尾作为返回值返回给调用者。由于 Rust 中的函数返回值可以传递所有权，因此返回的 vec 将成为函数调用者所拥有的新的 Vec&lt;i32&gt;。move_semantics2这第二个例子就是解决所有权转移后vec0不再可用的#[test]fn move_semantics2() {    let vec0 = vec![22, 44, 66];    let vec1 = fill_vec(vec0.clone());    assert_eq!(vec0, [22, 44, 66]);    assert_eq!(vec1, [22, 44, 66, 88]);}move_semantics3因为前面的在fill_vec中都进行了额外的所有权转移，这个例子就是来解释怎么优化这块的，可以考虑直接声明为可变动，那后续里面就可以直接操作了fn fill_vec(mut vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {    vec.push(88);    vec}move_semantics4因为x连续进行了两次借用，所以第二次借用会出现错误。所以可以考虑先对y进行使用，当y后续没有使用归还了x之后，z就可以继续借用x了。#[test]fn move_semantics4() {    let mut x = 100;    let y = &amp;mut x;    *y += 100;    let z = &amp;mut x;    *z += 1000;    assert_eq!(x, 1200);}move_semantics5get_char不获取所有权，只获取值，不影响原来的值；string_uppercase获取所有权，进行转换，影响原来的值。fn main() {    let data = \"Rust is great!\".to_string();    get_char(&amp;data);    string_uppercase(data);}// Shouldn't take ownershipfn get_char(data: &amp;String) -&gt; char {    data.chars().last().unwrap()}// Should take ownershipfn string_uppercase(mut data: String) {    data = data.to_uppercase();    println!(\"{data}\");}Further informationFor this section, the book links are especially important.  Ownership  Reference and borrowingStructs  Rust has three struct types: a classic C struct, a tuple struct, and a unit struct.structs1这里主要表示常规结构体和元祖结构体的定义和使用，注意常规结构体都需要写字段名。struct ColorRegularStruct {    red: i32,    green: i32,    blue: i32,}struct ColorTupleStruct(i32, i32, i32);#[derive(Debug)]struct UnitStruct;#[cfg(test)]mod tests {    use super::*;    #[test]    fn regular_structs() {        let green = ColorRegularStruct { red: 0, green: 255, blue: 0 };        assert_eq!(green.red, 0);        assert_eq!(green.green, 255);        assert_eq!(green.blue, 0);    }    #[test]    fn tuple_structs() {        let green = ColorTupleStruct(0, 255, 0);        assert_eq!(green.0, 0);        assert_eq!(green.1, 255);        assert_eq!(green.2, 0);    }    #[test]    fn unit_structs() {        let unit_struct = UnitStruct;        let message = format!(\"{unit_struct:?}s are fun!\");        assert_eq!(message, \"UnitStructs are fun!\");    }}  #[derive(Debug)]：这行代码为结构体自动实现了Debug trait，使其可以使用:?进行格式化输出。  {unit_struct:?}：花括号内的 :? 是一种格式化标记，表示使用 Debug trait 来打印 unit_struct 的调试信息。structs2创建一下自己的结构体，满足结果判断就行let your_order = Order {    name: String::from(\"Hacker in Rust\"),    year: 2019,    made_by_phone: false,    made_by_mobile: false,    made_by_email: true,    item_number: 123,    count: 1,};structs3这里是给结构体增加方法，和常规定义方法类似。#[derive(Debug)]struct Package {    sender_country: String,    recipient_country: String,    weight_in_grams: u32,}impl Package {    fn new(sender_country: String, recipient_country: String, weight_in_grams: u32) -&gt; Self {        if weight_in_grams &lt; 10 {            panic!(\"Can't ship a package with weight below 10 grams\");        }        Self {            sender_country,            recipient_country,            weight_in_grams,        }    }    fn is_international(&amp;self) -&gt; bool {        self.sender_country != self.recipient_country    }    fn get_fees(&amp;self, cents_per_gram: u32) -&gt; u32 {        cents_per_gram * self.weight_in_grams    }}#[cfg(test)]mod tests {    use super::*;    #[test]    #[should_panic]    fn fail_creating_weightless_package() {        let sender_country = String::from(\"Spain\");        let recipient_country = String::from(\"Austria\");        Package::new(sender_country, recipient_country, 5);    }}  需要注意返回不能用return以及;  #[should_panic] 表示期望有异常，所以会打印出报错日志，但是这测试是通过的  :: 用于命名空间（模块）访问、调用关联函数和常量，以及泛型和特征的约束。  . 用于访问结构体或枚举的字段和方法，以及调用对象实例的方法。    Further information    Structures  Method SyntaxEnums  Rust allows you to define types called “enums” which enumerate possible values.Enums are a feature in many languages, but their capabilities differ in each language. Rust’s enums are most similar to algebraic data types in functional languages, such as F#, OCaml, and Haskell.Useful in combination with enums is Rust’s “pattern matching” facility, which makes it easy to run different code for different values of an enumeration.enums1定义一个没有参数的枚举#[derive(Debug)]enum Message {    Resize,    Move,    Echo,    ChangeColor,    Quit,}enums2丰富的枚举类型支持，可以支持结构体，元祖等混合使用.#[derive(Debug)]enum Message {    // TODO: Define the different variants used below.    Resize {        width: i32,        height: i32,    },    Move(Point),    Echo(String),    ChangeColor(i32, i32, i32),    Quit}enums3主要就是枚举的match操作，类似于kotlin的when，不需要使用breakstruct Point {    x: u64,    y: u64,}enum Message {    Resize {        width: u64,        height: u64,    },    Move(Point),    Echo(String),    ChangeColor(u8, u8, u8),    Quit,}struct State {    width: u64,    height: u64,    position: Point,    message: String,    color: (u8, u8, u8),    quit: bool,}impl State {    fn resize(&amp;mut self, width: u64, height: u64) {        self.width = width;        self.height = height;    }    fn move_position(&amp;mut self, point: Point) {        self.position = point;    }    fn echo(&amp;mut self, s: String) {        self.message = s;    }    fn change_color(&amp;mut self, red: u8, green: u8, blue: u8) {        self.color = (red, green, blue);    }    fn quit(&amp;mut self) {        self.quit = true;    }    fn process(&amp;mut self, message: Message) {        // TODO: Create a match expression to process the different message        // variants using the methods defined above.        match message {            Message::Resize { width, height } =&gt; {                self.resize(width, height)            }            Message::Move(point) =&gt; { self.move_position(point) }            Message::Echo(msg) =&gt; { self.echo(msg) }            Message::ChangeColor(red, green, blue) =&gt; { self.change_color(red, green, blue) }            Message::Quit =&gt; { self.quit() }        }    }}Further information  Enums  Pattern syntaxStrings  Rust has two string types, a string slice (&amp;str) and an owned string (String).We’re not going to dictate when you should use which one, but we’ll show you how to identify and create them, as well as use them.strings1需要返回String，而不是&amp;strfn current_favorite_color() -&gt; String {    String::from(\"blue\")}  字符串字面量 &amp;'str 是字符串字面量，它是一个指向程序数据段中某个位置的不可变引用，具有 'static 生命周期。  String 类型：String 是一个堆分配的字符串类型，提供了更多的功能和灵活性。strings2这里主要考查String转&amp;strfn is_a_color_word(attempt: &amp;str) -&gt; bool {    attempt == \"green\" || attempt == \"blue\" || attempt == \"red\"}fn main() {    let word = String::from(\"green\"); // Don't change this line.    if is_a_color_word(&amp;word) {        println!(\"That is a color word I know!\");    } else {        println!(\"That is not a color word I know.\");    }}因为不涉及改变，直接借用就行了，也可以使用as_str()方法string3字符串的一些操作fn trim_me(input: &amp;str) -&gt; &amp;str {    input.trim()}fn compose_me(input: &amp;str) -&gt; String {    format!(\"{} world!\", input)}fn replace_me(input: &amp;str) -&gt; String {    input.replace(\"cars\",\"balloons\")}string4也是字符串的操作，多种情况的返回值fn main() {    string_slice(\"blue\");    string(\"red\".to_string());    string(String::from(\"hi\"));    string(\"rust is fun!\".to_owned());    string(\"nice weather\".into());    string(format!(\"Interpolation {}\", \"Station\"));    // WARNING: This is byte indexing, not character indexing.    // Character indexing can be done using `s.chars().nth(INDEX)`.    string_slice(&amp;String::from(\"abc\")[0..1]);    string_slice(\"  hello there \".trim());    string(\"Happy Monday!\".replace(\"Mon\", \"Tues\"));    string(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());}Further information  StringsModules  In this section we’ll give you an introduction to Rust’s module system.modules1这里是考察module的可见性，默认是私有的，需要在外访问加pubmod sausage_factory {    fn get_secret_recipe() -&gt; String {        String::from(\"Ginger\")    }    pub fn make_sausage() {        get_secret_recipe();        println!(\"sausage!\");    }}modules2和1类似，这里是重导，外部访问要求内部必须都是pub的#[allow(dead_code)]mod delicious_snacks {    pub use self::fruits::PEAR as fruit;    pub use self::veggies::CUCUMBER as veggie;    mod fruits {        pub const PEAR: &amp;str = \"Pear\";        pub const APPLE: &amp;str = \"Apple\";    }    mod veggies {        pub const CUCUMBER: &amp;str = \"Cucumber\";        pub const CARROT: &amp;str = \"Carrot\";    }}module3简单演示怎么导入公共模块内容use std::time::{SystemTime, UNIX_EPOCH};Further information  The Module SystemHashmaps  A hash map allows you to associate a value with a particular key.You may also know this by the names unordered map in C++,dictionary in Python or an associative array in other languages.  This is the other data structure that we’ve been talking about before, whentalking about Vecs.hashmap1创建和插入fn fruit_basket() -&gt; HashMap&lt;String, u32&gt; {    let mut basket = HashMap::new();    basket.insert(String::from(\"banana\"), 2);    basket.insert(String::from(\"apple\"), 3);    basket.insert(String::from(\"watermelon\"), 1);    basket}hashmap2如果不存在再插入fn fruit_basket(basket: &amp;mut HashMap&lt;Fruit, u32&gt;) {    let fruit_kinds = [        Fruit::Apple,        Fruit::Banana,        Fruit::Mango,        Fruit::Lychee,        Fruit::Pineapple,    ];    for fruit in fruit_kinds {        basket.entry(fruit).or_insert(1);    }}hashmap3一个插入的小练习use std::collections::HashMap;#[derive(Default)]struct Team {    goals_scored: u8,    goals_conceded: u8,}fn build_scores_table(results: &amp;str) -&gt; HashMap&lt;&amp;str, Team&gt; {    let mut scores = HashMap::new();    for line in results.lines() {        let mut split_iterator = line.split(',');        // NOTE: We use `unwrap` because we didn't deal with error handling yet.        let team_1_name = split_iterator.next().unwrap();        let team_2_name = split_iterator.next().unwrap();        let team_1_score: u8 = split_iterator.next().unwrap().parse().unwrap();        let team_2_score: u8 = split_iterator.next().unwrap().parse().unwrap();        let entry1 = scores.entry(team_1_name).or_insert(Team { goals_scored: 0, goals_conceded: 0 });        entry1.goals_scored += team_1_score;        entry1.goals_conceded += team_2_score;        let entry2 = scores.entry(team_2_name).or_insert(Team { goals_scored: 0, goals_conceded: 0 });        entry2.goals_scored += team_2_score;        entry2.goals_conceded += team_1_score;    }    scores}quiz2阶段性小练习，总结enum Command {    Uppercase,    Trim,    Append(usize),}mod my_module {    use super::Command;    pub fn transformer(input: Vec&lt;(String, Command)&gt;) -&gt; Vec&lt;String&gt; {        input.iter().map(|(item, cmd)| {            match cmd {                Command::Uppercase =&gt; {                    item.to_uppercase()                }                Command::Trim =&gt; {                    item.trim().to_string()                }                Command::Append(size) =&gt; {                    format!(\"{}{}\", item, \"bar\".repeat(*size))                }            }        }).collect()    }}#[cfg(test)]mod tests {    use super::my_module::{transformer};    use super::Command;    #[test]    fn it_works() {        let input = vec![            (\"hello\".to_string(), Command::Uppercase),            (\" all roads lead to rome! \".to_string(), Command::Trim),            (\"foo\".to_string(), Command::Append(1)),            (\"bar\".to_string(), Command::Append(5)),        ];        let output = transformer(input);        assert_eq!(            output,            [                \"HELLO\",                \"all roads lead to rome!\",                \"foobar\",                \"barbarbarbarbarbar\",            ]        );    }}Further information  Storing Keys with Associated Values in Hash MapsOptionsType Option represents an optional value: every Option is either Some and contains a value, or None, and does not.Option types are very common in Rust code, as they have a number of uses:  Initial values  Return values for functions that are not defined over their entire input range (partial functions)  Return value for otherwise reporting simple errors, where None is returned on error  Optional struct fields  Struct fields that can be loaned or “taken”  Optional function arguments  Nullable pointers  Swapping things out of difficult situationsOptions1Option的两个值，Some和None的基本使用fn maybe_icecream(hour_of_day: u16) -&gt; Option&lt;u16&gt; {    if hour_of_day &lt; 22 { Some(5) }    else if hour_of_day &lt; 24 { Some(0) }    else { None }}#[cfg(test)]mod tests {    use super::*;    #[test]    fn raw_value() {        let icecreams = maybe_icecream(12).unwrap();        assert_eq!(icecreams, 5); // Don't change this line.    }    #[test]    fn check_icecream() {        assert_eq!(maybe_icecream(0), Some(5));        assert_eq!(maybe_icecream(9), Some(5));        assert_eq!(maybe_icecream(18), Some(5));        assert_eq!(maybe_icecream(22), Some(0));        assert_eq!(maybe_icecream(23), Some(0));        assert_eq!(maybe_icecream(24), None);        assert_eq!(maybe_icecream(25), None);    }}Options2Option的使用，可以使用if let表达式解构里面的值，或者while let#[cfg(test)]mod tests {    #[test]    fn simple_option() {        let target = \"rustlings\";        let optional_target = Some(target);        // TODO: Make this an if-let statement whose value is `Some`.        if let Some(word) = optional_target {            assert_eq!(word, target);        }    }    #[test]    fn layered_option() {        let range = 10;        let mut optional_integers: Vec&lt;Option&lt;i8&gt;&gt; = vec![None];        for i in 1..=range {            optional_integers.push(Some(i));        }        let mut cursor = range;        // TODO: Make this a while-let statement. Remember that `Vec::pop()`        // adds another layer of `Option`. You can do nested pattern matching        // in if-let and while-let statements.        while let Some(Some(integer)) = optional_integers.pop() {            assert_eq!(integer, cursor);            cursor -= 1;        }        assert_eq!(cursor, 0);    }}  if let Some(word) = optional_target { ... }：这是一个 if let 表达式，用于模式匹配和解构 optional_target。如果 optional_target 是 Some 枚举，那么将 word 绑定为 Some 内部的值，并执行相应的代码块。  while let Some(Some(integer)) = optional_integers.pop() { ... }：          while let 表达式用于循环处理 optional_integers 向量的元素，直到向量为空为止。      Vec::pop() 方法从向量的末尾移除一个元素，并返回其值。由于 optional_integers 是 Vec&lt;Option&lt;i8&gt;&gt; 类型，所以每次 pop() 返回的是 Option&lt;i8&gt;。      Some(Some(integer)) 是模式匹配的方式，表示要匹配的值是 Some 枚举中的另一个 Some 枚举，其中包含一个整数 integer。      在循环体内，断言 integer 的值应该等于 cursor 的当前值，并且 cursor 自减 1。      Option3match直接使用对象，导致了主权丢失，后面继续使用值会报错#[derive(Debug)]struct Point {    x: i32,    y: i32,}fn main() {    let optional_point = Some(Point { x: 100, y: 200 });    // TODO: Fix the compiler error by adding something to this match statement.    match optional_point {        Some(ref p) =&gt; println!(\"Co-ordinates are {},{}\", p.x, p.y),        _ =&gt; panic!(\"No match!\"),    }    println!(\"{optional_point:?}\"); // Don't change this line.}ref表示是借用值，避免所有权的转移Further Information  Option Enum Format  Option Module Documentation  Option Enum Documentation  if let  while letError handlingMost errors aren’t serious enough to require the program to stop entirely.Sometimes, when a function fails, it’s for a reason that you can easily interpret and respond to.For example, if you try to open a file and that operation fails because the file doesn’t exist, you might want to create the file instead of terminating the process.errors1异常判断和前面判空类似，也是枚举#[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]#[must_use = \"this `Result` may be an `Err` variant, which should be handled\"]#[rustc_diagnostic_item = \"Result\"]#[stable(feature = \"rust1\", since = \"1.0.0\")]pub enum Result&lt;T, E&gt; {    /// Contains the success value    #[lang = \"Ok\"]    #[stable(feature = \"rust1\", since = \"1.0.0\")]    Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),    /// Contains the error value    #[lang = \"Err\"]    #[stable(feature = \"rust1\", since = \"1.0.0\")]    Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),}所以改为fn generate_nametag_text(name: String) -&gt; Result&lt;String, String&gt; {    if name.is_empty() {        Err(\"Empty names aren't allowed\".to_string())    } else {        Ok(format!(\"Hi! My name is {name}\"))    }}errors2进行一个解码fn total_cost(item_quantity: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {    let processing_fee = 1;    let cost_per_item = 5;    let qty = item_quantity.parse::&lt;i32&gt;();    match qty {        Ok(v) =&gt; { Ok(v * cost_per_item + processing_fee) }        Err(e) =&gt; { Err(e) }    }}errors3因为这里没有返回值，所以不能直接用?去抛出异常fn main() {    let mut tokens = 100;    let pretend_user_input = \"8\";    let cost = total_cost(pretend_user_input).unwrap();    if cost &gt; tokens {        println!(\"You can't afford that many!\");    } else {        tokens -= cost;        println!(\"You now have {tokens} tokens.\");    }}errors4简单的演示怎么返回Ok与Errimpl PositiveNonzeroInteger {    fn new(value: i64) -&gt; Result&lt;Self, CreationError&gt; {        if value &gt; 0 {            Ok(Self(value as u64))        } else if value == 0 {            Err(CreationError::Zero)        } else {            Err(CreationError::Negative)        }    }}error5因为会抛出异常，所以表明异常返回值即可fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {    let pretend_user_input = \"42\";    let x: i64 = pretend_user_input.parse()?;    println!(\"output={:?}\", PositiveNonzeroInteger::new(x)?);    Ok(())}error6map_err对错误值进行转换，而不影响正确的值#[derive(PartialEq, Debug)]enum ParsePosNonzeroError {    Creation(CreationError),    ParseInt(ParseIntError),}impl ParsePosNonzeroError {    fn from_creation(err: CreationError) -&gt; Self {        Self::Creation(err)    }    fn from_parseint(err: ParseIntError) -&gt; Self { Self::ParseInt(err) }}#[derive(PartialEq, Debug)]struct PositiveNonzeroInteger(u64);impl PositiveNonzeroInteger {    fn new(value: i64) -&gt; Result&lt;Self, CreationError&gt; {        match value {            x if x &lt; 0 =&gt; Err(CreationError::Negative),            0 =&gt; Err(CreationError::Zero),            x =&gt; Ok(Self(x as u64)),        }    }    fn parse(s: &amp;str) -&gt; Result&lt;Self, ParsePosNonzeroError&gt; {        let x: i64 = s.parse().map_err(ParsePosNonzeroError::from_parseint)?;        Self::new(x).map_err(ParsePosNonzeroError::from_creation)    }}Further information  Error Handling  Generics  Result  Boxing errorsGenerics  Generics is the topic of generalizing types and functionalities to broader cases.This is extremely useful for reducing code duplication in many ways, but can call for some rather involved syntax.Namely, being generic requires taking great care to specify over which types a generic type is actually considered valid.The simplest and most common use of generics is for type parameters.generics1需要一个可以同时存储u8和i8的数据结构，向上提升一下即可fn main() {    let mut numbers: Vec&lt;i16&gt; = Vec::new();    // Don't change the lines below.    let n1: u8 = 42;    numbers.push(n1.into());    let n2: i8 = -1;    numbers.push(n2.into());    println!(\"{numbers:?}\");}generics2泛型类和泛型方法struct Wrapper&lt;T&gt; {    value: T,}impl&lt;T&gt; Wrapper&lt;T&gt; {    fn new(value: T) -&gt; Self {        Wrapper { value }    }}Further information  Generic Data Types  BoundsTraitsA trait is a collection of methods.Data types can implement traits. To do so, the methods making up the trait are defined for the data type. For example, the String data type implements the From&lt;&amp;str&gt; trait. This allows a user to write String::from(\"hello\").In this way, traits are somewhat similar to Java interfaces and C++ abstract classes.Some additional common Rust traits include:  Clone (the clone method)  Display (which allows formatted display via {})  Debug (which allows formatted display via {:?})Because traits indicate shared behavior between data types, they are useful when writing generics.traits1给String实现一个特征，和接口类似trait AppendBar {    fn append_bar(self) -&gt; Self;}impl AppendBar for String {    // TODO: Implement `AppendBar` for the type `String`.    fn append_bar(self) -&gt; Self {        self + \"Bar\"    }}traits2因为Vec是支持泛型的，这里要添加的为String，所以先把泛型写死，然后因为这里传入的是self，是不可变的，所以需要先转化为可变动trait AppendBar {    fn append_bar(self) -&gt; Self;}impl AppendBar for Vec&lt;String&gt; {    fn append_bar(self) -&gt; Self {        let mut vec = self.clone();        vec.push(String::from(\"Bar\"));        vec    }}traits3需要一个简单的默认实现，和一般方法没什么区别trait Licensed {    fn licensing_info(&amp;self) -&gt; String {        String::from(\"Default license\")    }}traits4对泛型的直接使用trait Licensed {    fn licensing_info(&amp;self) -&gt; String {        \"Default license\".to_string()    }}struct SomeSoftware;struct OtherSoftware;impl Licensed for SomeSoftware {}impl Licensed for OtherSoftware {}fn compare_license_types(software1: impl Licensed, software2: impl Licensed) -&gt; bool {    software1.licensing_info() == software2.licensing_info()}traits5泛型的多从约束trait SomeTrait {    fn some_function(&amp;self) -&gt; bool {        true    }}trait OtherTrait {    fn other_function(&amp;self) -&gt; bool {        true    }}struct SomeStruct;impl SomeTrait for SomeStruct {}impl OtherTrait for SomeStruct {}struct OtherStruct;impl SomeTrait for OtherStruct {}impl OtherTrait for OtherStruct {}fn some_func(item: impl SomeTrait + OtherTrait) -&gt; bool {    item.some_function() &amp;&amp; item.other_function()}Further information  Traitsquiz3泛型总结，确保T是实现了的Display的struct ReportCard&lt;T&gt; {    grade: T,    student_name: String,    student_age: u8,}impl&lt;T: std::fmt::Display&gt; ReportCard&lt;T&gt; {    fn print(&amp;self) -&gt; String {        format!(            \"{} ({}) - achieved a grade of {}\",            &amp;self.student_name, &amp;self.student_age, &amp;self.grade,        )    }}Lifetimes  Lifetimes tell the compiler how to check whether references live long enough to be valid in any given situation. For example lifetimes say “make sure parameter ‘a’ lives as long as parameter ‘b’ so that the return value is valid”.  They are only necessary on borrows, i.e. references, since copied parameters or moves are owned in their scope and cannot be referenced outside. Lifetimes mean that calling code of e.g. functions can be checked to make sure their arguments are valid. Lifetimes are restrictive of their callers.  If you’d like to learn more about lifetime annotations, the lifetimekata project has a similar style of exercises to Rustlings, but is all about learning to write lifetime annotations.lifetimes1当有多个借用参数时，这时无法区分，所以需要显示指定生命周期之间的关系，方便编译器判断回收。fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {    if x.len() &gt; y.len() {        x    } else {        y    }}lifetimes2因为生命周期是根据最短的来的，所以括号后就已经不安全了，所以得把最后的返回值打印放到括号结束之前fn main() {    let string1 = String::from(\"long string is long\");    let result;    {        let string2 = String::from(\"xyz\");        result = longest(&amp;string1, &amp;string2);        println!(\"The longest string is '{result}'\");    }}lifetimes3给struct内的借用对象指定生命周期struct Book&lt;'a&gt; {    author: &amp;'a str,    title: &amp;'a str,}Further information  Lifetimes (in Rust By Example)  Validating References with LifetimesTests  Going out of order from the book to cover tests – many of the following exercises will ask you to make tests pass!test1使用use引入要测试的函数fn is_even(n: i64) -&gt; bool {    n % 2 == 0}#[cfg(test)]mod tests {    use super::is_even;    #[test]    fn you_can_assert() {        assert!(is_even(10));        assert!(!is_even(11));    }}test2assert_eq!判断两值相等fn power_of_2(n: u8) -&gt; u64 {    1 &lt;&lt; n}#[cfg(test)]mod tests {    use super::*;    #[test]    fn you_can_assert_eq() {        assert_eq!(power_of_2(2), 4);        assert_eq!(power_of_2(3), 8);        assert_eq!(power_of_2(4), 16);        assert_eq!(power_of_2(8), 256);    }}test3主要是验证需要抛出异常，前面的测试也遇到过类似的，这里是让添加注解#[cfg(test)]mod tests {    use super::*;    #[test]    fn correct_width_and_height() {        let rect = Rectangle::new(10, 20);        assert_eq!(rect.width, 10); // Check width        assert_eq!(rect.height, 20); // Check height    }    #[test]    #[should_panic]    fn negative_width() {        let _rect = Rectangle::new(-10, 10);    }    #[test]    #[should_panic]    fn negative_height() {        let _rect = Rectangle::new(10, -10);    }}Further information  Writing TestsIterators  This section will teach you about Iterators.iterators1迭代器的基本使用#[cfg(test)]mod tests {    #[test]    fn iterators() {        let my_fav_fruits = [\"banana\", \"custard apple\", \"avocado\", \"peach\", \"raspberry\"];        // TODO: Create an iterator over the array.        let mut fav_fruits_iterator = my_fav_fruits.iter();        assert_eq!(fav_fruits_iterator.next(), Some(&amp;\"banana\"));        assert_eq!(fav_fruits_iterator.next(), Some(&amp;\"custard apple\")); // TODO: Replace `todo!()`        assert_eq!(fav_fruits_iterator.next(), Some(&amp;\"avocado\"));        assert_eq!(fav_fruits_iterator.next(), Some(&amp;\"peach\")); // TODO: Replace `todo!()`        assert_eq!(fav_fruits_iterator.next(), Some(&amp;\"raspberry\"));        assert_eq!(fav_fruits_iterator.next(), None); // TODO: Replace `todo!()`    }}iterators2字符串和数组的迭代fn capitalize_first(input: &amp;str) -&gt; String {    let mut chars = input.chars();    match chars.next() {        None =&gt; String::new(),        Some(first) =&gt; first.to_uppercase().collect::&lt;String&gt;() + chars.as_str(),    }}fn capitalize_words_vector(words: &amp;[&amp;str]) -&gt; Vec&lt;String&gt; {    words.iter().map(|x| {        capitalize_first(x)    }).collect()}fn capitalize_words_string(words: &amp;[&amp;str]) -&gt; String {    let mut string = String::new();    words.iter().for_each(|x| {        string.push_str(capitalize_first(x).as_str());    });    string}iterators3完全相同的函数体，可以返回不同的结果#[derive(Debug, PartialEq, Eq)]enum DivisionError {    // Example: 42 / 0    DivideByZero,    // Only case for `i64`: `i64::MIN / -1` because the result is `i64::MAX + 1`    IntegerOverflow,    // Example: 5 / 2 = 2.5    NotDivisible,}fn divide(a: i64, b: i64) -&gt; Result&lt;i64, DivisionError&gt; {    if b == 0 {        Err(DivisionError::DivideByZero)    } else if a == i64::MIN &amp;&amp; b == -1 {        Err(DivisionError::IntegerOverflow)    } else if a % b == 0 {        Ok(a / b)    } else {        Err(DivisionError::NotDivisible)    }}fn result_with_list() -&gt; Result&lt;Vec&lt;i64&gt;, DivisionError&gt; {    let numbers = [27, 297, 38502, 81];    numbers.into_iter().map(|n| divide(n, 27)).collect()}fn list_of_results() -&gt; Vec&lt;Result&lt;i64, DivisionError&gt;&gt; {    let numbers = [27, 297, 38502, 81];    numbers.into_iter().map(|n| divide(n, 27)).collect()}  返回 Result&lt;Vec&lt;i32&gt;, DivisionError&gt;，表示这个函数在遇到任何错误时会立即返回错误，否则会返回包含所有成功结果的向量。  返回 Vec&lt;Result&lt;i32, DivisionError&gt;&gt;, 这个函数将所有结果（成功和失败）都收集到向量中，而不会在遇到错误时立即返回。iterators4迭代器求积fn factorial(num: u64) -&gt; u64 {    (1..=num).product()}或者使用fold但是会有警告fn factorial(num: u64) -&gt; u64 {    (1..=num).fold(1, |acc, n| acc * n)}iterators5多层的迭代use std::collections::HashMap;#[derive(Clone, Copy, PartialEq, Eq)]enum Progress {    None,    Some,    Complete,}fn count_for(map: &amp;HashMap&lt;String, Progress&gt;, value: Progress) -&gt; usize {    let mut count = 0;    for val in map.values() {        if *val == value {            count += 1;        }    }    count}fn count_iterator(map: &amp;HashMap&lt;String, Progress&gt;, value: Progress) -&gt; usize {    map.iter().filter(|x| { x.1 == &amp;value }).count()}fn count_collection_for(collection: &amp;[HashMap&lt;String, Progress&gt;], value: Progress) -&gt; usize {    let mut count = 0;    for map in collection {        for val in map.values() {            if *val == value {                count += 1;            }        }    }    count}fn count_collection_iterator(collection: &amp;[HashMap&lt;String, Progress&gt;], value: Progress) -&gt; usize {    collection.iter().map(|x| { count_iterator(x, value) }).sum()}Further information  Iterator  Iterator documentationSmart Pointers  In Rust, smart pointers are variables that contain an address in memory and reference some other data, but they also have additional metadata and capabilities.Smart pointers in Rust often own the data they point to, while references only borrow data.box用于把对象分配在堆上，也可以用于固定递归类型的数据大小，这里就是枚举递归了，所以用Box来解决#[derive(PartialEq, Debug)]enum List {    Cons(i32, Box&lt;List&gt;),    Nil,}fn create_empty_list() -&gt; List {    List::Nil}fn create_non_empty_list() -&gt; List {    List::Cons(32, Box::new(List::Nil))}rcRust的所有权使得一个对象只能有一个所有者，但在一些特殊的情况时很难处理，所以这里就引入了一个引用计数的对象Rcuse std::rc::Rc;#[derive(Debug)]struct Sun;#[allow(dead_code)]#[derive(Debug)]enum Planet {    Mercury(Rc&lt;Sun&gt;),    Venus(Rc&lt;Sun&gt;),    Earth(Rc&lt;Sun&gt;),    Mars(Rc&lt;Sun&gt;),    Jupiter(Rc&lt;Sun&gt;),    Saturn(Rc&lt;Sun&gt;),    Uranus(Rc&lt;Sun&gt;),    Neptune(Rc&lt;Sun&gt;),}impl Planet {    fn details(&amp;self) {        println!(\"Hi from {self:?}!\");    }}#[cfg(test)]mod tests {    use super::*;    #[test]    fn rc1() {        let sun = Rc::new(Sun);        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 1 reference        let mercury = Planet::Mercury(Rc::clone(&amp;sun));        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 2 references        mercury.details();        let venus = Planet::Venus(Rc::clone(&amp;sun));        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 3 references        venus.details();        let earth = Planet::Earth(Rc::clone(&amp;sun));        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 4 references        earth.details();        let mars = Planet::Mars(Rc::clone(&amp;sun));        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 5 references        mars.details();        let jupiter = Planet::Jupiter(Rc::clone(&amp;sun));        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 6 references        jupiter.details();        let saturn = Planet::Saturn(Rc::clone(&amp;sun));        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 7 references        saturn.details();        let uranus = Planet::Uranus(Rc::clone(&amp;sun));        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 8 references        uranus.details();        let neptune = Planet::Neptune(Rc::clone(&amp;sun));        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 9 references        neptune.details();        assert_eq!(Rc::strong_count(&amp;sun), 9);        drop(neptune);        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 8 references        drop(uranus);        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 7 references        drop(saturn);        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 6 references        drop(jupiter);        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 5 references        drop(mars);        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 4 references        drop(earth);        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 3 references        drop(venus);        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 2 references        drop(mercury);        println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 1 reference        assert_eq!(Rc::strong_count(&amp;sun), 1);    }}arc对于单线程场景，rc性能更高，但是在多线程场景并不适用，所以增加了Arc在多线程场景，当然性能会有损耗#![forbid(unused_imports)]use std::{sync::Arc, thread};fn main() {    let numbers: Vec&lt;_&gt; = (0..100u32).collect();    let shared_numbers = Arc::new(numbers);    let mut join_handles = Vec::new();    for offset in 0..8 {        let child_numbers = Arc::clone(&amp;shared_numbers);        let handle = thread::spawn(move || {            let sum: u32 = child_numbers.iter().filter(|&amp;&amp;n| n % 8 == offset).sum();            println!(\"Sum of offset {offset} is {sum}\");        });        join_handles.push(handle);    }    for handle in join_handles.into_iter() {        handle.join().unwrap();    }}cow可以指向一个借用的（&amp;T）或拥有的（T）数据。这对于处理那些可能需要克隆数据以进行修改的场景非常有用，但在大多数情况下只是读取数据，从而避免不必要的克隆开销。Cow常用于优化性能，特别是当你有只读和少数写入的场景。它可以帮助你延迟克隆数据，直到真的需要修改数据时才进行克隆。use std::borrow::Cow;fn abs_all(input: &amp;mut Cow&lt;[i32]&gt;) {    for ind in 0..input.len() {        let value = input[ind];        if value &lt; 0 {            input.to_mut()[ind] = -value;        }    }}#[cfg(test)]mod tests {    use super::*;    #[test]    fn reference_mutation() {        let vec = vec![-1, 0, 1];        let mut input = Cow::from(&amp;vec);        abs_all(&amp;mut input);        assert!(matches!(input, Cow::Owned(_)));    }    #[test]    fn reference_no_mutation() {        let vec = vec![0, 1, 2];        let mut input = Cow::from(&amp;vec);        abs_all(&amp;mut input);        assert!(matches!(input, Cow::Borrowed(_)));    }    #[test]    fn owned_no_mutation() {        let vec = vec![0, 1, 2];        let mut input = Cow::from(vec);        abs_all(&amp;mut input);        assert!(matches!(input, Cow::Owned(_)));    }    #[test]    fn owned_mutation() {        let vec = vec![-1, 0, 1];        let mut input = Cow::from(vec);        abs_all(&amp;mut input);        assert!(matches!(input, Cow::Owned(_)));    }}Further Information  Smart Pointers  Using Box to Point to Data on the Heap  Rc&lt;T&gt;, the Reference Counted Smart Pointer  Shared-State Concurrency  Cow DocumentationThreads  In most current operating systems, an executed program’s code is run in a process, and the operating system manages multiple processes at once.Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called threads.Further information  Dining Philosophers example  Using Threads to Run Code Simultaneously  Using Message Passing to Transfer Data Between Threads"
  },
  
  {
    "title": "Ubuntu安装Anaconda3创建python环境",
    "url": "/posts/anaconda3/",
    "categories": "Ubuntu",
    "tags": "anaconda",
    "date": "2024-05-20 12:42:00 +0800",
    





    "snippet": "下载Anaconda3这里使用的ubuntu版本为20.04，python版本对应的是3.10，根据release-notes可以看出，最新版也是支持3.10的，所以直接下载最新版官网下载或者清华源，我这里直接命令行下载最新版wget https://repo.anaconda.com/archive/Anaconda3-2024.02-1-Linux-x86_64.sh因为需要安装在非root用户下，所以给他增加执行权限chmod 777 Anaconda3-2024.02-1-Linux-x86_64.sh运行安装，需要注意，这里协议查看是，直接按空格也是可以跳过的，不一定是回车，回车可能导致点多了退出./Anaconda3-2024.02-1-Linux-x86_64.sh最后输入yes，然后等待下载和安装初始化前面的安装，anaconda会安装到用户目录下，所以配置export PATH=\"/home/jiangker/anaconda3/bin:$PATH\"到~/.zshrc，然后运行source ~/.zshrc然后运行目录conda init zsh就会创建最基础的初始化配置，然后再次运行source ~/.zshrc，看到最前面出现了(base)则表示初始化成功，目前环境为base环境创建python环境conda create --name yolov5 python=3.10激活环境conda activate yolov5即可看到已经成功切换了环境，这时就可以正常使用python了"
  },
  
  {
    "title": "Ubuntu开启SSH访问",
    "url": "/posts/openssh/",
    "categories": "Ubuntu",
    "tags": "ssh",
    "date": "2024-05-11 11:39:00 +0800",
    





    "snippet": "安装SSH服务器sudo apt updatesudo apt install -y openssh-server启动SSH服务sudo systemctl start ssh确认SSH服务状态sudo systemctl status ssh（可选）设置防火墙sudo ufw allow ssh设置SSH服务为开机启动sudo systemctl enable ssh"
  },
  
  {
    "title": "Docker部署yolov5服务",
    "url": "/posts/docker_yolov5/",
    "categories": "Other",
    "tags": "yolov5",
    "date": "2024-04-23 15:31:00 +0800",
    





    "snippet": "简介yolov5是由python实现的，所以这里简单直接的去部署一个python的server来直接使用yolov5，用的是最新master分支，服务器为ubuntu20.04。运行容器首先需要下载代码在服务端路径下，运行容器时进行关联，然后在容器中进行使用，这里容器直接使用最基础的环境，然后进行配置即可。sudo docker run --name yolov5 -p 8888:8888 -e TZ=Asia/Shanghai -v /home/docker/yolov5:/counting -d ubuntu:20.04 /bin/bash进入容器内部进行配置sudo docker exec -it yolov5 /bin/bash下载python3和pipapt-get update &amp;&amp; apt-get install -y python3 python3-pip 下载运行依赖的环境apt-get install -y libgl1 libglib2.0-0进入yolov5目录cd counting下载依赖pip install -r requirements.txt运行项目python3 server.py异常情况libgl1ImportError: libGL.so.1: cannot open shared object file: No such file or directorylibglib2.0-0如果没有安装libgl1可能出现如下异常ImportError: libgthread-2.0.so.0: cannot open shared object file: No such file or directoryNotImplementedError: cannot instantiate ‘WindowsPath’ on your system如果提示如题这样的错误，可能是因为是在Windows环境训练的模型，然后在linux下使用导致的问题，可以考虑在detect.py文件头部加上如下代码import pathlibtemp = pathlib.PosixPathpathlib.WindowsPath = pathlib.PosixPathNotImplementedError: cannot instantiate ‘WindowsPath’ on your system when load .pkl file in prod environtment"
  },
  
  {
    "title": "Docker安装Zookeeper",
    "url": "/posts/docker_zookeeper/",
    "categories": "Other",
    "tags": "zookeeper",
    "date": "2024-04-22 17:28:00 +0800",
    





    "snippet": "创建目录文件mkdir zookeeper &amp;&amp; cd zookeeper运行容器docker run -d -e TZ=\"Asia/Shanghai\" -p 2181:2181 -v $PWD/data:/data --name zookeeper --restart always zookeeper"
  },
  
  {
    "title": "Docker安装Minio",
    "url": "/posts/docker_minio/",
    "categories": "Other",
    "tags": "docker, Minio",
    "date": "2024-04-02 11:25:00 +0800",
    





    "snippet": "创建目录文件mkdir -p /home/docker/minio/data/运行容器docker run -p 9000:9000 -p 9001:9001 --name minio \\-v /home/docker/minio/data:/data \\-e MINIO_ROOT_USER=minioadmin \\-e MINIO_ROOT_PASSWORD=minioadmin \\-d minio/minio server /data --console-address \":9001\""
  },
  
  {
    "title": "Docker安装MongoDB",
    "url": "/posts/docker_mongodb/",
    "categories": "Other",
    "tags": "docker, MongoDB",
    "date": "2024-04-02 10:20:00 +0800",
    





    "snippet": "创建目录文件mkdir -p /home/docker/mongodb/conf/mkdir -p /home/docker/mongodb/data/mkdir -p /home/docker/mongodb/logs/增加配置文件cd /home/docker/mongodb/conf &amp;&amp; vim mongod.conf增加内容# 数据库文件存储位置dbpath = /data/db# log文件存储位置logpath = /data/log/mongod.log# 使用追加的方式写日志logappend = true# 是否以守护进程方式运行# fork = true# 全部ip可以访问bind_ip = 0.0.0.0# 端口号port = 27017# 是否启用认证auth = true# 设置oplog的大小(MB)oplogSize=2048增加log文件cd /home/docker/mongodb/logs/ &amp;&amp; vi mongod.logchmod  777 mongod.log 运行容器docker run \\\t--name mongodb \\\t--restart=always \\    --privileged \\    -p 27017:27017 \\    -v /home/docker/mongodb/data:/data/db \\    -v /home/docker/mongodb/conf:/data/configdb \\    -v /home/docker/mongodb/logs:/data/log/  \\    -d mongo:latest \\    -f /data/configdb/mongod.conf修改配置进入容器docker exec -it mongodb /bin/bash进入mongodbmongo切换到admin库use admin创建账号/密码db.createUser({ user: 'admin', pwd: 'admin', roles: [ { role: \"userAdminAnyDatabase\", db: \"admin\" } ] });"
  },
  
  {
    "title": "Docker安装ActiveMQ",
    "url": "/posts/docker_activemq/",
    "categories": "Other",
    "tags": "docker, active mq",
    "date": "2024-03-12 10:56:00 +0800",
    





    "snippet": "docker 安装docker run -d --name activemq -p 61616:61616 -p 8161:8161 webcenter/activemq:latest61616端口用于程序调用，8161用于web访问，默认账户密码为admin/admin"
  },
  
  {
    "title": "Clean Code",
    "url": "/posts/clean_code/",
    "categories": "Other",
    "tags": "standard",
    "date": "2023-12-06 08:50:00 +0800",
    





    "snippet": "2 有意义的命名2.9 类名类名和对象名应该是名词或名词短语，而不应该为动词。2.10 方法名方法名应该是动词或动词短语。属性访问器、修改器和断言应该根据其值命名，并根据Javabean标准加上get、set、is前缀3 函数3.1 短小函数应该短小，每个函数才能一目了然，每个函数只做一件事情，每个函数都是依次把你带到下一个函数。3.2 只做一件事函数应该做一件事，做好这件事。编写函数毕竟事为了把大的一些概念拆分为另一抽象层面上的一系列步骤。3.3 每个函数都在一个抽象层级上面3.6 函数参数减少函数的参数，多作为成员变量或者方法4 注释尽量使用名称去传达信息而非注释，变更代码时需要及时维护注释，否则注释反倒可能起到误导作用。注释可以用来警示其他程序员会出现某种后果的注释也是有用的。言简意赅的表达出想要的意思，别使用很废话的注释。如果有需要注释掉的代码，最好直接删除，否则会导致后面的人不敢删，也不知道到底为什么在那。注释要让读者好懂，理解注释所谈为何物，如果注释本事都还需要解释，那就是糟糕的注释。5 垂直顺序被调用的函数应该放在被执行调用的函数下面，紧密相关的代码应该相互靠近。建立一种自顶向下贯穿源代码模块的良好信息流。每个人都会有自己习惯喜欢的格式规则，但如果在一个团队中工作，就应该遵循一起定制的规则。9 单元测试测试代码和生产代码一样重要，它需要被思考、被设计和被照料。它该像生产代码一样保持整洁。单元测试可以让代码可扩展、可维护、可复用。单元测试需要做到：可读性10 类单一职责：系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。内聚：类应该只有少量实体变量。类中的每个方法都应该操作一个或多个这种变量。如果一个类中的每一个变量都被每个方法所使用，则该类具有最大的内聚性。隔离也让对系统每个元素的理解变得更加容易。12 跌进重复是拥有良好设计系统的大敌，它代表着额外的工作、额外的风险和额外且不必要的复杂度。重复有多种表现，极其雷同的代码行当然是重复的。类似的代码往往也可以调整的更相似，这样就可以更容易的进行重构。"
  },
  
  {
    "title": "shell脚本",
    "url": "/posts/shell/",
    "categories": "Other",
    "tags": "shell",
    "date": "2023-12-06 08:48:00 +0800",
    





    "snippet": "第一个Shell脚本shell脚本以时候结尾，所以创建test.sh文件#!/bin/bashecho \"Hello World !\"#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。运行脚本chmod +x ./test.sh  #使脚本具有执行权限./test.sh  #执行脚本变量      命名    # 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。# 等号左右不能有空格your_name=\"jiangker.icu\"  # 使用别的语句给变量赋值# 循环出目录下文件名称for file in `ls /etc`或for file in $(ls /etc)  # 重新命名变量时不需要使用$符号，使用值时才需要加your_name=\"jiang\"echo ${your_name}your_name=\"jiangker\"echo ${your_name}  # 只读变量，后续不能再重新赋值myUrl=\"https://www.jiangker.icu\"readonly myUrl  #删除变量,unset 命令不能删除只读变量。unset variable_name            使用    # 使用变量时使用$符号，最好也带上括号# 循环输出根目录文件名称for name in $(ls ~);do    echo ${name}done            字符串操作    # 单引号声明变量,不能有单独的一个单引号，不能转义字符str='jiangker'echo 'my name is '$str' .' # 这种用法单双引号都可以# 双引号声明变量str=\"jiangker\"echo \"my name is ${str} .\" # 这种只能双引号  # 获取字符串长度str=\"jiangker\"echo ${#str} # 输出7# 提取子字符串echo ${str:1:4} # 输出iang      数组array_name=(value0 value1 value2 value3)# 或array_name=(value0value1value2value3)# 或array_name[0]=value0array_name[1]=value1array_name[n]=valuen# 读取元素name=${array_name[0]}# @表示所有元素echo ${array_name[@]}# 取得数组元素的个数length=${#array_name[@]}# 或者length=${#array_name[*]}# 取得数组单个元素的长度lengthn=${#array_name[n]}传递参数脚本内容echo \"Shell 传递参数实例！\";echo \"第一个参数为：$1\";echo \"第二个参数为：${2}\";echo \"参数个数为：$#\";echo \"传递的参数作为一个字符串显示：$*\";调用脚本./test.sh j k输出Shell 传递参数实例！第一个参数为：j第二个参数为：k参数个数为：2传递的参数作为一个字符串显示：j k参数判断测试语句格式：[ 条件表达式 ]  文件测试语句  逻辑测试语句  整数值比较语句  字符串比较语句文件测试语句            运算符      作用                  -d      测试文本是否为目录类型              -e      测试文件是否存在              -f      判断是否为一般文件              -r      测试当前用户是否拥有可读权限              -w      测试当前用户是否拥有可写权限              -x      测试当前用户是否有权限执行      ## 测试结果[ -d /etc/fstab ]## 获取上次结果echo $?## 也可以[ -e /dev/cdrom ] &amp;&amp; echo \"Exist\"# &amp;&amp; 前面语句成立执行，||前面条件不成立执行，组合类似if else[ $USER = root ] &amp;&amp; echo \"root\" || echo \"user\"整数比较运算符            运算符      作用                  -eq      是否等于              -ne      是否不等于              -gt      是否大于              -lt      是否小于              -le      是否小于或等于              -ge      是否大于或等于      字符串比较            运算符      作用                  =      内容是否相等              !=      是否不同              -z      是否为空      [ -z $SHELL ]echo $?if语句if [ true ]then\techo \"if\"elif\techo \"else if\"else\techo \"else\"fifor循环for name in (list)do\t# commanddonewhilewhile truedo \t# commanddone"
  },
  
  {
    "title": "设计模式原则",
    "url": "/posts/disign_principle/",
    "categories": "Design Patterns",
    "tags": "principle",
    "date": "2023-12-05 18:47:00 +0800",
    





    "snippet": "1.单一职责原则  就一个类而言，应该仅有一个引起它变化的原因。不要让一个类承担过多的职责。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会消弱或者抑制这个类完成其他职责的能力。这些耦合会导致脆弱的设计，当变化发生时，设计会遭受到破坏。2.开放封闭原则  类、模块、函数等应该是可以拓展的，但是不可以修改。对拓展开放，对修改封闭。在做程序设计时，需要保留足够的可拓展性，面对需求的变更时最好采取拓展的方式去实现，而非对原有类的修改。3.里氏替换原则  所有引用父类的地方必须能够透明的使用其子类的对象。在软件中将一个父类对象替换成其子类对象时，程序不应该产生任何错误和异常。里氏替换原则是实现开放封闭原则的重要方式之一。4.迪米特原则  一个软件实体应当尽可能少的与其他实体发生相互作用。也可以叫做最少知道原则。如果一个系统符合迪米特原则，那么当其中某一个模块发生修改时，就会尽量少的影响其他模块。迪米特原则要求我们在设计系统时，应该尽量减少对象之间的相互作用。系统设计时需要注意以下几点：  在类的划分上，应当尽量创建松耦合的类。类之间的耦合度越低，就越有利于复用。一个处在松耦合中的类一旦被修改，则不会对关联的类造成太大波及。  在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限。  在对其他类的引用上，一个对象对其他对象的引用应当将到最低。5.依赖倒置原则  高层模块不应该依赖低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。模块间的依赖通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口或者抽象类产生的。如果类与类直接依赖细节，那么就会直接耦合。如此一来当修改时，就会同时修改依赖着代码，这样限制了可扩展性。6.接口隔离原则  一个类对另一个类的依赖应该建立在最小的接口上。建立单一接口，不要建立庞大臃肿的接口；尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图建立一个庞大的接口供所有依赖它的类调用。采用接口隔离原则对接口进行约束时，要注意以下几点：  接口尽量小，但是要有限度。对接口进行细化可以提高程序设计的灵活性；但是如果过小，则会造成接口数量过多，使设计复杂化。所以，一定要适度。  为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注的微一个模块提供定制服务，才能建立最小的依赖关系。  提高内聚，减少对外交互。接口方法尽量少用public修饰，接口是对外的承诺，承诺越少对系统的开发越有利，变更风险也会越少。参考  Android进阶之光"
  },
  
  {
    "title": "Java虚拟机",
    "url": "/posts/jvm/",
    "categories": "Java",
    "tags": "JVM",
    "date": "2023-12-05 11:28:00 +0800",
    





    "snippet": "  JDK(Java Development Kit) 包含Java语言、Java虚拟机、Java Api 类库，是Java程序开发的最小环境。而JRE(Java Runtime Environment)包含了Java Api中的Java SE Api子集和Java虚拟机这两部分，是Java程序运行的标准环境。执行流程java文件首先在编译环境下编译成为可以运行的.class文件，然后由Java虚拟机运行。java文件和虚拟机并没有直接的联系，只是特定的二进制文件，例如kotlin、Groovy等语言都可以编译成class文件，在JVM中运行。类加载器类与类加载器判断类是否“相等”任意一个类，都由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。因此，比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必定不相等。这里的“相等”，包括代表类的 Class 对象的 equals() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。加载器种类系统提供了 3 种类加载器：  Bootstrap ClassLoader（引导类加载器）： 用C/C++代码实现的加载器，用于加载指定的JDK核心类库，如java.lang、java.util等系统类，目录如下：          &lt;JAVA_HOME&gt;\\lib 目录（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中      -Xbootclasspath参数指定的目录  Java 虚拟机的启动就是通过引导类加载器创建的一个初始类完成的。由于是由C语言实现的，所以Java代码并不能访问，但是我们可以查询某个类是否被引导类加载器加载过。        Extension ClassLoader（拓展类加载器）： 加载Java的拓展类，提供除了系统类之外的额外功能。          &lt;JAVA_HOME&gt;\\lib\\ext 目录中的所有类库。      系统属性java.ext.dir所指定的目录。        Application ClassLoader(应用程序类加载器)： 由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为“系统类加载器”。它负责加载用户类路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。当然，如果有必要，还可以加入自己定义的类加载器。双亲委派模型什么是双亲委派模型双亲委派模型是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码）工作过程如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。在 java.lang.ClassLoader 中的 loadClass 方法中实现该过程。为什么使用双亲委派模型像 java.lang.Object 这些存放在 rt.jar 中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的 Object 类都是同一个。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 classpath 下，那么系统将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证。类加载的时机类的生命周期类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括以下 7 个阶段：  加载  验证  准备  解析  初始化  使用  卸载验证、准备、解析 3 个阶段统称为连接。加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始（注意是“开始”，而不是“进行”或“完成”），而解析阶段则不一定：它在某些情况下可以在初始化后再开始，这是为了支持 Java 语言的运行时绑定。类加载过程中“初始化”开始的时机Java 虚拟机规范没有强制约束类加载过程的第一阶段（即：加载）什么时候开始，但对于“初始化”阶段，有着严格的规定。有且仅有 5 种情况必须立即对类进行“初始化”：  在遇到 new、putstatic、getstatic、invokestatic 字节码指令时，如果类尚未初始化，则需要先触发其初始化。  对类进行反射调用时，如果类还没有初始化，则需要先触发其初始化。  初始化一个类时，如果其父类还没有初始化，则需要先初始化父类。  虚拟机启动时，用于需要指定一个包含 main() 方法的主类，虚拟机会先初始化这个主类。  当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。这 5 种场景中的行为称为对一个类进行主动引用，除此之外，其它所有引用类的方式都不会触发初始化，称为被动引用。被动引用演示 DemoDemo1/** * 被动引用 Demo1: * 通过子类引用父类的静态字段，不会导致子类初始化。 * * @author ylb * */class SuperClass {    static {        System.out.println(\"SuperClass init!\");    }    public static int value = 123;}class SubClass extends SuperClass {    static {        System.out.println(\"SubClass init!\");    }}public class NotInitialization {    public static void main(String[] args) {        System.out.println(SubClass.value);        // SuperClass init!    }}对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。Demo2/** * 被动引用 Demo2: * 通过数组定义来引用类，不会触发此类的初始化。 * * @author ylb * */public class NotInitialization {    public static void main(String[] args) {        SuperClass[] superClasses = new SuperClass[10];    }}这段代码不会触发父类的初始化，但会触发“[L 全类名”这个类的初始化，它由虚拟机自动生成，直接继承自 java.lang.Object，创建动作由字节码指令 newarray 触发。Demo3/** * 被动引用 Demo3: * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 * * @author ylb * */class ConstClass {    static {        System.out.println(\"ConstClass init!\");    }    public static final String HELLO_BINGO = \"Hello Bingo\";}public class NotInitialization {    public static void main(String[] args) {        System.out.println(ConstClass.HELLO_BINGO);    }}编译通过之后，常量存储到 NotInitialization 类的常量池中，NotInitialization 的 Class 文件中并没有 ConstClass 类的符号引用入口，这两个类在编译成 Class 之后就没有任何联系了。接口的加载过程接口加载过程与类加载过程稍有不同。当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。类加载的过程类加载过程包括 5 个阶段：加载、验证、准备、解析和初始化。加载加载的过程“加载”是“类加载”过程的一个阶段，不能混淆这两个名词。在加载阶段，虚拟机需要完成 3 件事：  通过类的全限定名获取该类的二进制字节流。  将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。  在内存中创建一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。获取二进制字节流对于 Class 文件，虚拟机没有指明要从哪里获取、怎样获取。除了直接从编译好的 .class 文件中读取，还有以下几种方式：  从 zip 包中读取，如 jar、war 等  从网络中获取，如 Applet  通过动态代理技术生成代理类的二进制字节流  由 JSP 文件生成对应的 Class 类  从数据库中读取，如 有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。“非数组类”与“数组类”加载比较  非数组类加载阶段可以使用系统提供的引导类加载器，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器控制字节流的获取方式（如重写一个类加载器的 loadClass() 方法）  数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的，再由类加载器创建数组中的元素类。注意事项  虚拟机规范未规定 Class 对象的存储位置，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但存放在方法区中。  加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始了。但这两个阶段的开始时间仍然保持着固定的先后顺序。验证验证的重要性验证阶段确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证的过程  文件格式验证 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下：          是否以魔数 0XCAFEBABE 开头      主次版本号是否在当前虚拟机处理范围内      常量池是否有不被支持的常量类型      指向常量的索引值是否指向了不存在的常量      CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据      ……        元数据验证 对字节码描述信息进行语义分析，确保其符合 Java 语法规范。  字节码验证 本阶段是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。  符号引用验证 本阶段发生在解析阶段，确保解析正常执行。准备准备阶段是正式为类变量（或称“静态成员变量”）分配内存并设置初始值的阶段。这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。初始值“通常情况下”是数据类型的零值（0, null…），假设一个类变量的定义为：public static int value = 123;那么变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法。存在“特殊情况”：如果类字段的字段属性表中存在 ConstantValue 属性，那么在准备阶段 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为：public static final int value = 123;那么在准备阶段虚拟机会根据 ConstantValue 的设置将 value 赋值为 123。解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。初始化类初始化阶段是类加载过程的最后一步，是执行类构造器 &lt;clinit&gt;() 方法的过程。&lt;clinit&gt;() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。如下方代码所示：public class Test {    static {        i = 0;  // 给变量赋值可以正常编译通过        System.out.println(i);  // 这句编译器会提示“非法向前引用”    }    static int i = 1;}&lt;clinit&gt;() 方法不需要显式调用父类构造器，虚拟机会保证在子类的 &lt;clinit&gt;() 方法执行之前，父类的 &lt;clinit&gt;() 方法已经执行完毕。由于父类的 &lt;clinit&gt;() 方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下方代码所示：static class Parent {    public static int A = 1;    static {        A = 2;    }}static class Sub extends Parent {    public static int B = A;}public static void main(String[] args) {    System.out.println(Sub.B); // 输出 2}&lt;clinit&gt;() 方法不是必需的，如果一个类没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 &lt;clinit&gt;() 方法。接口中不能使用静态代码块，但接口也需要通过 &lt;clinit&gt;() 方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的 &lt;clinit&gt;() 方法不需要先执行父类的 &lt;clinit&gt;() 方法，只有当父接口中定义的变量使用时，父接口才会初始化。虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 &lt;clinit&gt;() 方法。JVM 内存结构Java 虚拟机的内存空间分为 5 个部分：  程序计数器  Java 虚拟机栈  本地方法栈  堆  方法区JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。程序计数器（PC 寄存器）程序计数器的定义程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为Undefined。程序计数器的作用  字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。  在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。程序计数器的特点  是一块较小的内存空间。  线程私有，每条线程都有自己的程序计数器。  生命周期：随着线程的创建而创建，随着线程的结束而销毁。  是唯一一个不会出现OutOfMemoryError的内存区域。Java 虚拟机栈（Java 栈）Java 虚拟机栈的定义Java 虚拟机栈是描述 Java 方法运行过程的内存模型。Java 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：  局部变量表  操作数栈  动态链接  方法出口信息  ……压栈出栈过程当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。  由于 Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。Java 虚拟机栈的特点  局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。  Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。          StackOverFlowError 若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。      OutOfMemoryError 若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。        Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。  出现 StackOverFlowError 时，内存空间可能还有很多。本地方法栈本地方法栈的定义本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。栈帧变化过程本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。  如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。堆堆的定义堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。堆的特点  线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。  在虚拟机启动时创建。  是垃圾回收的主要场所。  进一步可分为：新生代（Eden 区：From Survior，To Survivor）、老年代。不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。  Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。方法区方法区的定义Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：  已经被虚拟机加载的类信息  常量  静态变量  即时编译器编译后的代码方法区的特点  线程共享。 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。  永久代。 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。  内存回收效率低。 方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。  Java 虚拟机规范对方法区的要求比较宽松。 和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。运行时常量池方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 intern() 方法就能在运行期间向常量池中添加字符串常量。直接内存（堆外内存）直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。操作直接内存在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的DirectByteBuffer对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。直接内存与堆内存比较  直接内存申请空间耗费更高的性能  直接内存读取 IO 的性能要优于普通的堆内存。  直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO  堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO  服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。垃圾收集策略与算法程序计数器、虚拟机栈、本地方法栈随线程而生，也随线程而灭；栈帧随着方法的开始而入栈，随着方法的结束而出栈。这几个区域的内存分配和回收都具有确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而对于 Java 堆和方法区，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的正是这部分内存。判定对象是否存活若一个对象不被任何对象或变量引用，那么它就是无效对象，需要被回收。引用计数法在对象头维护着一个 counter 计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了。引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是主流的 Java 虚拟机里没有选用引用计数算法来管理内存，主要是因为它很难解决对象之间循环引用的问题。  举个栗子 👉 对象 objA 和 objB 都有字段 instance，令 objA.instance = objB 并且 objB.instance = objA，由于它们互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们。可达性分析法所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效对象。GC Roots 是指：  Java 虚拟机栈（栈帧中的本地变量表）中引用的对象  本地方法栈中引用的对象  方法区中常量引用的对象  方法区中类静态属性引用的对象GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。引用的种类判定对象是否存活与“引用”有关。在 JDK 1.2 以前，Java 中的引用定义很传统，一个对象只有被引用或者没有被引用两种状态，我们希望能描述这一类对象：当内存空间还足够时，则保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为了以下四种。不同的引用类型，主要体现的是对象不同的可达性状态reachable和垃圾收集的影响。强引用（Strong Reference）类似 “Object obj = new Object()” 这类的引用，就是强引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。但是，如果我们错误地保持了强引用，比如：赋值给了 static 变量，那么对象在很长一段时间内不会被回收，会产生内存泄漏。软引用（Soft Reference）软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。弱引用（Weak Reference）弱引用的强度比软引用更弱一些。当 JVM 进行垃圾回收时，无论内存是否充足，都会回收只被弱引用关联的对象。虚引用（Phantom Reference）虚引用也称幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。它仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。回收堆中无效对象对于可达性分析中不可达的对象，也并不是没有存活的可能。判定 finalize() 是否有必要执行JVM 会判断此对象是否有必要执行 finalize() 方法，如果对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么视为“没有必要执行”。那么对象基本上就真的被回收了。如果对象被判定为有必要执行 finalize() 方法，那么对象会被放入一个 F-Queue 队列中，虚拟机会以较低的优先级执行这些 finalize()方法，但不会确保所有的 finalize() 方法都会执行结束。如果 finalize() 方法出现耗时操作，虚拟机就直接停止指向该方法，将对象清除。对象重生或死亡如果在执行 finalize() 方法时，将 this 赋给了某一个引用，那么该对象就重生了。如果没有，那么就会被垃圾收集器清除。  任何一个对象的 finalize() 方法只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行，想继续在 finalize() 中自救就失效了。回收方法区内存方法区中存放生命周期较长的类信息、常量、静态变量，每次垃圾收集只有少量的垃圾被清除。方法区中主要清除两种垃圾：  废弃常量  无用的类判定废弃常量只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。比如，一个字符串 “bingo” 进入了常量池，但是当前系统没有任何一个 String 对象引用常量池中的 “bingo” 常量，也没有其它地方引用这个字面量，必要的话，”bingo”常量会被清理出常量池。判定无用的类判定一个类是否是“无用的类”，条件较为苛刻。  该类的所有对象都已经被清除  加载该类的 ClassLoader 已经被回收  该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。  一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载进方法区时创建，在方法区该类被删除时清除。垃圾收集算法学会了如何判定无效对象、无用类、废弃常量之后，剩余工作就是回收这些垃圾。常见的垃圾收集算法有以下几个：标记-清除算法标记的过程是：遍历所有的 GC Roots，然后将所有 GC Roots 可达的对象标记为存活的对象。清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。与此同时，清除那些被标记过的对象的标记，以便下次的垃圾回收。这种方法有两个不足：  效率问题：标记和清除两个过程的效率都不高。  空间问题：标记清除之后会产生大量不连续的内存碎片，碎片太多可能导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。复制算法（新生代）为了解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完，需要进行垃圾收集时，就将存活者的对象复制到另一块上面，然后将第一块内存全部清除。这种算法有优有劣：  优点：不会有内存碎片的问题。  缺点：内存缩小为原来的一半，浪费空间。为了解决空间利用率问题，可以将内存分为三块： Eden、From Survivor、To Survivor，比例是 8:1:1，每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。但是我们无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够，需要依赖其他内存（指老年代）进行分配担保。分配担保为对象分配内存空间时，如果 Eden+Survivor 中空闲区域无法装下该对象，会触发 MinorGC 进行垃圾收集。但如果 Minor GC 过后依然有超过 10% 的对象存活，这样存活的对象直接通过分配担保机制进入老年代，然后再将新对象存入 Eden 区。标记-整理算法（老年代）标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历 GC Roots，然后将存活的对象标记。整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。这是一种老年代的垃圾收集算法。老年代的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，如果采用复制算法，每次需要复制大量存活的对象，效率很低。分代收集算法根据对象存活周期的不同，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，针对各个年代的特点采用最适当的收集算法。  新生代：复制算法  老年代：标记-清除算法、标记-整理算法内存分配与回收策略对象的内存分配，就是在堆上分配（也可能经过 JIT 编译后被拆散为标量类型并间接在栈上分配），对象主要分配在新生代的 Eden 区上，少数情况下可能直接分配在老年代，分配规则不固定，取决于当前使用的垃圾收集器组合以及相关的参数配置。以下列举几条最普遍的内存分配规则，供大家学习。对象优先在 Eden 分配大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。👇Minor GC vs Major GC/Full GC：  Minor GC：回收新生代（包括 Eden 和 Survivor 区域），因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。  Major GC / Full GC: 回收老年代，出现了 Major GC，经常会伴随至少一次的 Minor GC，但这并非绝对。Major GC 的速度一般会比 Minor GC 慢 10 倍 以上。  在 JVM 规范中，Major GC 和 Full GC 都没有一个正式的定义，所以有人也简单地认为 Major GC 清理老年代，而 Full GC 清理整个内存堆。大对象直接进入老年代大对象是指需要大量连续内存空间的 Java 对象，如很长的字符串或数据。一个大对象能够存入 Eden 区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及大量的复制，就会造成效率低下。虚拟机提供了一个 -XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制。（还记得吗，新生代采用复制算法回收垃圾）长期存活的对象将进入老年代JVM 给每个对象定义了一个对象年龄计数器。当新生代发生一次 Minor GC 后，存活下来的对象年龄 +1，当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。使用 -XXMaxTenuringThreshold 设置新生代的最大年龄，只要超过该参数的新生代对象都会被转移到老年代中去。动态对象年龄判定如果当前新生代的 Survivor 中，相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄 &gt;= 该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。空间分配担保JDK 6 Update 24 之前的规则是这样的：在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间， 如果这个条件成立，Minor GC 可以确保是安全的； 如果不成立，则虚拟机会查看 HandlePromotionFailure 值是否设置为允许担保失败， 如果是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于，将尝试进行一次 Minor GC,尽管这次 Minor GC 是有风险的； 如果小于，或者 HandlePromotionFailure 设置不允许冒险，那此时也要改为进行一次 Full GC。JDK 6 Update 24 之后的规则变为：只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代作担保。这个过程就是分配担保。👇 总结一下有哪些情况可能会触发 JVM 进行 Full GC。      System.gc() 方法的调用此方法的调用是建议 JVM 进行 Full GC，注意这只是建议而非一定，但在很多情况下它会触发 Full GC，从而增加 Full GC 的频率。通常情况下我们只需要让虚拟机自己去管理内存即可，我们可以通过 -XX:+ DisableExplicitGC 来禁止调用 System.gc()。        老年代空间不足老年代空间不足会触发 Full GC 操作，若进行该操作后空间依然不足，则会抛出如下错误：java.lang.OutOfMemoryError: Java heap space        永久代空间不足JVM 规范中运行时数据区域中的方法区，在 HotSpot 虚拟机中也称为永久代（Permanet Generation），存放一些类信息、常量、静态变量等数据，当系统要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，会触发 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space         CMS GC 时出现 promotion failed 和 concurrent mode failurepromotion failed，就是上文所说的担保失败，而 concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足造成的。        统计得到的 Minor GC 晋升到旧生代的平均大小大于老年代的剩余空间  "
  },
  
  {
    "title": "单例模式",
    "url": "/posts/singleton_pattern/",
    "categories": "Design Patterns",
    "tags": "singleton",
    "date": "2023-12-01 14:00:00 +0800",
    





    "snippet": "  保证一个类仅有一个实例，并提供一个访问它的全局访问点。1. 单例模式的6种写法饿汉模式class Singleton private constructor(){    companion object{        private val instance = Singleton()        fun getInstance() = instance    }}这种方式在类加载时就完成了初始化，所以类加载较慢，但获取时较快，并且线程安全。对于kotlin来说object就是一个饿汉模式的单例。懒汉模式class Singleton private constructor() {    companion object {        private var instance: Singleton? = null        fun getInstance(): Singleton {            return instance ?: Singleton().also { instance = it }        }    }}好处是在使用时再初始化，避免内存浪费，但是最大的问题是线程不安全。懒汉模式升级版class Singleton private constructor() {    companion object {        private var instance: Singleton? = null        @Synchronized        fun getInstance(): Singleton {            return instance ?: Singleton().also { instance = it }        }    }}在基础的懒汉模式基础上加入了锁，避免了线程不安全的问题，但是引入了一个新的问题，就是每一次获取实例都需要加锁，造成了不必要的开销。双重检查模式class Singleton private constructor() {    companion object {        @Volatile        private var instance: Singleton? = null        fun getInstance(): Singleton {            return instance ?: synchronized(Singleton::class) {                instance ?: Singleton().also { instance = it }            }        }    }}这也算是懒汉模式的升级版，只在初始化时加锁，后续使用不再加锁，减少了不必要的开销。第一次判空避免了不必要的加锁，第二次判空保证了只创建一次。静态内部类单例模式class Singleton private constructor() {    private class SingletonHolder {        companion object {            internal val sInstance = Singleton()        }    }    companion object {        fun getInstance(): Singleton = SingletonHolder.sInstance    }}枚举单例enum class Singleton {    INSTANCE;}"
  },
  
  {
    "title": "Gradle多模块配置以及变体",
    "url": "/posts/gradle-variant/",
    "categories": "Android",
    "tags": "gradle",
    "date": "2023-12-01 12:39:00 +0800",
    





    "snippet": "1 创建gradle文件在project的build.gradle同级目录下创建config.gradleext {    //测试版和上线版控制    isRelease = false    androidID = [compileSdkVersion: 29,                 buildToolsVersion: \"29.0.3\",                 applicationId    : \"jfp.study.coding_android\",                 minSdkVersion    : 21,                 targetSdkVersion : 29,                 versionCode      : 1,                 versionName      : \"1.0\",    ]    dependenciesID = [            retrofit      : 'com.squareup.retrofit2:retrofit:2.6.1',            converter_gson: 'com.squareup.retrofit2:converter-gson:2.6.1'    ]    url = [            debug  : \"http:www.debug.com\",            release: \"http:www.release.com\"    ]}2 引入到build.gradle中在project的build.gradle文件的根目录下添加apply from : 'config.gradle'3 模块build.gradle中的使用if (isRelease) {    apply plugin: 'com.android.library'} else {    apply plugin: 'com.android.application'}apply plugin: 'kotlin-android'apply plugin: 'kotlin-android-extensions'apply plugin: 'kotlin-kapt'def androidId = rootProject.ext.androidIDandroid {    compileSdkVersion androidId.compileSdkVersion    buildToolsVersion androidId.buildToolsVersion    defaultConfig {        if (!isRelease) {            // appId = applicationId + flavorDimensions.applicationIdSuffix + buildTypes.applicationIdSuffix            applicationId androidId.applicationId        }        minSdkVersion androidId.minSdkVersion        targetSdkVersion androidId.targetSdkVersion        versionCode androidId.versionCode        versionName androidId.versionName        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"        //给Java代码暴露release标记，通过BuildConfig文件获取        buildConfigField(\"boolean\", \"isDebug\", String.valueOf(isRelease))    }    buildTypes {        //不同版本设置不同的url        debug {            applicationIdSuffix \".debug\"            buildConfigField(\"String\", \"urlService\", \"\\\"${url.debug}\\\"\")        }        release {            minifyEnabled false            buildConfigField(\"String\", \"urlService\", \"\\\"${url.release}\\\"\")            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'        }    }        // 变种维度    flavorDimensions \"version\", \"type\"    productFlavors {        demo {            dimension \"version\"            // 修改此版本的appId            applicationIdSuffix \".demo\"            versionNameSuffix \"-demo\"        }        full {            dimension \"version\"            applicationIdSuffix \".full\"            versionNameSuffix \"-full\"        }        free {            dimension \"type\"        }        noFree{            dimension \"type\"        }    }    //配置资源路径，方便测试环境，打包不集成到正式环境    sourceSets {        //main包下        main {            if (isRelease) {                //java包下                java {                    //在release时，屏蔽掉debug目录下的文件                    exclude '**/debug/**'                }            }        }    }}dependencies {    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])    dependenciesID.each { k, v -&gt; implementation v }}4 生成BuildConfig.java文件public final class BuildConfig {  public static final boolean DEBUG = Boolean.parseBoolean(\"true\");  public static final String APPLICATION_ID = \"com.jiangker.testapplication\";  public static final String BUILD_TYPE = \"debug\";  public static final int VERSION_CODE = 1;  public static final String VERSION_NAME = \"1.0\";  // Fields from build type: debug  public static final String urlService = \"http:www.debug.com\";  // Fields from default config.  public static final boolean isDebug = false;}5 参考文档[配置构建  | Android 开发者  | Android Developers](https://developer.android.com/studio/build?hl=zh-cn) 配置 build 变体"
  },
  
  {
    "title": "排序算法",
    "url": "/posts/sort/",
    "categories": "Algorithm",
    "tags": "sort",
    "date": "2023-12-01 10:49:00 +0800",
    





    "snippet": "算法分类十种常见排序算法可以分为两大类：  比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。  非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 排序算法一般都会有几个较为基础通用的方法class Sort {    private fun check(array: Array&lt;Int&gt;, a: Int, b: Int) = array[a] &gt; array[b]    private fun swap(array: Array&lt;Int&gt;, a: Int, b: Int) {        val max = array[a]        array[a] = array[b]        array[b] = max    }}算法复杂度            排序算法      时间复杂度(平均)      时间复杂度（最坏）      时间复杂度（最好）      空间复杂度      稳定性                  插入排序      O(n²)      O(n²)      O(n)      O(1)      稳定              希尔排序      O(n²)      O(n²)      O(n)      O(1)      不稳定              选择排序      O(n²)      O(n²)      O(n²)      O(1)      不稳定              堆排序      O(nlogn)      O(nlogn)      O(nlogn)      O(1)      不稳定              冒泡排序      O(n²)      O(n²)      O(n)      O(1)      稳定              快速排序      O(nlogn)      O(n²)      O(nlogn)      O(nlogn)      不稳定              归并排序      O(nlogn)      O(nlogn)      O(nlogn)      O(n)      稳定              计数排序      O(n+k)      O(n+k)      O(n+k)      O(n+k)      稳定              桶排序      O(n+k)      O(n²)      O(n)      O(n+k)      稳定              基数排序      O(n*k)      O(n*k)      O(n*k)      O(n+k)      稳定      之前是用泛型来做的，后考虑学习算法主要的是理解逻辑，所以使用简单的int简单而且更直观1 冒泡排序冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。1.1 算法描述  比较相邻的元素。如果第一个比第二个大，就交换它们两个；  对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；  针对所有的元素重复以上的步骤，除了最后一个；  重复步骤1~3，直到排序完成。1.2 动图演示1.3 代码演示fun bubbleSort(array: Array&lt;Int&gt;) {    val size = array.size    //i 表示排序完成了多少个，以此遍历，最后一个为排好的    for (i in 0 until size - 1) {        //从第一个元素开始向后遍历，比较次数为个数减一        for (r in 0 until size - 1 - i) {            if (array[r] &gt; array[r + 1]) {                val max = array[r]                array[r] = array[r+1]                array[r+1] = max            }        }    }}2 选择排序选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。2.1 算法描述n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：  初始状态：无序区为R[1..n]，有序区为空；  第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；  n-1趟结束，数组有序化了。2.2 动图演示2.3 代码演示fun selectionSort(array: IntArray) {    for (i in array.indices) {        //最小值的序号        var min = i        //遍历从当前元素开始的元素，从新设置最小序号        for (r in i + 1 until array.size) {            if (array[min] &gt; array[r]) {                min = r            }        }        //交换选中的最小值        if (min != i){            val value = array[min]            array[min] = array[i]            array[i] = value        }    }}2.4 算法分析表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。3 插入排序（Insertion Sort）插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。3.1 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：  从第一个元素开始，该元素可以认为已经被排序；  取出下一个元素，在已经排序的元素序列中从后向前扫描；  如果该元素（已排序）大于新元素，将该元素移到下一位置；  重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；  将新元素插入到该位置后；  重复步骤2~5。、3.2 动图演示3.3 代码实现fun insertSort(array: IntArray) {    for (i in 1 until array.size) {        //要插入的值        val value = array[i]        //插入到哪里        var index = i        while (index &gt; 0 &amp;&amp; array[index - 1] &gt; value) {            array[index] = array[index - 1]            index--        }        array[index] = value    }}3.4 算法分析插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。4、希尔排序（Shell Sort）1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。4.1 算法描述先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：  选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；  按增量序列个数k，对序列进行k 趟排序；  每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。4.2 动图演示4.3 代码示例fun shellSort(array: IntArray) {    /**     * 使数组中任意间隔为h的位置都是有序的     * 相当于h个独立的间隔为h的数组     */    var h = 0    val size = array.size    while (h &lt; size / 3) h = 3 * h + 1 //1、4、13、40、121、364...    //直到进行间隔h为1的插入排序    while (h &gt;= 1) {        for (i in h until size){            val value = array[i]            var index = i            //从h位置开始，以此往前进行间隔为h的插入排序            while (index &gt;= h &amp;&amp; array[index - h] &gt; value){                array[index] = array[index - h]                index -= h            }            array[index] = value        }        h /= 3    }}4.4 算法分析希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。5、归并排序（Merge Sort）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。5.1 算法描述  把长度为n的输入序列分成两个长度为n/2的子序列；  对这两个子序列分别采用归并排序；  将两个排序好的子序列合并成一个最终的排序序列。5.2 动图演示5.3代码实现fun mergeSort(array: IntArray) {    val temp = IntArray(array.size)    divide(array, temp, 0, array.size - 1)}private fun divide(array: IntArray, temp: IntArray, left: Int, right: Int) {    if (left &gt;= right) return    val mid = left + (right - left) / 2    divide(array, temp, left, mid)    divide(array, temp, mid + 1, right)    //如果左边最大元素大于右边最小元素才需要合并    if (array[mid] &gt; array[mid + 1])        merge(array, temp, left, mid, right)}private fun merge(array: IntArray, temp: IntArray, start: Int, mid: Int, end: Int) {    var left = start    var right = mid + 1    //把需要归并的那段数据复制到临时数组中        System.arraycopy(array, start, temp, start, end - start + 1)    //归并回原数组    for (i in start..end) {        if (left &gt; mid) break        else if (right &gt; end) array[i] = temp[left++]        else if (temp[right] &lt; temp[left]) array[i] = temp[right++]        else array[i] = temp[left++]    }}5.4 算法分析归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。6、快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。6.1 算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：  从数列中挑出一个元素，称为 “基准”（pivot）；  重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；  递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。6.2 动图演示6.3 代码实现fun quickSort(array: IntArray) {    quickSort(array, 0, array.size - 1)}private fun quickSort(array: IntArray, start: Int, end: Int) {    if (start &gt;= end) return    val mid = partition(array, start, end)    quickSort(array, start, mid - 1)    quickSort(array, mid + 1, end)}/** * 分为小于以及大于等于  不足：当重复元素多时，计算速度退化明显 * mid 表示此处以及左边的都小于标定值的坐标 * 当i处值小于标定值时，把mid处元素和i处交换 * 其余时候直接增加i值即可，相当于把大于和等于的放置在右边 */private fun partition(array: IntArray, start: Int, end: Int): Int {    var mid = start    for (i in start + 1..end) {        if (array[start] &gt; array[i]) {            mid++            val value = array[mid]            array[mid] = array[i]            array[i] = value        }    }    val value = array[mid]    array[mid] = array[start]    array[start] = value    return mid}7、堆排序（Heap Sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。7.1 算法描述  将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；  将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；  由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。7.2 动图演示7.3代码实现/** * 因为是从小到大排序，所以先排为最大堆，然后取出最大元素放置到末尾即可 */fun heapSort(array: IntArray) {    //从第一个元素开始以此往后进行最大堆的创建    for (index in array.indices) {        siftUp(array, index)    }    //把最大元素依次与末尾元素进行交换，然后进行下沉操作    for (index in array.size - 1 downTo 1) {        heapify(array, index)    }}private fun siftUp(array: IntArray, index: Int) {    var i = index    while (i &gt; 0) {        val pre = if (i % 2 == 0) i / 2 - 1 else i / 2        if (array[pre] &lt; array[i]) {            swap(array, pre, i)            i = pre        } else {            break        }    }}/** * 将index的元素和第一个位置元素交换，然后进行下沉操作 */private fun heapify(array: IntArray, index: Int) {    swap(array, 0, index)    var i = 0    val end = index - 1    //如果有子元素则进行下沉操作    while (2 * i &lt; end) {        val right = 2 * (i + 1)        val left = right - 1        //如果有两个子元素，则用最大的去交换，如果只有一个子元素，则比较后结束        if (right &lt; end) {            val maxIndex = if (array[right] &gt; array[left]) right else left            if (array[maxIndex] &gt; array[i]) {                swap(array, maxIndex, i)                i = maxIndex            } else {                break            }        } else {            if (array[left] &gt; array[i]) {                swap(array, left, i)            }            break        }    }}private fun swap(array: IntArray, a: Int, b: Int) {    val value = array[a]    array[a] = array[b]    array[b] = value}8、计数排序（Counting Sort）计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。8.1 算法描述  找出待排序的数组中最大和最小的元素；  统计数组中每个值为i的元素出现的次数，存入数组C的第i项；  对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；  反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。8.2 动图演示8.3 代码实现//TODO8.4 算法分析计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。9、桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。9.1 算法描述  设置一个定量的数组当作空桶；  遍历输入数据，并且把数据一个一个放到对应的桶里去；  对每个不是空的桶进行排序；  从不是空的桶里把排好序的数据拼接起来。9.2 图片演示9.3 代码实现//TODO9.4 算法分析桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。10、基数排序（Radix Sort）基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。10.1 算法描述  取得数组中的最大数，并取得位数；  arr为原始数组，从最低位开始取每个位组成radix数组；  对radix进行计数排序（利用计数排序适用于小范围数的特点）；10.2 动图演示10.3 代码实现//TODO10.4 算法分析基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n»k，因此额外空间需要大概n个左右。"
  },
  
  {
    "title": "View的绘制流程",
    "url": "/posts/view_mechniasm/",
    "categories": "Android",
    "tags": "view",
    "date": "2023-12-01 10:36:00 +0800",
    





    "snippet": "MeasureSpec  是View的静态内部类，主要是定义的View的尺寸计算规则。32位的int值，前两位为测量模式，后30位为数值。  UNPECIFIED ：未指定模式，View想要多大就多大，父容器不做限制，一般为系统布局的测量。  AT_MOST： 最大模式，对应于wrap_content属性，子View的最终大小是父View指定的SpecSize，并且子View的大小不能大于这个值。      EXACTLY： 精确模式，对应于match_parent属性和具体的数值，父容器测量出View所需要的大小，也就是SpecSize的值。    主要方法          makeMeasureSpec用来使用mode和size生成一个保存所有信息的int值。      getMode来获取int值中保存的模式信息。      getSize来获取int值中保存的Size信息。      getRootMeasureSpec 根据size以及layoutParams的模式来生成spec参数。      Measure流程      如果自定义的View未重写onMeasure方法或未对warp_content进行特殊处理，则和match_parent效果是一样的。        建议的最小宽度为          在未设置背景时为设置的最小值      在设置了背景是为设置的最小值和背景的宽度中的最大值            因为ViewGroup对子View的测量方式的不同，所以ViewGroup的onMeasure需要在自定义时去根据自己的需求重写，不重写的话子view是不会被测量的，就没有measure后的值。        ViewGroup在测量子View时，最大可以给予的宽高需要减去自己的padding值以及子View的margin值。        ViewGroup中主要的测量方法    // 根据父布局可以给予的sepc值以及padding和子view的布局参数计算子view的sepc值public static int getChildMeasureSpec(int spec, int padding, int childDimension)//测量指定的子view宽高，参数为父view可以给予的最大宽高，在内部会计算出自己的padding然后调用getChildMeasureSpec方法protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec)// 通过遍历子view去通过measureChild方法进行测量protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec)            因为默认的view的layoutParams是不支持margin的，所以viewgroup中的measure方法是不带margin的，所以自定义时最常用的还是getChildMeasureSpec方法。    如果需要支持子View的margin，需要在自定义view时重写generateLayoutParams(AttributeSet attrs)和generateDefaultLayoutParams()返回ViewGroup.MarginLayoutParams或其子类的对象，前者会在解析布局参数时调用，而后者为addView时不带布局参数时调用生成一个默认的布局参数。  onMeasure方法中必须调用setMeasuredDimension去设置值。Layout流程  若measure方法被跳过了，则会在layout时候进行测量。  调用setFrame方法进行位置的放置，若设置的值对比之前的有改变，则会触发onLayout方法，这个方法是需要在自定义的ViewGroup中进行重写的。  自定义ViewGroup必须重写onLayout方法对子View进行放置，layout方法的参数是相对于父布局左上角坐标的。  若ViewGroup支持margin，则需要在onLayout的时候对margin进行处理，并且需要注意自己的padding值。draw流程  流程          如果需要，绘制背景 drawBackground(canvas)      保存当前cavas层      绘制view的内容 onDraw(canvas)      绘制子view dispatchDraw(canvas)      如果需要，绘制View的褪色边缘      绘制装饰，滚动条以及foreground的绘制 onDrawForeground(canvas)        view中有一个setWillNotDraw方法，若为true，会给View的mPrivateFlags参数增加PFLAG_SKIP_DRAW参数，View只会去绘制子View以及drawAutofilledHighlight方法。而ViewGroup初始化的时候会默认把这个值置为true，所以自定义Viewgroup时若需要重写onDraw方法则需要自己去调用这个方法设置为false。  设置WILL_NOT_DRAW标志时，若有background等需要绘制的内容，是无效的，不会跳过绘制。  重写onDraw时不能在其中new对象，因为会频繁调用，容易造成内存的抖动。  自定义View中，在onDraw中需要考虑padding对自己的影响，默认padding值是不会对View有影响的。自定义View需注意  自定义View中需要增加对warp_content的支持，否则和match_parent无差异  自定义ViewGroup时onMeasure需要考虑自己的padding和子view的margin对其影响  自定义View需要在onDraw时考虑padding对其的影响。  自定义ViewGroup如果需要在onDraw中进行绘制，需要在初始化时调用setWillNotDraw(false)"
  },
  
  {
    "title": "vim命令",
    "url": "/posts/vim/",
    "categories": "Other",
    "tags": "vim",
    "date": "2023-11-30 20:55:00 +0800",
    





    "snippet": "1. 常用命令            命令      作用                  dd      删除（剪切）光标所在行              5dd      删除（剪切）从光标处开始的5行              yy      复制光标所在的整行              5yy      复制光标处开始的5行              n      显示搜索命令定位到的下一个字符串              N      显示搜索命令定位到的上一个字符串              u      撤销上一步的操作              p      将之前删除的或复制过的数据粘贴在光标后面      2. 末行模式中可用的命令            命令      作用                  :w      保存              :q      退出              :wq      保存退出              :wq!      强制保存退出              :q!      强制退出（舍弃修改）              :set nu      显示行号              :set nonu      不显示行号              :命令      执行该命令              :n      跳转到第n行              :s/one/two      将当前光标所在行的第一个one替换成two              :s/one/two/g      将光标所在行的所有one替换成two              :%s/one/two/g      将全文中所有one替换成two              ?jiangker      在文本中从下至上搜索jiangker              /jiangker      在文本中从上至下搜索jiangker      3.模式切换3.1 命令模式 ==&gt; 输入模式            命令      作用                  a      append - 光标后一位切换到输入模式              A      在行尾切换到输入模式              i      insert - 在当前位置切换到输入模式              I      在行首切换到输入模式              o      在光标下一行创建一个空行切换到输入模式              O      在光标上一行创建一个空行切换到输入模式      "
  },
  
  {
    "title": "Git常用命令",
    "url": "/posts/git/",
    "categories": "Other",
    "tags": "git",
    "date": "2023-11-30 20:49:00 +0800",
    





    "snippet": "用户配置  git config --global user.name 'jiangker'   git config --global user.email 'niklaus1996@icloud.com'默认为 –local 只对某个仓库有效–global 对当前用户所有仓库有效–system 对系统所有登录的用户有效显示config的配置  git config --list --global变更工作区的内容使用checkout，变更暂存区的内容使用reset创建git仓库  #把已有的项目代码纳入git管理  git init                 #创建一个空的git仓库  git init name            添加所有文件到暂存区  git add . 添加所有跟踪了有变更的文件到暂存区  git add -u                              删除文件  git rm .         重命名文件  git mv oldName newName                              放弃暂存区的变更(变更回到工作区)  git reset HEAD                             放弃暂存区的变更和本地变更   git reset --hard         查看日志  git log n4 --oneline查看所有仓库日志  git log --all --oneline --graph查看分支  git branch -av创建分支  git checkout -b temp比较分支差异(比较head和head父亲的父亲commit的区别)   git diff HEAD HEAD~2 git diff HEAD HEAD^^ 删除分支  git branch -d name //如果是没有合并到别的分支，会删除失败   git branch -D name //强制删除修改最近提交的commit的msg  git commit --amend 对git分支进行变基，修改合并前面的commit  git rebase -i eb7fa8（父commit）查看暂存区和HEAD的差异  git diff --cached              查看工作区和暂存区的差异  git diff git diff -- fileName //只查看指定文件              暂存区恢复到工作区  git checkout -- fileNamestash操作  git stash //存放  git stash list //stash列表  git stash pop //弹出顶部  git stash apply //应用顶部但不弹出            添加远端仓库  git remote add &lt;name&gt; &lt;path&gt;删除远程分支  git push &lt;name&gt; --delete &lt;branch-name&gt;清空本地有的远程分支而远程已不存在  git remote prune &lt;origin&gt;"
  },
  
  {
    "title": "SQLite",
    "url": "/posts/sqlite/",
    "categories": "Android",
    "tags": "sqlite",
    "date": "2023-11-30 20:46:00 +0800",
    





    "snippet": "1. 创建数据库Android提供一个SQLiteOpenHelper抽象类来协助我们使用SQLite，使用时需要继承至SQLiteOpenHelper并实现其中的两个抽象方法onCreate()、onUpgrade()。SQLiteOpenHelper中还有两个非常重要的方法：getWritableDatabase()和getReadableDatabase()。这两个方法都可以创建或打开一个现有的数据库（有则打开，无则创建），并返回一个可对数据库进行读写操作的对象。不同的是当数据库不可写入时，getReadableDatabase()会以只读的形式打开，而getWritableDatabase()方法会出现异常。数据类型            类型      字段                  整型      integer              浮点型      real              文本类型      text              二进制类型      blob      /** * @param name 数据库名称 * @param version 数据库版本 */class MyDatabaseHelper(    context: Context,    name: String,    version: Int) : SQLiteOpenHelper(context, name, null, version) {        private val createBook = \"\"\"        create table Book ( id integer primary key autoincrement,        author text, price real, pages integer, name text)    \"\"\".trimIndent()    // 若数据库不存在则触发    override fun onCreate(db: SQLiteDatabase) {        db.execSQL(createBook)    }    // 当数据库版本升级时触发    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {    }}// 使用class SQLiteActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        val binding = DataBindingUtil.setContentView&lt;ActivitySqliteBinding&gt;(this, R.layout.activity_sqlite)        val dbHelper = MyDatabaseHelper(this,\"BookStore.db\",1)        binding.apply {            btnCreateTB.setOnClickListener {                // 创建数据库对象                val db = dbHelper.writableDatabase            }        }    }}2. 插入数据val db = dbHelper.writableDatabaseval value = ContentValues().apply {    put(\"name\",\"The Da Vinci Code\")    put(\"author\",\"Dan Brown\")    put(\"pages\",\"454\")    put(\"price\",\"17\")}db.insert(\"Book\",null,value)3. 更新数据update的第三四个参数作为限制参数，否则会把所有行都进行更新，“?”为占位符，对应后面的列表数据val db = dbHelper.writableDatabaseval value = ContentValues().apply {    put(\"author\",\"Dan Brown - ${System.currentTimeMillis()/1_000_000}\")}db.update(\"Book\",value,\"name = ?\", arrayOf(\"The Da Vinci Code\"))4. 删除数据第二个和第三个参数同为限制参数val db = dbHelper.writableDatabasedb.delete(\"Book\",\"pages &gt; ?\", arrayOf(\"400\"))5. 查询数据query()方法参数            方法参数      对应SQL部分      描述                  table      from table_name      查询的表名              columns      select column1，column2      查询的列名              selection      where colum = value      指定查询的约束条件              selectionArgs             为where的占位符提供参数              groupBy      group by column      指定需要group by 的列              having      having column = value      对group by后的结果进一步约束              orderBy      order by column1，column2      指定查询结果的排序方式      val db = dbHelper.writableDatabaseval cursor = db.query(    table = \"Book\",    columns = arrayOf(\"name\", \"pages\", \"price\"),    selection=\"pages &gt; ?\",    selectionArgs = arrayOf(\"400\"),    groupBy = null,    having = null,    orderBy =\"price\")if (cursor.moveToFirst()) {    do {        val name = cursor.getString(cursor.getColumnIndex(\"name\"))        val pages = cursor.getInt(cursor.getColumnIndex(\"pages\"))        val price = cursor.getDouble(cursor.getColumnIndex(\"price\"))        Log.d(\"SQLite:\", \"Query -&gt; name: $name,pages: $pages,price: $price\")    } while (cursor.moveToNext())}cursor.close()6. 使用SQL操作数据库val db = dbHelper.writableDatabase// 增删改使用db.execSQL(    \"insert into Book (name,author,pages,price) values(?,?,?,?)\",    arrayOf(\"One day\", \"Dav\", \"465\", \"17.8\"))// 查询使用val cursor = db.rawQuery(\"select name,pages,price from Book where pages &gt; ? and price &gt; ?\", arrayOf(\"400\", \"50\"))7. 事务操作  事务的特性就是可以保证让一系列的操作要么全部完成，要么一个都不会完成// 事务操作btnTransaction.setOnClickListener {    val db = dbHelper.writableDatabase    // 开启事务    db.beginTransaction()    try {        db.delete(\"Book\", null, null)        val value = contentValuesOf(            \"name\" to \"The Da Vinci Code\",            \"author\" to \"Dan Brown\",            \"pages\" to System.currentTimeMillis() % 1000,            \"price\" to System.currentTimeMillis() % 100        )        db.insert(\"Book\", null, value)        // 事务执行成功        db.setTransactionSuccessful()    } catch (e: Exception) {    } finally {        // 结束事务        db.endTransaction()    }}"
  },
  
  {
    "title": "Mysql命令",
    "url": "/posts/mysql/",
    "categories": "Other",
    "tags": "mysql",
    "date": "2023-11-30 20:42:00 +0800",
    





    "snippet": "数据库操作进入数据库命令行，回车输入密码mysql -u root -p数据库相关命令            输入      作用                  show databases      数据库列              use （数据库）      切换数据库              show tables      数据库的表              show columns from （表名）      显示的所有列信息              show create database （数据库）      显示数据库创建语句              show create table （表名）      显示表的创建语句      检索数据 SELECT  如果没有明确排序查询结果，则返回的数据的顺序没有特殊意义。            输入      作用                  SELECT phone FROM tb_user;      查询表tb_user中phone列的所有数据              SELECT phone,name FROM tb_user;      可以同时查询多列，用逗号隔开              SELECT * FROM tb_user;      查询所有列              SELECT DISTINCT phone from tb_user;      检索不同的行，重复的不显示。多列情况需全部不同才不显示              SELECT phone FROM tb_user LIMIT 1;      限制最多输出行数              SELECT phone FROM tb_user LIMIT 1,3;      限制从第一行开始的三行              SELECT phone FROM tb_user LIMIT 3 OFFSET 1;      限制从第一行开始的三行      排序检索数据  默认的检索排序是从小到大排序的            输入      作用                  SELECT phone FROM tb_user ORDER BY phone;      查询按phone进行排序，也可以多个              SELECT phone FROM tb_user ORDER BY phone DESC;      从大到小排序，多个数据只应用到前面的那个数，而后面的为默认。所以可以指定多个              SELECT name,phone FROM tb_user ORDER BY phone,name DESC;                     SELECT name,phone FROM tb_user ORDER BY phone DESC,name ASC;                     SELECT name,phone FROM tb_user ORDER BY phone LIMIT 1;      限制语句应该放在最后      "
  },
  
  {
    "title": "Protobuf的使用",
    "url": "/posts/protobuf/",
    "categories": "Android",
    "tags": "protubuf",
    "date": "2023-11-30 20:42:00 +0800",
    





    "snippet": "项目配置项目build.gradlebuildscript {    dependencies {        //添加        classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.8'    }}模块build.gradleplugins {    id 'com.google.protobuf'}android {    sourceSets{        main{            //设置proto和生成的java文件路径            proto {                srcDir 'src/mian/proto'                include '**/*.proto'            }            java {                srcDir 'src/main/java'            }        }    }}protobuf {    //配置protoc编译器    protoc {        artifact = 'com.google.protobuf:protoc:3.8.0'    }    //这里配置生成目录，编译后会在build的目录下生成对应的java文件    generateProtoTasks {        all().each { task -&gt;            task.builtins {                remove java            }            task.builtins {                java {}            }        }    }}dependencies {    api \"com.google.protobuf:protobuf-java:3.8.0\"}proto文件格式//指定版本为3，否则默认为2syntax = \"proto3\";package com.jiangker.testitem.proto;//option 为可选字段//生成文件路径option java_package = \"com.jiangker.testitem.datastore.protobuf\";//生成的文件名option java_outer_classname = \"PersonProto\";message Person{  // 格式：字段类型 + 字段名称 + 字段编号  string name = 1;}字段编号一旦开始使用就不能够再改变注意 ：在范围 [1, 15] 之间的字段编号在编码的时候会占用一个字节，包括字段编号和字段类型，在范围 [16, 2047] 之间的字段编号占用两个字节，因此，应该为频繁出现的消息字段保留 [1, 15] 之间的字段编号，一定要为将来频繁出现的元素留出一些空间。字段类型            proto Type      Notes      Java Type                  double             double              float             float              int32      使用变长编码，如果字段是负值，效率很低，使用 sint32 代替      int              int64      使用变长编码。如果字段是负值，效率很低，使用 sint64 代替      long              uint32      使用变长编码      int              uint64      使用变长编码      long              sint32      使用变长编码，如果是负值比普通的 int32 更高效      int              sint64      使用变长编码，如果是负值比普通的 int64 更高效      long              fixed32      使用变长编码。符号整型。负值的编码效率高于常规的 int32 类型。      int              bool             boolean              string      包含 UTF-8 和 ASCII 编码的字符串，长度不能超过 2^32 。      String              bytes      可包含任意的字节序列但长度不能超过 2^32 。      ByteString      默认值当解析消息时，若消息编码中没有包含某个元素，则相应的会使用该字段的默认值。默认值依据类型而不同：  字符串类型，空字符串  字节类型，空字节  布尔类型，false  数值类型，0  枚举类型，第一个枚举元素  被 repeated 修饰字段，默认值是一个大小为 0 的空 List枚举enum Type{   MAN = 0;}  必须有一个 0 值，才可以作为数值类型的默认值。  0 值常量必须作为第一个元素，是为了与 proto2 的语义兼容就是第一个元素作为默认值。"
  },
  
  {
    "title": "Android 性能优化",
    "url": "/posts/performance_optimization/",
    "categories": "Android",
    "tags": "optimization",
    "date": "2023-11-30 20:38:00 +0800",
    





    "snippet": "1. 布局优化：  改进自定义的View，界面中大量使用的输入框都是由LinearLayout来封装的。因为EditText都是有drawable的，所以改为自定义的EditText减少布局层级。  使用include、merge、viewstub来优化布局层级以及延迟加载。  使用约束布局来更改界面中的复杂布局  布局中多使用精确尺寸，例如match_parent以及dp，减少测量次数。  分步加载，对于特别复杂的一个界面，在进入界面之后先显示整体框架，然后再展示的输入框中的数据。  其他：          onDraw方法中不能new 对象，因为频繁调用，容易造成内存抖动。      使用SpannableString来代替多个连续的textview。      IntArray减少自动装箱      2. 计算优化：  关于矢量计算过程的优化，因为向量是方向和长度需要分解为实部和虚部去计算，之前是每次计算时先分解然后又转换回去，优化之后为每当要获取方向和长度时才转换回去，否则都是保存实部和虚部，因为绘制矢量图也是用的实部和虚部，所以计算速度大大提升了好几倍。3. 卡顿优化：  程序大多数界面为上部分为实验条目区，下部分为输入区，界面在弹出软键盘时，需要对实验条目区进行隐藏，然后这个过程很卡顿，之前的做法是监听软键盘，弹出或隐藏之后立刻进行隐藏调用，复杂的界面大概需要1.5秒左右。然后对最外层layout的方法进行调用打印，发现draw方法被调用了三次，然后在layout的时候记录view高度，变化measure的高度变化了之后直接这里回调隐藏view，使最后draw方法只调用了一次，优化之后大概0.6秒左右可以完成。4. 启动速度优化：  因为启动往往需要加载比较多的三方库，可以对初始化的代码进行一层包装，然后再使用协程或者线程池来异步加载。需要区分哪些可以放在子线程哪些不能，哪些直接有顺序关系以及异步线程数不要多余CPU核心数了。5. 内存抖动优化  尽量避免在循环体内创建对象  view的onDraw()方法会被频繁调用，使用切勿在这里创建对象。  当需要大量使用bitmap时，可以把他们缓存起来。  对于能够复用的对象，可以使用缓存起来从中去获取。6. 内存泄漏  recyclerview泄漏  spannablestring泄漏  单例内存泄漏  handler内存泄漏 - 队列中的message持有handler的引用，而handler持有activity的引用就会造成泄漏。"
  },
  
  {
    "title": "线程池",
    "url": "/posts/thread_pool/",
    "categories": "Java",
    "tags": "ThreadPool",
    "date": "2023-11-30 17:23:00 +0800",
    





    "snippet": "  Executor框架用于把任务的提交和执行解耦，任务的提交交给Runnable或Callable，而Executor用来处理任务。ThreadPoolExecutor时线程池的核心实现类。ThreadPoolExecutorpublic ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler) {FixedThreadPoolpublic static ExecutorService newFixedThreadPool(int nThreads) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());}创建只有固定核心线程数的线程池，超过线程数的任务都将放入到无界阻塞队列中。CacheThreadPoolpublic static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());}创建无核心线程的线程池，提交的任务都会交给空闲线程或者创建新的线程去处理，空闲超过60s的线程将会被终止。适合大量的需要立即处理并且耗时较少的任务。SingleThreadExecutorpublic static ExecutorService newSingleThreadExecutor() {    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));}只有一个核心线程，任务放到无界阻塞队列中，可以保证任务放到一个线程中顺序执行。ScheduledThreadPool主要用于给定延时之后运行任务或者定期处理任务。这里传入的DelayedWorkQueue是一个无界的队列，所以非线程是无效的。ScheduledExecutorService对比前面的线程池多了一些延迟执行的方法。public static ScheduledExecutorService newScheduledThreadPool(        int corePoolSize, ThreadFactory threadFactory) {    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);}public ScheduledThreadPoolExecutor(int corePoolSize,                                   ThreadFactory threadFactory) extends ExecutorService{    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,          new DelayedWorkQueue(), threadFactory);    public ScheduledFuture&lt;?&gt; schedule(Runnable command,                            long delay, TimeUnit unit);}newWorkStealingPool支持给定并行度的线程，提供多个等待队列来减少竞争。默认线程数等于CPU数。public static ExecutorService newWorkStealingPool(int parallelism) {    return new ForkJoinPool        (parallelism,         ForkJoinPool.defaultForkJoinWorkerThreadFactory,         null, true);}public ForkJoinPool(int parallelism,                    ForkJoinWorkerThreadFactory factory,                    UncaughtExceptionHandler handler,                    boolean asyncMode) {    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException;}execute和submit的区别  execute只能提交Runnable类型的任务，无返回值。submit既可以提交Runnable类型的任务，也可以提交Callable类型的任务，会有一个类型为Future的返回值，但当任务类型为Runnable时，返回值为null。  execute在执行任务时，如果遇到异常会直接抛出，而submit不会直接抛出，只有在使用Future的get方法获取返回值时，才会抛出异常。"
  },
  
  {
    "title": "ThreadLocal",
    "url": "/posts/thread_local/",
    "categories": "Java",
    "tags": "ThreadLocal",
    "date": "2023-11-30 17:14:00 +0800",
    





    "snippet": "使用  同一个对象，在不同的线程中可以维持不同的值class ThreadLocalTest {    @Test    fun testName(){        val localName = ThreadLocal&lt;String&gt;()        val name = \"jiangker\"        localName.set(name)        Assert.assertEquals(name,localName.get())        localName.remove()        thread {            Assert.assertEquals(null,localName.get())        }        Assert.assertEquals(name,localName.get())        localName.remove()    }}val localName = ThreadLocal&lt;String&gt;()val name = \"jiangker\"localName.set(name)// 正确Assert.assertEquals(name,localName.get())thread {    // java.lang.AssertionError: expected:&lt;jiangker&gt; but was:&lt;null&gt;    Assert.assertEquals(name,localName.get())}  ThreadLocal并不存储值，value是存储在Thread中一个ThreadLocal的ThreadLocalMap的静态内部类中的。      ThreadLocalMap实际是一个默认的容量为16的Entry的循环数组，当容量超过最大2/3的时候会进行清理操作，若还大于2/3*3/4则扩容为原来的两倍。    Entry是一个key为弱引用包裹的ThreadLocal，value为object      Entry存储在ThreadLocal的hashCode对length长度-1取与的位置，若已经存在Entry且Key中不为空则向后遍历找寻可以插入的位置。        若ThreadLocal不使用时不进行remove操作，value会被泄漏。但若进行了别的ThreadLocal的操作，可能才会对空的Entry进行清空。    在set操作时，会对部分元素进行检测，若遇到key为空的Entry，则执行清理操作，并对之后的元素重写进行hash操作。  在remove操作时，也会对此元素之后连续非空的元素进行检查并且rehash。参考文章ThreadLocal的奇思妙想"
  },
  
  {
    "title": "Android 序列化",
    "url": "/posts/serializable/",
    "categories": "Android",
    "tags": "serializable",
    "date": "2023-11-30 17:10:00 +0800",
    





    "snippet": "Serializable接口因为序列化和反序列化都需要大量的IO操作，开销大，适用于将对象序列化到存储设备中或者将对象序列化后通过网络传输public class Test implements Serializable {    //辅助序列化，严重是否为相同的类，防止序列化失败    private static final long serialVersionUID = 1234567890;    //添加了transient关键字的和静态变量都不会参与序列化    transient String name = \"jiangker\";        /**     * 自定义序列化规则     */    private void writeObject(ObjectOutputStream s) throws IOException{ }    private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { }}Parcelable使用麻烦，效率高，适合内存序列化//其中的对象都需要是可以进行序列化的public class Test implements Parcelable {    private String name;    private int age;    public Test(String name, int age) {        this.name = name;        this.age = age;    }    //从序列化后的对象中创建原始对象    protected Test(Parcel in) {        name = in.readString();        age = in.readInt();    }    /**     * 将当前对象写入序列化对象中     * @flags 0 或 1 ，一般写0     * 1表示当前对象需要作为返回值返回，不能立即释放资源     */    @Override    public void writeToParcel(Parcel dest, int flags) {        dest.writeString(name);        dest.writeInt(age);    }    //返回当前文件的内容描述，若含有文件描述符则返回1，一般为0    @Override    public int describeContents() {        return 0;    }    public static final Creator&lt;Test&gt; CREATOR = new Creator&lt;Test&gt;() {        //从序列化后的对象中创建原始对象        @Override        public Test createFromParcel(Parcel in) {            return new Test(in);        }        //创建指定长度的原始对象数组        @Override        public Test[] newArray(int size) {            return new Test[size];        }    };}"
  },
  
  {
    "title": "仿Getx Obx",
    "url": "/posts/getx-obx/",
    "categories": "flutter",
    "tags": "state",
    "date": "2023-11-30 16:12:00 +0800",
    





    "snippet": "创建的flutter初始状态代码class MyHomePage extends StatefulWidget {  MyHomePage({Key key, this.title}) : super(key: key);  final String title;  @override  _MyHomePageState createState() =&gt; _MyHomePageState();}class _MyHomePageState extends State&lt;MyHomePage&gt; {  int _counter = 0;  void _incrementCounter() {    setState(() {      _counter++;    });  }  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(widget.title),      ),      body: Center(        child: Column(          mainAxisAlignment: MainAxisAlignment.center,          children: &lt;Widget&gt;[            Text(              'You have pushed the button this many times:',            ),            Text(              '$_counter',              style: Theme.of(context).textTheme.headline4,            ),          ],        ),      ),      floatingActionButton: FloatingActionButton(        onPressed: _incrementCounter,        tooltip: 'Increment',        child: Icon(Icons.add),      ),    );  }}主要存在两个问题      数据和界面没有分离        没有局部刷新  局部刷新controller  管理title 以及 counter这两个数据typedef Callback = void Function();class Controller {  Callback callback;  Controller({@required this.title});  int _counter = 0;    final String title;  int get counter =&gt; _counter;  void incrementCounter() {    _counter++;    callback?.call();  }}Widgettypedef WidgetBuilder = Widget Function();class Observer extends StatefulWidget {  final WidgetBuilder builder;  final Controller controller;  Observer({@required this.builder, @required this.controller});  @override  _ObserverState createState() =&gt; _ObserverState();}class _ObserverState extends State&lt;Observer&gt; {  @override  void initState() {    super.initState();    widget.controller.callback = refresh;  }  @override  Widget build(BuildContext context) =&gt; widget.builder();  void refresh() {    setState(() {});  }}Pageclass MyApp extends StatelessWidget {  // This widget is the root of your application.  @override  Widget build(BuildContext context) {    return MaterialApp(      title: 'Flutter Demo',      theme: ThemeData(        primarySwatch: Colors.blue,      ),      home: MyHomePage(controller: Controller(title: 'Flutter Demo Home Page')),    );  }}class MyHomePage extends StatelessWidget {  final Controller controller;  MyHomePage({Key key, this.controller}) : super(key: key);  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(controller.title),      ),      body: Center(        child: Column(          mainAxisAlignment: MainAxisAlignment.center,          children: &lt;Widget&gt;[            Text(              'You have pushed the button this many times:',            ),            Observer(              builder: () =&gt; Text(                '${controller.counter}',                style: Theme.of(context).textTheme.headline4,              ),              controller: controller,            )          ],        ),      ),      floatingActionButton: FloatingActionButton(        onPressed: controller.incrementCounter,        tooltip: 'Increment',        child: Icon(Icons.add),      ),    );  }}提取LiveDataLiveDataclass LiveData&lt;T&gt; {  LiveData(T value) {    _value = value;  }  List&lt;Callback&gt; observers = &lt;Callback&gt;[];  T _value;  T get value =&gt; _value;  set value(T value) {    this._value = value;    observers.forEach((observer) {      observer();    });  }  void observer(Callback listener) {    observers.add(listener);  }  void removeObserver(Callback callback) {    observers.remove(callback);  }}Observer  主要修改为面向的是LiveData而不是Controllertypedef WidgetBuilder&lt;T&gt; = Widget Function(T);class Observer&lt;T&gt; extends StatefulWidget {  final WidgetBuilder&lt;T&gt; builder;  final LiveData&lt;T&gt; counter;  Observer({@required this.builder, @required this.counter});  @override  _ObserverState createState() =&gt; _ObserverState();}class _ObserverState extends State&lt;Observer&gt; {  @override  void initState() {    super.initState();    widget.counter.observer(refresh);  }  @override  Widget build(BuildContext context) =&gt; widget.builder(widget.counter.value);  void refresh() {    setState(() {});  }  @override  void dispose() {    super.dispose();    widget.counter.removeObserver(refresh);  }}"
  },
  
  {
    "title": "Activity基础",
    "url": "/posts/activity/",
    "categories": "Android",
    "tags": "AOSP",
    "date": "2023-11-30 15:42:00 +0800",
    





    "snippet": "Activity常见方法            方法名称      作用                  void startActivityForResult(Intent intent, int requestCode)      需要返回值的方式启动一个activity              void setResult(int resultCode, Intent data)      设置activity的返回值，resultCode默认为RESULT_CANCELED，可以设置为RESULT_OK              void onActivityResult(int requestCode, int resultCode, Intent data)      重写这个方法可以用于回去activity的返回值              void onSaveInstanceState(Bundle outState)      在activity被销毁时候可以把数据保存到Bundle中              void onRestoreInstanceState(Bundle savedInstanceState)      重建时候恢复数据使用      Activity切换显式Intent传入Activity对象val intent = Intent(this, SecondActivity::class.java)startActivity(intent)设置ComponentNameval intent = Intent()intent.setClassName(\"com.jiangker.testitem\",\"com.jiangker.testitem.SecondActivity\")startActivity(intent)ComponentName中的值  className: com.jiangker.testitem.SecondActivity  shortClassName: .SecondActivity  packageName: com.jiangker.testitem隐式Intent不用明确指出我们想要启动哪一个活动，而是指定一系列更为抽象的action和categoryactionintent-filter中可以设置多个，intent中可以设置一个，但必须是其中的一个 #### categoryintent中可以没有，有的情况必须是intent-filter的子集，并且intent-filter中必须要有android.intent.category.DEFAULT才能被隐式启动&lt;intent-filter&gt;    &lt;action android:name=\"android.intent.action.TEST\"/&gt;    &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt;    &lt;category android:name=\"android.intent.category.TEST\"/&gt;&lt;/intent-filter&gt;val intent = Intent()intent.action = \"android.intent.action.TEST\"intent.addCategory(\"android.intent.action.TEST\")startActivity(intent)同时具有这两个标签的都会在桌面生成图标作为主入口 &lt;intent-filter&gt;    &lt;action android:name=\"android.intent.action.MAIN\" /&gt;    &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;&lt;/intent-filter&gt;data如果intent-filter中有的类型，intent中必须有，重复的类型只需要满足其中一个即可。当intent-filter中没有的，intent也不能有&lt;data android:scheme=\"string\"    android:host=\"string\"    android:port=\"string\"    android:path=\"string\"    android:pathPattern=\"string\"    android:pathPrefix=\"string\"    android:mimeType=\"string\"/&gt;data由两部分组成，mimeType和URL，mimeType指媒体类型，可以表示图片、文本、视频等不同的类型。而URI中可以包含很多数据，结构如：&lt;scheme&gt;://&lt;host&gt;:port/[&lt;path&gt;]|&lt;pathPrefix&gt;|&lt;pathPattern&gt;|URI默认值为content和file，是可以不写的  Scheme:URI的模式，比如http、file、content等，如果URI中没有指定scheme，那么整个URI都是无效的  Host：URI的主机名，比如www.baidu.com，如果host未指定，那么URI也是无效的  Port：URI中的端口号，比如80，仅当URI中指定了scheme和host参数的时候，port才会有意义  Path、pathPattern和pathPrefix：这三个表示路径信息，其中path表示完整的路径信息；pathPattern也表示完整的路径信息，但是它里面可以包含通配符“”，“”表示0个或多个任意字符；pathPrefix表示路径的前缀信息匹配检测//检测有哪些匹配成功的，必须有android.intent.category.DEFAULTval resolveInfoes: List&lt;ResolveInfo&gt; = packageManager.queryIntentActivities(intent,PackageManager.MATCH_DEFAULT_ONLY)//如果只有一个匹配的就返回那个activity的信息，如果有多个则返回ResolveActivityval resolveInfo :ResolveInfo = packageManager.resolveActivity(intent,PackageManager.MATCH_DEFAULT_ONLY)启动模式活动的启动模式一共有四种，分别是standard、singleTop、singleTask、singleInstance，可以在AndroidManifest.xml中通过给&lt;activity标签指定android:launchMode属性来选择启动模式，Activity所需要的任务栈的名字为应用的包名，也可以使用TaskAffinity属性来指定，代码设置的启动模式优先级高于xml配置的，但singleInstance无法使用代码实现。Activity默认启动都是在启动他的栈中，除了singleInstance。standard  是默认的启动模式，每启动一个新的活动，它就会在返回栈中入栈，并处于栈顶的位置，不在乎这个活动是否已经在返回栈中存在  每次启动都会创建该活动的一个新的实例,并放入当前activity的栈中，当启动它的没有返回栈，则会报错，如context调用的startActivity  若启动它的activity为singleInstance模式或者采用的是FLAG_ACTIVITY_NEW_TASK则会放入到自己原来实例的栈singleTop  当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例，即若不是栈顶，则会创建新的实例  得到复用时会调用自己的onNewIntent方法（onPause -&gt; onNewIntent -&gt; onResume 或 onRestart -&gt; onStart -&gt; onNewIntent -&gt; onResume）singleTask  当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则使用该实例，并把这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例  配合taskAffinity使用会出现在另外的栈中  触发复用时和singleTop一样的流程singleInstance  指定为singleInstance模式的活动会启动一个新的返回栈来管理这个活动  这个栈只会有一个实例，启动别的activity会放到自己原来的栈中生命周期Activity是由Activity栈进管理，当来到一个新的Activity后，此Activity将被加入到Activity栈顶，之前的Activity位于此Activity底部。Acitivity一般意义上有四种状态：  当Activity位于栈顶时，此时正好处于屏幕最前方，此时处于运行状态；  当Activity失去了焦点但仍然对用于可见（如栈顶的Activity是透明的或者栈顶Activity并不是铺满整个手机屏幕），此时处于暂停状态；  当Activity被其他Activity完全遮挡，此时此Activity对用户不可见，此时处于停止状态；  当Activity由于人为或系统原因（如低内存等）被销毁，此时处于销毁状态；  因为activity需要先执行onpause才能启动上一个activity，所以onpause不能执行重量级操作。生命周期实例1. 生命周期说明2. 旋转屏幕（配置改变）sequenceDiagram\tparticipant A\tparticipant B\tA -&gt;&gt; A : onPause\tA -&gt;&gt; A : onStop\tA -&gt;&gt; A : onSaveInstanceState\tA -&gt;&gt; A : onDestroy\tA -&gt;&gt; B : onCreate\tB -&gt;&gt; B : onStart\tB -&gt;&gt; B : onRestoreInstanceState\tB -&gt;&gt; B : onResume3. 配置Configuration之后在对应的AndroidManifest.xml文件中对应的Activity下添加属性android:configChanges=\"orientation|screenSize\"之后进行旋转对应的Activity只会触发 onConfigurationChanged(newConfig : Configuration) 方法4. 用户从A跳转到B（B不可见）sequenceDiagram\tparticipant A\tparticipant B\tA -&gt;&gt; A : onPause\tA -&gt;&gt; B : onCreate\tB -&gt;&gt; B : onStart\tB -&gt;&gt; B : onResume\tB -&gt;&gt; A : onStop\tA -&gt;&gt; A : onSaveInstanceState5. 从B回退到AsequenceDiagram\tparticipant A\tparticipant B\tB -&gt;&gt; B : onPause\tB -&gt;&gt; A : onRestart\tA -&gt;&gt; A : onStart\tA -&gt;&gt; A : onResume\tA -&gt;&gt; B : onStop\tB -&gt;&gt; B : onDestroy6. B经过旋转之后再回退到AsequenceDiagram\tparticipant A\tparticipant B\tB -&gt;&gt; B : onPause\tB -&gt;&gt; A : onDestroy\tA -&gt;&gt; A : onCreate\tA -&gt;&gt; A : onStart\tA -&gt;&gt; A : onRestoreInstaceState\tA -&gt;&gt; A : onResume\tA -&gt;&gt; B : onStop\tB -&gt;&gt; B : onDestroy7. onActivityResult执行在onRestart之前ActivityThread相关  基于源码android sdk 29onCreate触发流程sequenceDiagram\tparticipant null\tparticipant ActivityThread\tparticipant Instrumentation\tparticipant Activity\tnull -&gt;&gt; ActivityThread : handleLaunchActivity\tActivityThread -&gt;&gt; ActivityThread : performLaunchActivity\tActivityThread -&gt;&gt; Instrumentation : callActivityOnCreate\tInstrumentation -&gt;&gt; Activity : performCreate\tActivity -&gt;&gt; Activity : onCreateonStart触发流程sequenceDiagram\tparticipant null\tparticipant ActivityThread\tparticipant Instrumentation\tparticipant Activity\tnull -&gt;&gt; ActivityThread: handleStartActivity\tActivityThread -&gt;&gt; Activity : performStart\tActivity -&gt;&gt; Instrumentation : callActivityOnStart\tInstrumentation -&gt;&gt; Activity : onStartonResume触发流程sequenceDiagram\tparticipant null\tparticipant ActivityThread\tparticipant Instrumentation\tparticipant Activity\tnull -&gt;&gt;  ActivityThread: handleResumeActivity\tActivityThread -&gt;&gt;  + ActivityThread : performResumeActivity\tActivityThread -&gt;&gt; - Activity :  performResume\tActivity -&gt;&gt; Instrumentation : callActivityOnResume\tInstrumentation -&gt;&gt; Activity : onResume"
  },
  
  {
    "title": "Unraid硬盘散热控制",
    "url": "/posts/unraid_temp/",
    "categories": "Unraid",
    "tags": "temp",
    "date": "2023-11-08 15:52:00 +0800",
    





    "snippet": "前言我有一台nas，不过nas的硬盘风扇电源不知道接哪里最合适，因为接主板上，需要手动去控制转速。而接硬盘背板时，这样会一直满负荷运行，导致太吵了。所以这里产生了一个想法，用arduino去控制风扇，再在nas里面去添加一个脚本，实时根据温度去发送应该的转速，然后使用pwm去控制风扇转速。nas python脚本# coding=utf-8import osimport socketfrom time import sleepdef get_temp():    temp = os.popen(\"ls -1 /dev/sd? | xargs -n1 smartctl -A | grep Celsius\").read()    item_temp = temp.split('\\n')    max_temp = 0    for item in item_temp:        if not item:            continue        split = item.split(' ')        index = split.index(\"(Min/Max\")        item_temp = split[index - 1]        max_temp = max(int(item_temp), max_temp)    return max_tempdef convert(temp):    if temp &gt; 44:        return 1000    elif temp &lt; 35:        return 0    else:        return (temp - 35) * 100sk = socket.socket()  # 创建socket对象sk.bind((\"0.0.0.0\", 9001))  # 绑定IP和端口sk.listen()  # 开启监听print(\"start listen\")while 1:  # 让服务端和客户端循环通信    conn, address = sk.accept()  # 等待客户端连接 阻塞    print(\"accept client\")    try:        while 1:            temp = get_temp()            send_msg = str(convert(temp))+'\\n'  # 要发送的消息            conn.send(send_msg.encode(\"utf-8\"))  # 发送消息给客户端            print(\"send temp success, current temp: \" + str(temp) + \"fan speed: \" + send_msg)            sleep(1)    except OSError:        print(\"send to client error\")        conn.close()首先使用ls -1 /dev/sd? | xargs -n1 smartctl -A | grep Celsius去获取当前所有硬盘的状态。根据获取到的值去进行拆分，获取到温度最大值。这里原计划是发送到公共的广播，但是esp8266的udp代码部分出现问题，所以改成还是用tcp实现了。这个可以添加为unraid的脚本，然后在array建立时直接运行。arduino这里使用的是esp8266，价格便宜，用在这里也算是大材小用了。#include &lt;ESP8266WiFi.h&gt;                        // 本程序使用ESP8266WiFi库const char* ssid     = \"xxxx-xxxx\";                // 需要连接到的WiFi名const char* password = \"xxxxxxxx\";             // 连接的WiFi密码int gpio = 16; // D0void setup() {  Serial.begin(115200);                         // 初始化串口通讯波特率为115200  analogWriteFreq(25000);            // 频率设置为25kHz  analogWriteRange(1000);           // 范围设置为1000  analogWrite(gpio, 1000);  WiFi.mode(WIFI_STA);                          // 设置Wifi工作模式为STA,默认为AP+STA模式  WiFi.begin(ssid, password);                   // 通过wifi名和密码连接到Wifi  Serial.print(\"\\r\\nConnecting to \");           // 串口监视器输出网络连接信息  Serial.print(ssid); Serial.println(\" ...\");   // 显示NodeMCU正在尝试WiFi连接  int i = 0;                                    // 检查WiFi是否连接成功  while (WiFi.status() != WL_CONNECTED)         // WiFi.status()函数的返回值是由NodeMCU的WiFi连接状态所决定的。  {                                             // 如果WiFi连接成功则返回值为WL_CONNECTED    delay(1000);                                // 此处通过While循环让NodeMCU每隔一秒钟检查一次WiFi.status()函数返回值    Serial.print(\"waiting for \");    Serial.print(i++); Serial.println(\"s...\");  }  Serial.println(\"\");                           // WiFi连接成功后  Serial.println(\"WiFi connected!\");            // NodeMCU将通过串口监视器输出\"连接成功\"信息。  Serial.print(\"IP address: \");                 // 同时还将输出NodeMCU的IP地址。这一功能是通过调用  Serial.println(WiFi.localIP());               // WiFi.localIP()函数来实现的。该函数的返回值即NodeMCU的IP地址。}const char* host = \"192.168.10.235\";const uint16_t port = 9001;void loop() {  /* 新建一个WiFiClient类对象，作为TCP客户端对象 */  WiFiClient tcpclient;  /* 建立TCP连接 */  Serial.print(\"connecting to \"); Serial.print(host); Serial.print(':'); Serial.println(port);  if (!tcpclient.connect(host, port)) {    Serial.println(\"connection failed\");        // 如果连接失败，则打印连接失败信息，并返回    delay(3000);    return;  }  while (true)  {    String str = tcpclient.readStringUntil('\\n');    if (str.length()==0)    {      // 读取失败时风扇满载运行      analogWrite(gpio, 1000);      break;    }    int value = str.toInt();    analogWrite(gpio, value);    Serial.println(str);  }}这里实现很简单，主要参考实例程序改写，首先是链接WiFi，然后接收服务端发送来的消息，然后根据传递过来的数字设置转速。代码地址https://github.com/jiangkerLove/temp_ctrl"
  },
  
  {
    "title": "ubuntu java多版本切换",
    "url": "/posts/java-version/",
    "categories": "Ubuntu",
    "tags": "java",
    "date": "2023-10-27 16:34:00 +0800",
    





    "snippet": "java安装在默认情况下，应该是不带有jdk的，这个时候，我们可以使用apt来下载apt-get install openjdk-8-jdk openjdk-11-jdk -y当下载多个版本后，默认的java应该就是后下载的那个的版本。使用update-alternatives切换版本在/usr/bin目录下➜  bin ls -al| grep javalrwxrwxrwx  1 root root          22 10月 27 16:26 java -&gt; /etc/alternatives/javalrwxrwxrwx  1 root root          23 10月 27 16:26 javac -&gt; /etc/alternatives/javaclrwxrwxrwx  1 root root          25 10月 27 16:26 javadoc -&gt; /etc/alternatives/javadoclrwxrwxrwx  1 root root          23 10月 27 16:26 javah -&gt; /etc/alternatives/javahlrwxrwxrwx  1 root root          23 10月 27 16:26 javap -&gt; /etc/alternatives/javap可以看到，实际上apt下载的jdk已经由alternatives来管理了，使用我们可以直接实验➜  bin update-alternatives --list java/usr/lib/jvm/java-11-openjdk-amd64/bin/java/usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java改成下载的jdk都列出在这里了。所以需要切换时直接切换即可➜  bin update-alternatives --config javaThere are 2 choices for the alternative java (providing /usr/bin/java).  Selection    Path                                            Priority   Status------------------------------------------------------------* 0            /usr/lib/jvm/java-11-openjdk-amd64/bin/java      1111      auto mode  1            /usr/lib/jvm/java-11-openjdk-amd64/bin/java      1111      manual mode  2            /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java   1081      manual modePress &lt;enter&gt; to keep the current choice[*], or type selection number: 2update-alternatives: using /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java to provide /usr/bin/java (java) in manual mode就可以顺利切换到java8了"
  },
  
  {
    "title": "ubuntu python多版本切换",
    "url": "/posts/python_version/",
    "categories": "Ubuntu",
    "tags": "python",
    "date": "2023-10-27 15:34:00 +0800",
    





    "snippet": "安装apt-get install python python3 -y默认情况，默认的python是指向python2的，在/usr/bin目录下➜  bin ls -al| grep pythonlrwxrwxrwx  1 root root           7 4月  15  2020 python -&gt; python2lrwxrwxrwx  1 root root           9 3月  13  2020 python2 -&gt; python2.7-rwxr-xr-x  1 root root     3662032 7月   1  2022 python2.7lrwxrwxrwx  1 root root           9 10月 27 12:48 python3 -&gt; python3.8-rwxr-xr-x  1 root root     5494584 5月  26 22:05 python3.8可以看到python链接到的是python2，不过一般切换python版本，我们不会直接去更改链接，会使用update-alternatives来管理配置和使用update-alternatives管理python版本查看目前可以管理的pythonupdate-alternatives --list python有可能会直接输出update-alternatives: error: no alternatives for python表示我们并没有关联任何的python版本绑定update-alternatives --install /usr/bin/python python /usr/bin/python3.8 1update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2语法：update-alternatives –install    这时如果再查看，则可以看到已经有了两个python版本了/usr/bin/python2.7/usr/bin/python3.8切换python版本➜  bin update-alternatives --config pythonThere are 2 choices for the alternative python (providing /usr/bin/python).  Selection    Path                Priority   Status------------------------------------------------------------* 0            /usr/bin/python2.7   2         auto mode  1            /usr/bin/python2.7   2         manual mode  2            /usr/bin/python3.8   1         manual modePress &lt;enter&gt; to keep the current choice[*], or type selection number: 2update-alternatives: using /usr/bin/python3.8 to provide /usr/bin/python (python) in manual mode➜  bin python --versionPython 3.8.10可以看到，已经切换到了python3了。删除python选项update-alternatives –remove    删除对应的选项update-alternatives –remove-all   删除的所有选项参考Ubuntu：Python多版本切换。"
  },
  
  {
    "title": "Ubuntu安装zsh",
    "url": "/posts/zsh/",
    "categories": "Ubuntu",
    "tags": "zsh",
    "date": "2023-10-27 14:49:00 +0800",
    





    "snippet": "zsh 安装更新sudo apt-get update安装zshsudo apt-get install zsh设置默认是呀zshchsh -s $(which zsh)下载安装wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh若失败可以使用sh -c \"$(wget -O- https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)\"参考  linux安装oh-my-zsh  [Ubuntu] 关于ohmyzsh下载被443拒绝连接"
  },
  
  {
    "title": "Android AOSP编译",
    "url": "/posts/aosp/",
    "categories": "Android",
    "tags": "AOSP",
    "date": "2023-10-27 14:40:00 +0800",
    





    "snippet": "环境搭建  所有操作都是在root用户下，所以最好首先切换到root用户更新apt-get updatezshzsh安装下载必备内容apt-get install -y git vim wget curl python iftopapt-get install -y git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 libncurses5 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig  注意这里下载的默认python应该是python2，而目前的repo是依赖的python3  iftop用于在aosp下载时查看网络情况，因为过程走的很慢配置gitgit config --global user.email \"niklaus1996@icloud.com\"git config --global user.name \"jiangker\"下载 repomkdir ~/bin &amp;&amp; cd ~/bincurl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repochmod +x repoPATH=~/bin:$PATHrepo更新配置，因为我们用了zsh，所以vim ~/.zshrc# 增加export REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo'AOSP下载创建工作目录mkdir ~/aosp &amp;&amp; cd ~/aosp初始化仓库repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest如果这里失败，提示语法错误，很可能就是python版本错误，可以直接修改repo默认的python版本为python3初始化指定分支repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-12.0.0_r34开始同步repo sync参考Android 镜像使用帮助编译# 导入构建脚本source build/envsetup.sh# 选择编译版本lunchmake -j24这里的lunch需要选择设备，参考选择设备 build，我这里是pixel3，所以是lunch aosp_blueline-userdebug参考编译 Android导入Android Studio#用于初始化环境变量source build/envsetup.sh  \t#生成文件out/host/linux-x86/framework/idegen.jarmmm development/tools/idegen/  #源码根目录生成文件android.ipr(工程相关设置), android.iml(模块相关配置)./development/tools/idegen/idegen.sh  Android Studio 导入工程时直接选择android.ipr刷入pixel3配置adb  这里默认已经下载过了Android Studio，所以系统中已经带有了Android Sdk相关内容了，我们只需要配置环境即可直接在~/.zshrc添加export ANDROID_HOME=/root/Android/Sdkexport PATH=\"$ANDROID_HOME/platform-tools:$PATH\"然后source ~/.zshrc因为前面已经使用过了AS，所以默认device驱动已经添加上了，如果没有可以在/etc/udev/rules.d/71-android.rules里添加输入命令可以看到，已经可以显示目前设备了➜  ~ adb devicesList of devices attached8B5X13Y0L\tdevice下载所需二进制文件在链接中找到对应的build id代号、标记和 build 号，这里可以看到android-12.0.0_r34对应的是SP1A.210812.016.C2然后在Nexus 和 Pixel 设备的驱动程序二进制文件里直接搜索，下载对应pixel3的二进制文件然后在根目录解压两个文件得到两个sh文件，执行sh文件，需要注意的是这里的sh文件都需要在最后输入I ACCEPT刷入设备如需刷写设备，请执行以下操作：      在启动时按住相应的组合键或使用以下命令使设备进入 fastboot 模式：     adb reboot bootloader        pixel3的组合键是先音量减然后再关机键，其它机型可以看启动进入 fastboot 模式        在设备处于 fastboot 模式后，运行以下命令：     fastboot flashall -w        如果提示fastboot: error: ANDROID_PRODUCT_OUT not set，可以选择配置一下，例如pixel3是blueline，所以输出的包是在out/target/product/blueline目录下，可以配置     export ANDROID_PRODUCT_OUT=`pwd`/out/target/product/blueline      "
  },
  
  {
    "title": "actix-web 框架",
    "url": "/posts/actix-web/",
    "categories": "Rust",
    "tags": "actix-web",
    "date": "2023-10-25 15:54:00 +0800",
    





    "snippet": "常见问题中文乱码返回的中文是乱码，其余正常，断点以及数据库中存储的数据都是正常的。这时可以加上使用utf-8字符。HttpResponse::Ok()    .content_type(\"text/plain; charset=utf-8\")    .body(format!(\"{}\", “你好，世界”))"
  },
  
  {
    "title": "rustup更换镜像",
    "url": "/posts/rustup_source/",
    "categories": "Rust",
    "tags": "rustup",
    "date": "2023-10-22 22:01:00 +0800",
    





    "snippet": "添加到配置文件echo 'export RUSTUP_UPDATE_ROOT=https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup' &gt;&gt; ~/.bash_profileecho 'export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup' &gt;&gt; ~/.bash_profilesource ~/.bash_profile"
  },
  
  {
    "title": "ubuntu更换阿里源",
    "url": "/posts/apt-source/",
    "categories": "Ubuntu",
    "tags": "apt",
    "date": "2023-10-22 21:31:00 +0800",
    





    "snippet": "前言因为默认ubuntu的源是国外的，使用会出现更新很慢的情况，严重影响效率，所以需要先进行替换。ubuntu系统因为大多数时候默认是没有vim的，所以使用vi来打开vi /etc/apt/sources.list然后替换里面的内容deb http://mirrors.aliyun.com/debian/ buster main non-free contribdeb http://mirrors.aliyun.com/debian/ buster-updates main non-free contribdeb http://mirrors.aliyun.com/debian/ buster-backports main non-free contribdeb http://mirrors.aliyun.com/debian-security/ buster/updates main non-free contribdeb-src http://mirrors.aliyun.com/debian/ buster main non-free contribdeb-src http://mirrors.aliyun.com/debian/ buster-updates main non-free contribdeb-src http://mirrors.aliyun.com/debian/ buster-backports main non-free contribdeb-src http://mirrors.aliyun.com/debian-security/ buster/updates main non-free contrib也可以直接删除文件，然后创建文件就OK，更新完成后更新souceapt-get updatedebian容器在一些时候，我们需要使用很简洁的debian容器，容器的内部根本没有vim和vi命令，使用这个时候我们可以先在启动容器之前先在待会儿挂载的目录下先放好需要的这个souce文件，然后在容器内部去拷贝过去替换"
  },
  
  {
    "title": "rust交叉编译",
    "url": "/posts/cross_compilation/",
    "categories": "Rust",
    "tags": "cross compilation",
    "date": "2023-10-22 11:13:00 +0800",
    





    "snippet": "前言我为什么需要使用rust进行交叉编译，因为想使用rust编译和运行web程序，所以使用Dockerfile时需要分为构建和运行两个步骤进行，但是编译出的程序并不能直接运行，所以改用交叉编译的方式来打包，就可以在对应架构下的容器内直接运行。配置环境我这里直接使用docker镜像，搭建一个专门用来编译docker的容器。首先在pwd/rust-build目录下准备好apt souce的源文件。apt更换源docker run -it --name rust-build -v `pwd`/rust-build:/web rust:1.73.0-slim-buster /bin/bash使用目前最新的rust版本，然后在用户目录下映射常用来编译的目录。然后先更新源，再开始下载编译环境。这里需要使用rustup，也需要添加镜像源rustup更换源rustup target add x86_64-unknown-linux-musl编译cargo build --release --target x86_64-unknown-linux-musl常见报错musl-tools编译过程报错error: failed to run custom build command for `ring v0.16.20`Caused by:  process didn't exit successfully: `/web/house-monitor/target/release/build/ring-59b47e2d18302b2c/build-script-build` (exit status: 101)  --- stdout  OPT_LEVEL = Some(\"3\")  TARGET = Some(\"x86_64-unknown-linux-musl\")  HOST = Some(\"x86_64-unknown-linux-gnu\")  cargo:rerun-if-env-changed=CC_x86_64-unknown-linux-musl  CC_x86_64-unknown-linux-musl = None  cargo:rerun-if-env-changed=CC_x86_64_unknown_linux_musl  CC_x86_64_unknown_linux_musl = None  cargo:rerun-if-env-changed=TARGET_CC  TARGET_CC = None  cargo:rerun-if-env-changed=CC  CC = None  RUSTC_LINKER = None  cargo:rerun-if-env-changed=CROSS_COMPILE  CROSS_COMPILE = None  cargo:rerun-if-env-changed=CRATE_CC_NO_DEFAULTS  CRATE_CC_NO_DEFAULTS = None  DEBUG = Some(\"false\")  CARGO_CFG_TARGET_FEATURE = Some(\"fxsr,sse,sse2\")  cargo:rerun-if-env-changed=CFLAGS_x86_64-unknown-linux-musl  CFLAGS_x86_64-unknown-linux-musl = None  cargo:rerun-if-env-changed=CFLAGS_x86_64_unknown_linux_musl  CFLAGS_x86_64_unknown_linux_musl = None  cargo:rerun-if-env-changed=TARGET_CFLAGS  TARGET_CFLAGS = None  cargo:rerun-if-env-changed=CFLAGS  CFLAGS = None  --- stderr  running \"musl-gcc\" \"-O3\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"-m64\" \"-I\" \"include\" \"-Wall\" \"-Wextra\" \"-pedantic\" \"-pedantic-errors\" \"-Wall\" \"-Wextra\" \"-Wcast-align\" \"-Wcast-qual\" \"-Wconversion\" \"-Wenum-compare\" \"-Wfloat-equal\" \"-Wformat=2\" \"-Winline\" \"-Winvalid-pch\" \"-Wmissing-field-initializers\" \"-Wmissing-include-dirs\" \"-Wredundant-decls\" \"-Wshadow\" \"-Wsign-compare\" \"-Wsign-conversion\" \"-Wundef\" \"-Wuninitialized\" \"-Wwrite-strings\" \"-fno-strict-aliasing\" \"-fvisibility=hidden\" \"-fstack-protector\" \"-g3\" \"-U_FORTIFY_SOURCE\" \"-DNDEBUG\" \"-c\" \"-o/web/house-monitor/target/x86_64-unknown-linux-musl/release/build/ring-95fb3f38509657d3/out/aesni-x86_64-elf.o\" \"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ring-0.16.20/pregenerated/aesni-x86_64-elf.S\"  thread 'main' panicked at /usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ring-0.16.20/build.rs:653:9:  failed to execute [\"musl-gcc\" \"-O3\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"-m64\" \"-I\" \"include\" \"-Wall\" \"-Wextra\" \"-pedantic\" \"-pedantic-errors\" \"-Wall\" \"-Wextra\" \"-Wcast-align\" \"-Wcast-qual\" \"-Wconversion\" \"-Wenum-compare\" \"-Wfloat-equal\" \"-Wformat=2\" \"-Winline\" \"-Winvalid-pch\" \"-Wmissing-field-initializers\" \"-Wmissing-include-dirs\" \"-Wredundant-decls\" \"-Wshadow\" \"-Wsign-compare\" \"-Wsign-conversion\" \"-Wundef\" \"-Wuninitialized\" \"-Wwrite-strings\" \"-fno-strict-aliasing\" \"-fvisibility=hidden\" \"-fstack-protector\" \"-g3\" \"-U_FORTIFY_SOURCE\" \"-DNDEBUG\" \"-c\" \"-o/web/house-monitor/target/x86_64-unknown-linux-musl/release/build/ring-95fb3f38509657d3/out/aesni-x86_64-elf.o\" \"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ring-0.16.20/pregenerated/aesni-x86_64-elf.S\"]: No such file or directory (os error 2)  note: run with `RUST_BACKTRACE=1` environment variable to display a backtracewarning: build failed, waiting for other jobs to finish...下载apt-get install musl-toolsopenssl-sys报错信息error: failed to run custom build command for `openssl-sys v0.9.93`Caused by:  process didn't exit successfully: `/web/house-monitor/target/release/build/openssl-sys-8c5cac0f00469e9a/build-script-main` (exit status: 101)  --- stdout  cargo:rerun-if-env-changed=X86_64_UNKNOWN_LINUX_MUSL_OPENSSL_LIB_DIR  X86_64_UNKNOWN_LINUX_MUSL_OPENSSL_LIB_DIR unset  cargo:rerun-if-env-changed=OPENSSL_LIB_DIR  OPENSSL_LIB_DIR unset  cargo:rerun-if-env-changed=X86_64_UNKNOWN_LINUX_MUSL_OPENSSL_INCLUDE_DIR  X86_64_UNKNOWN_LINUX_MUSL_OPENSSL_INCLUDE_DIR unset  cargo:rerun-if-env-changed=OPENSSL_INCLUDE_DIR  OPENSSL_INCLUDE_DIR unset  cargo:rerun-if-env-changed=X86_64_UNKNOWN_LINUX_MUSL_OPENSSL_DIR  X86_64_UNKNOWN_LINUX_MUSL_OPENSSL_DIR unset  cargo:rerun-if-env-changed=OPENSSL_DIR  OPENSSL_DIR unset  cargo:rerun-if-env-changed=OPENSSL_NO_PKG_CONFIG  cargo:rerun-if-env-changed=PKG_CONFIG_ALLOW_CROSS_x86_64-unknown-linux-musl  cargo:rerun-if-env-changed=PKG_CONFIG_ALLOW_CROSS_x86_64_unknown_linux_musl  cargo:rerun-if-env-changed=TARGET_PKG_CONFIG_ALLOW_CROSS  cargo:rerun-if-env-changed=PKG_CONFIG_ALLOW_CROSS  cargo:rerun-if-env-changed=PKG_CONFIG_x86_64-unknown-linux-musl  cargo:rerun-if-env-changed=PKG_CONFIG_x86_64_unknown_linux_musl  cargo:rerun-if-env-changed=TARGET_PKG_CONFIG  cargo:rerun-if-env-changed=PKG_CONFIG  cargo:rerun-if-env-changed=PKG_CONFIG_SYSROOT_DIR_x86_64-unknown-linux-musl  cargo:rerun-if-env-changed=PKG_CONFIG_SYSROOT_DIR_x86_64_unknown_linux_musl  cargo:rerun-if-env-changed=TARGET_PKG_CONFIG_SYSROOT_DIR  cargo:rerun-if-env-changed=PKG_CONFIG_SYSROOT_DIR  run pkg_config fail: pkg-config has not been configured to support cross-compilation.  Install a sysroot for the target platform and configure it via  PKG_CONFIG_SYSROOT_DIR and PKG_CONFIG_PATH, or install a  cross-compiling wrapper for pkg-config and set it via  PKG_CONFIG environment variable.  --- stderr  thread 'main' panicked at /usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/openssl-sys-0.9.93/build/find_normal.rs:190:5:  Could not find directory of OpenSSL installation, and this `-sys` crate cannot  proceed without this knowledge. If OpenSSL is installed and this crate had  trouble finding it,  you can set the `OPENSSL_DIR` environment variable for the  compilation process.  Make sure you also have the development packages of openssl installed.  For example, `libssl-dev` on Ubuntu or `openssl-devel` on Fedora.  If you're in a situation where you think the directory *should* be found  automatically, please open a bug at https://github.com/sfackler/rust-openssl  and include information about your system as well as this message.  $HOST = x86_64-unknown-linux-gnu  $TARGET = x86_64-unknown-linux-musl  openssl-sys = 0.9.93  note: run with `RUST_BACKTRACE=1` environment variable to display a backtracewarning: build failed, waiting for other jobs to finish...尽管看提示说可以下载libssl-dev来解决这个问题，但是实际上，如果是交叉编译，下载了这个也一样编译不过。所以我们这里需要手动编译openssl解决以下这些步骤都是不可或缺的，最好挨着依次配置mkdir /musl &amp;&amp; cd /muslapt-get install -y wget pkg-config make musl-toolswget https://www.openssl.org/source/openssl-1.1.1w.tar.gztar -zxvf openssl-1.1.1w.tar.gzcd openssl-1.1.1wln -s /usr/include/x86_64-linux-gnu/asm /usr/include/x86_64-linux-musl/asmln -s /usr/include/asm-generic /usr/include/x86_64-linux-musl/asm-genericln -s /usr/include/linux /usr/include/x86_64-linux-musl/linuxCC=\"musl-gcc -fPIE -pie\" ./Configure no-shared no-async --prefix=/musl --openssldir=/musl/ssl linux-x86_64make dependmake -j$(nproc)make installexport PKG_CONFIG_ALLOW_CROSS=1export OPENSSL_STATIC=trueexport OPENSSL_DIR=/musl这里可以看到，实际不需要下载libssl-dev，当然下载了也无妨pkg-config如果没有下载这个，可能会出现root@88b11af69d55:/musl/openssl-1.1.1w# CC=\"musl-gcc -fPIE -pie\" ./Configure no-shared no-async --prefix=/musl --openssldir=/musl/ssl linux-x86_64Can't locate FindBin.pm in @INC (you may need to install the FindBin module) (@INC contains: /etc/perl /usr/local/lib/x86_64-linux-gnu/perl/5.28.1 /usr/local/share/perl/5.28.1 /usr/lib/x86_64-linux-gnu/perl5/5.28 /usr/share/perl5 /usr/lib/x86_64-linux-gnu/perl/5.28 /usr/share/perl/5.28 /usr/local/lib/site_perl /usr/lib/x86_64-linux-gnu/perl-base) at ./Configure line 15.BEGIN failed--compilation aborted at ./Configure line 15.安装过后的话命令就可以正常运行通过了root@88b11af69d55:/musl/openssl-1.1.1w# CC=\"musl-gcc -fPIE -pie\" ./Configure no-shared no-async --prefix=/musl --openssldir=/musl/ssl linux-x86_64Configuring OpenSSL version 1.1.1w (0x1010117fL) for linux-x86_64Using os-specific seed configurationCreating configdata.pmCreating Makefile*************************************************************************                                                                ******   OpenSSL has been successfully configured                     ******                                                                ******   If you encounter a problem while building, please open an    ******   issue on GitHub &lt;https://github.com/openssl/openssl/issues&gt;  ******   and include the output from the following command:           ******                                                                ******       perl configdata.pm --dump                                ******                                                                ******   (If you are new to OpenSSL, you might want to consult the    ******   'Troubleshooting' section in the INSTALL file first)         ******                                                                *************************************************************************musl-gcc: not found一般正常很多编译都需要这个，可以看到如果没有安装这个，make命令在执行-j以及install时都会报错root@88b11af69d55:/musl/openssl-1.1.1w# make -j$(nproc)/usr/bin/perl \"-I.\" -Mconfigdata \"util/dofile.pl\" \\    \"-oMakefile\" include/crypto/bn_conf.h.in &gt; include/crypto/bn_conf.h/usr/bin/perl \"-I.\" -Mconfigdata \"util/dofile.pl\" \\    \"-oMakefile\" include/crypto/dso_conf.h.in &gt; include/crypto/dso_conf.h/usr/bin/perl \"-I.\" -Mconfigdata \"util/dofile.pl\" \\    \"-oMakefile\" include/openssl/opensslconf.h.in &gt; include/openssl/opensslconf.hmake depend &amp;&amp; make _allmake[1]: Entering directory '/musl/openssl-1.1.1w'make[1]: Leaving directory '/musl/openssl-1.1.1w'make[1]: Entering directory '/musl/openssl-1.1.1w'musl-gcc -fPIE -pie  -I. -Iinclude -fPIC -pthread -m64 -Wall -O3 -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DKECCAK1600_ASM -DRC4_ASM -DMD5_ASM -DAESNI_ASM -DVPAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DX25519_ASM -DPOLY1305_ASM -DOPENSSLDIR=\"\\\"/musl/ssl\\\"\" -DENGINESDIR=\"\\\"/musl/lib/engines-1.1\\\"\" -DNDEBUG   -c -o apps/app_rand.o apps/app_rand.cmusl-gcc -fPIE -pie  -I. -Iinclude -fPIC -pthread -m64 -Wall -O3 -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DKECCAK1600_ASM -DRC4_ASM -DMD5_ASM -DAESNI_ASM -DVPAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DX25519_ASM -DPOLY1305_ASM -DOPENSSLDIR=\"\\\"/musl/ssl\\\"\" -DENGINESDIR=\"\\\"/musl/lib/engines-1.1\\\"\" -DNDEBUG   -c -o apps/apps.o apps/apps.cmusl-gcc -fPIE -pie  -I. -Iinclude -fPIC -pthread -m64 -Wall -O3 -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DKECCAK1600_ASM -DRC4_ASM -DMD5_ASM -DAESNI_ASM -DVPAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DX25519_ASM -DPOLY1305_ASM -DOPENSSLDIR=\"\\\"/musl/ssl\\\"\" -DENGINESDIR=\"\\\"/musl/lib/engines-1.1\\\"\" -DNDEBUG   -c -o apps/bf_prefix.o apps/bf_prefix.c/bin/sh: 1: musl-gcc: not foundmake[1]: *** [Makefile:671: apps/app_rand.o] Error 127make[1]: *** Waiting for unfinished jobs..../bin/sh: 1: musl-gcc: not foundmake[1]: *** [Makefile:673: apps/apps.o] Error 127/bin/sh: 1: musl-gcc: not foundmake[1]: *** [Makefile:675: apps/bf_prefix.o] Error 127make[1]: Leaving directory '/musl/openssl-1.1.1w'make: *** [Makefile:172: all] Error 2unable to get local issuer certificate如果使用了reqwest(http库)，当交叉编译完成后，在一个很精简的debian docker容器中运行时，在请求接口时可能会有如下报错thread 'main' panicked at src/service/xxx.rs:18:16:called `Result::unwrap()` on an `Err` value: reqwest::Error { kind: Request, url: Url { scheme: \"https\", cannot_be_a_base: false, username: \"\", password: None, host: Some(Domain(\"xxx.com\")), port: None, path: \"/xxx/xxx\", query: Some(\"xxx=xxx&amp;xxx=xxx\"), fragment: None }, source: hyper::Error(Connect, Ssl(Error { code: ErrorCode(1), cause: Some(Ssl(ErrorStack([Error { code: 337047686, library: \"SSL routines\", function: \"tls_process_server_certificate\", reason: \"certificate verify failed\", file: \"ssl/statem/statem_clnt.c\", line: 1921 }]))) }, X509VerifyResult { code: 20, error: \"unable to get local issuer certificate\" })) }note: run with `RUST_BACKTRACE=1` environment variable to display a backtracehow to fix？apt-get install ca-certificates参考How to build openssl-sys crate for musl in RustWhy rust is failing to build command for openssl-sys v0.9.60 even after local installation?Ubuntu 18: failed to run custom build command for openssl-sys v0.9.39"
  },
  
  {
    "title": "增加webhooks自动更新blog",
    "url": "/posts/update_blog/",
    "categories": "Rust",
    "tags": "actix-web",
    "date": "2023-10-21 11:28:00 +0800",
    





    "snippet": "前言需要实现一个，当push代码后，实现一个github的webhooks的接口，然后拉去最新的内容，更新博客。之前由Spring boot实现过一款，但是简单的一个接口，占用的内存就比较高，所以现在改用rust来实现。这样可以使内存的占用直接控制在10mb以内。增加依赖[dependencies]actix-web = \"4.4.0\"代码use std::process::Command;use actix_web::{App, HttpResponse, HttpServer, Responder, post};//webhook是post请求，所以对所有post请求都执行更新web#[post(\"/\")]async fn get_pull_update() -&gt; impl Responder {    //执行git pull 返回shell执行的结果    match Command::new(\"sh\").arg(\"-c\").arg(\"git pull\").output() {        Ok(res) =&gt; HttpResponse::Ok().body(format!(\"update success! {:?}\", res)),        Err(err) =&gt; HttpResponse::Ok().body(format!(\"update fail! {}\", err))    }}//将 async main 函数标记为 actix 系统的入口点。#[actix_web::main]async fn main() -&gt; std::io::Result&lt;()&gt; {    //创建 http 服务器    HttpServer::new(|| {        App::new()//新建一个应用            .service(get_pull_update)//将 hello 函数作为服务    })        .bind(\"0.0.0.0:8080\")?//绑定ip和端口，这里需要使用0.0.0.0才能接收到外部请求        .run()//开始监听        .await}额外需要注意的是，在容器类需要下载git，然后配置ssh，就可以正常使用了"
  },
  
  {
    "title": "使用serde解析json",
    "url": "/posts/serde_json/",
    "categories": "Rust",
    "tags": "serde",
    "date": "2023-10-20 23:00:00 +0800",
    





    "snippet": "使用serde解析json添加依赖在Cargo.toml文件中添加以下行：[dependencies]serde = { version = \"1.0\", features = [\"derive\"] }serde_json = \"1.0\"Object to jsonuse serde::{Serialize, Deserialize};#[derive(Serialize, Deserialize)]struct User {    name: String,    age: u8,    skill: Vec&lt;String&gt;,}fn main() {    let user = User {        name: \"jiangker\".into(),        age: 18,        skill: vec![\"Java\".into(), \"Rust\".into(), \"Dart\".into()],    };    // 序列化为JSON字符串    let user_str = serde_json::to_string(&amp;user).unwrap();    println!(\"{}\", user_str)}输出{\"name\":\"jiangker\",\"age\":18,\"skill\":[\"Java\",\"Rust\",\"Dart\"]}Json to Object任何正常的json都可以直接解析成serde中定义的枚举enum Value {    Null,    Bool(bool),    Number(Number),    String(String),    Array(Vec&lt;Value&gt;),    Object(Map&lt;String, Value&gt;),}示例fn main() {    // 一个&amp;str类型的JSON数据    let data: &amp;str = r#\"{\"name\":\"jiangker\",\"age\":18,\"skill\":[\"Java\",\"Rust\",\"Dart\"]}\"#;    // 转换成Value    let user_value: serde_json::Value = serde_json::from_str(data).unwrap();    println!(\"{:?}\", user_value);    println!(\"name: {}\", user_value[\"name\"]);}输出Object {\"age\": Number(18), \"name\": String(\"jiangker\"), \"skill\": Array [String(\"Java\"), String(\"Rust\"), String(\"Dart\")]}name: \"jiangker\"也可以直接解析为对象#[derive(serde::Deserialize, Debug)]struct User {    name: String,    age: u8,    skill: Vec&lt;String&gt;,}fn main() {    // 一个&amp;str类型的JSON数据    let data: &amp;str = r#\"{\"name\":\"jiangker\",\"age\":18,\"skill\":[\"Java\",\"Rust\",\"Dart\"]}\"#;    // 转换成User对象    let user: User = serde_json::from_str(data).unwrap();    println!(\"{:?}\", user);    println!(\"name: {}\", user.name);    println!(\"age: {}\", user.age);    println!(\"skill: {:?}\", user.skill);}输出User { name: \"jiangker\", age: 18, skill: [\"Java\", \"Rust\", \"Dart\"] }name: jiangkerage: 18skill: [\"Java\", \"Rust\", \"Dart\"]json宏use serde_json::{json, Value};fn main() {    // 定义一个json宏    let user: Value = json!({\"name\":\"jiangker\",\"age\":18,\"skill\":[\"Java\",\"Rust\",\"Dart\"]});    println!(\"{:?}\", user);    println!(\"name: {}\", user[\"name\"]);}输出Object {\"age\": Number(18), \"name\": String(\"jiangker\"), \"skill\": Array [String(\"Java\"), String(\"Rust\"), String(\"Dart\")]}name: \"jiangker\""
  },
  
  {
    "title": "InheritedWidget Share Data",
    "url": "/posts/inherited-widget/",
    "categories": "flutter",
    "tags": "data-sharing",
    "date": "2023-09-14 11:00:00 +0800",
    





    "snippet": "If we had get the official demo app, the data saved in _MyHomePageState, used buy his child Widget and operated by other child button. We can split this Widget, create a ShowText to show the count and an IncrementBtn to operate the count,like thisbut we still need save count in _MyHomePageState, diliver count to ShowText, get a option callback to IncrementBtn. If there were many data in this page, this would be a huge disaster.So we can use InheritedWidget to share data.class ShareCountWidget extends InheritedWidget {  const ShareCountWidget(this.count, {super.key, required super.child});  final int count;  static ShareCountWidget? of(BuildContext context) {    return context.dependOnInheritedWidgetOfExactType&lt;ShareCountWidget&gt;();  }  @override  bool updateShouldNotify(covariant ShareCountWidget oldWidget) =&gt; oldWidget.count != count;}Even a child widget that is decorated with const will be updated just like any other widget.It help us to sharing data and update widget, but still need us to create state to save data.PrincipleInheritedWidget corresponds to InheritedElement.class InheritedElement extends ProxyElement {  InheritedElement(InheritedWidget super.widget);  final Map&lt;Element, Object?&gt; _dependents = HashMap&lt;Element, Object?&gt;();  @override  void _updateInheritance() {    assert(_lifecycleState == _ElementLifecycle.active);    final PersistentHashMap&lt;Type, InheritedElement&gt; incomingWidgets =        _parent?._inheritedElements ?? const PersistentHashMap&lt;Type, InheritedElement&gt;.empty();    _inheritedElements = incomingWidgets.put(widget.runtimeType, this);  }}_dependents is used to record which Elements depend on its data.abstract class Element extends DiagnosticableTree implements BuildContext {    PersistentHashMap&lt;Type, InheritedElement&gt;? _inheritedElements;    Set&lt;InheritedElement&gt;? _dependencies;    void _updateInheritance() {        assert(_lifecycleState == _ElementLifecycle.active);        _inheritedElements = _parent?._inheritedElements;    }}_inheritedElements is from it’s parent. If current Element is InheritedElement, it will add itself to it.This approach has the benefit that adding a child element will not affect the parent element._dependencies is used to record it’s dependence. When it removed from the ELement tree, remove itself from InheritedElement._dependents."
  },
  
  {
    "title": "unraid jenkins安装和配置",
    "url": "/posts/jenkins/",
    "categories": "Unraid, Jenkins",
    "tags": "jenkins",
    "date": "2023-08-29 10:10:00 +0800",
    





    "snippet": "Jenkins安装一般情况Jenkins的安装都是使用docker-compose，在文件中把环境配置都创建好，但是unraid中不能使用compose，所以为了保持一致性，需要自己手动配置相关环境。注意此处映射的路径需要是有所有权限的，可以通过设置chmod 777 Jenkins运行镜像相关的配置，默认直接在app市场搜索，然后就行一点小修改即可。docker run  -d  --name='Jenkins'  --net='bridge'  --privileged=true  -e TZ=\"Asia/Shanghai\"  -e HOST_OS=\"Unraid\"  -e HOST_HOSTNAME=\"root\"  -e HOST_CONTAINERNAME=\"Jenkins\"  -l net.unraid.docker.managed=dockerman  -l net.unraid.docker.webui='http://[IP]:[PORT:9999]/'  -l net.unraid.docker.icon='https://raw.githubusercontent.com/selfhosters/unRAID-CA-templates/master/templates/img/jenkins.png'  -p '9999:8080/tcp'  -v '/mnt/user/appdata/Jenkins':'/var/jenkins_home':'rw' 'jenkins/jenkins:2.414.1-lts-jdk17'这里只映射了一个映射路径，计划是把sdk相关的配置都放入到此目录下。镜像也选择官方的最新镜像，但因为需要使用Android commandlinetools来配置Android SDK，并且最新的commandlinetools依赖jdk17，所以我这里直接使用的建立在jdk17环境上的镜像，若采用默认镜像，可能是jdk11，此时需要自己配置一下默认的jdk环境。Root用户配置因为需要涉及到一些编辑，所以优先使用root用户就行登陆，然后进行部分内容的安装。宿主主机登陆Jenkins容器Root用户docker exec -it -u root Jenkins /bin/bash更新apt-get update安装wget和vimapt-get install wget vim -ySDK相关安装配置在默认用户下安装剩下的配置，因为默认用户根目录为/var/jenkins_home，即我们的映射过的目录。大致需要安装的sdk路径关系如下~├─sdk|  ├─jdk|  |   └─jdk17|  ├─android-sdk|  |   └cmdline-tools|  ├─gradle|  |   ├─gradle8.0.0|  |   └─gradle8.1.0宿主主机登陆Jenkins容器默认用户docker exec -it Jenkins /bin/bashssh配置因为Jenkins安装默认插件时自动带有git，所以我们直接配置ssh密钥就可以了ssh-keygen -o一路yes生成密钥，在gitlab上添加pub keycat ~/.ssh/id_rsa.pub然后添加私钥到Jenkins中(系统管理-&gt;凭证管理-&gt;凭证-&gt;系统-&gt;全局凭证)，选择Add Credentials添加凭证，选择SSH private key，然后把私钥直接填入对应输入框。其余id名字任意填写即可，填写过后如图。cat ~/.ssh/id_rsa但此次设置完成后，在构建节点中如果要直接去使用的话，得首先进行host认证，可以先进行一次代码的拉取。否则会出现拉取代码认证如图在构建任务中可以直接进行选择了安装安卓编译环境首先进入到用户目录，然后创建sdk文件夹、android-sdk文件夹，然后进入对应目录cd ~ mkdir sdkcd sdkmkdir android-sdkcd android-sdkAndroid commandlinetools可以在下载地址最下面的Command line tools only找到，这里下载Linux版本的。wget https://dl.google.com/android/repository/commandlinetools-linux-10406996_latest.zip解压对应文件，然后需要移动解压出来的文件到其子目录下,结果如下：~/sdk/android-sdk├─cmdline-tools|  ├─lasted|  |   ├─bin/|  |   ├─lib/|  |   ├─source.properties|  |   └─NOTICE.txtunzip -o commandlinetools-linux-10406996_latest.zipcd cmdline-toolsmkdir lastedmv NOTICE.txt bin/ lib/ source.properties lasted/同意条款，此次需要运行在jdk17上cd lasted/bin./sdkmanager --licenses一路y直到完成，然后在Jenkins的系统管理-&gt;系统配置中的全局熟悉下添加环境变量安装gradle在gradle目录下下载需要的sdk，可以在下载地址 选择需要的版本，下载解压即可wget https://services.gradle.org/distributions/gradle-8.0-bin.zipunzip -o gradle-8.0-bin.zip然后在Jenkins的系统管理-&gt;全局工具配置的gradle配置下，添加对应的gradle版本。安装java环境和gradle类似，下载解压对应的jdk即可。wget https://download.oracle.com/java/17/archive/jdk-17.0.8_linux-x64_bin.tar.gztar -zxvf jdk-17.0.8_linux-x64_bin.tar.gz同样在Jenkins的系统管理-&gt;全局工具配置的jdk配置下，添加对应jdk"
  },
  
  {
    "title": "unraid docker安装gitlab",
    "url": "/posts/unraid_gitlab/",
    "categories": "Unraid",
    "tags": "gitlab",
    "date": "2023-08-27 21:18:00 +0800",
    





    "snippet": "使用docker安装gitlabdocker run  -d  --name='GitLab-CE'  --net='bridge'  -e TZ=\"Asia/Shanghai\"  -e HOST_OS=\"Unraid\"  -e HOST_HOSTNAME=\"root\"  -e HOST_CONTAINERNAME=\"GitLab-CE\"  -l net.unraid.docker.managed=dockerman  -l net.unraid.docker.webui='http://[IP]:[PORT:9080]'  -l net.unraid.docker.icon='https://raw.githubusercontent.com/tynor88/docker-templates/master/images/gitlab_small.png'  -p '7888:22/tcp'  -p '9080:80/tcp'  -v '/mnt/user/appdata/gitlab/config':'/etc/gitlab':'rw'  -v '/mnt/user/appdata/gitlab/data':'/var/opt/gitlab':'rw'  -v '/mnt/user/appdata/gitlab/log':'/var/log/gitlab':'rw'  --env GITLAB_OMNIBUS_CONFIG=\"external_url 'http://gitlab.jiangker.cn/'; gitlab_rails['gitlab_shell_ssh_port'] = 7888\" 'gitlab/gitlab-ce'  external_url 'http://gitlab.jiangker.cn/' 此处的端口为http访问的端口，是容器内端口  gitlab_rails['gitlab_shell_ssh_port'] = 7888此处端口为ssh同步代码时的端口，需要和容器内22端口绑定的宿主端口一致see see 密码初始密码可以在/mnt/cache/appdata/gitlab/config/initial_root_password中可以看到"
  },
  
  {
    "title": "HomeAssistant安装HACS",
    "url": "/posts/hacs/",
    "categories": "RaspberryPi, application",
    "tags": "raspberrypi, docker",
    "date": "2023-04-16 10:18:00 +0800",
    





    "snippet": ""
  },
  
  {
    "title": "OpenWrt安装和配置",
    "url": "/posts/openwrt/",
    "categories": "Other",
    "tags": "openwrt",
    "date": "2023-02-04 11:15:00 +0800",
    





    "snippet": "安装文件准备  微PE文件  U盘  OpenWrt镜像文件  physdiskwrite.exe文件  含硬盘的多网口小主机制作微PE启动盘微PE是一个exe文件。所以在win系统下选择制作启动U盘。然后把OpenWrt镜像文件和physdiskwrite.exe文件都拷贝到U盘里。把u盘插入到小主机上，选择U盘启动，进入到微PE系统。使用里面的分区助手清除掉小主机内部硬盘的分区（否则写入会失败）使用win+r打开搜索框，输入cmd回车打开命令行界面，输入physdiskwrite.exe -u {$openwrt.img}然后回车。两个对应的文件需要为全路径此时会显示可以写入的磁盘，我这里只有硬盘和U盘，所以这里只显示了两个。然后选择需要写入的disk序号，应该于分区工具的序号一致的。然后回车，最后输入y回车确认。等待文件写入完成即制作完成了。扩容overlay分区默认安装完成之后，可以使用的overlay区域是很小的，大区域的可能会导致镜像异常的大。所以在使用之前需要先进行一个扩容。这里需要准备一个u盘的linux系统，可以单独准备，也可以使用最先的u盘。  rufus.exe  gparted.iso  u盘  已经安装好并且未启动过的openwrt小主机使用rufus.exe制作启动u盘，然后插入小主机，设置u盘启动。进入到gparted系统后选择默认回车适用就行。然后选择默认语言，在输入2回车选择command line模式。输入parted /dev/sda 来对硬盘重新进行分区如果提示警告很多空间未使用。则输入Fix进入然后会输出目前硬盘所有的盘符，可以看到一个几百兆空间的就是我们需要扩容的区域，一般也是最后一个盘符，我这里为2.输入resizepart 2 60G回车，第二个参数为盘符，最后一个参数为将end位置移动到哪，我这里硬盘是128的，所以使用一半左右的空间。输入print命令可以看到2区域已经被扩容了输入quit命令退出，再输入shutwodn进行关机，然后拔掉u盘这样扩容就已经完成了。可以开始启动openwrt了启动配置作为一个硬路由使用，需要设置一下密码修改密码passwd配置网关需要连接好网线，这样才会有ipvi /etc/config/network主要修改默认ip和把lan口设置为eth1，wan口设置为eth0config interface 'loopback'        option ifname 'lo'        option proto 'static'        option ipaddr '127.0.0.1'        option netmask '255.0.0.0'config globals 'globals'        option ula_prefix 'fddd:9fe7:d160::/48'        option packet_steering '1'config interface 'lan'        option type 'bridge'        option ifname 'eth1'        option proto 'static'        option netmask '255.255.255.0'        option ip6assign '60'        option ipaddr '192.168.10.1'config interface 'wan'        option ifname 'eth0'        option proto 'dhcp'配置zsh更新插件包opkg update安装git(默认的git使用不了git-remote)opkg install git-httpopkg install ca-bundle安装zshopkg install zsh安装oh-my-shsh -c \"$(wget -O- https://raw.githubusercontent.com/felix-fly/openwrt-ohmyzsh/master/install.sh)\"设置为默认which zsh &amp;&amp; sed -i -- 's:/bin/ash:'`which zsh`':g' /etc/passwd安装rsyncopkg install rsync常用docker 安装docker create –name=baidunet -p 5800:5800 -p 5900:5900 -v /cloud/download:/config/baidunetdiskdownload –restart unless-stopped johngong/baidunetdisk:latest"
  },
  
  {
    "title": "Java和Kotlin的范型",
    "url": "/posts/generic/",
    "categories": "Android",
    "tags": "范型",
    "date": "2022-11-28 21:00:00 +0800",
    





    "snippet": "范型Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，为了兼容旧Java版本，所以允许时会被擦除。举例目前有如下几个关系的类范型示例Javaclass ArrayList&lt;E&gt;{    public boolean add(E e) {}}在Kotlin中也是类似的，对于范型，还可以设置上界，例如：Javapublic class PersonList&lt;T extends Person&gt; extends ArrayList&lt;T&gt; { }Kotlinclass PersonList&lt;T : Person&gt; : ArrayList&lt;T&gt;()这样就很好的限制了使用PersonList的范型必须为Person或子类协变和逆变因为即使Student是Person的子类，但是在Java和Kotlin中，PersonList&lt;Person&gt;与PersonList&lt;Student&gt;是并没有关系的，所以也不能相互转换，要解决这个问题，所以引入了协变和逆变两个概念，大致关系如下图协变Java协变代表正常的继承关系，在Java中为&lt;? extends Person&gt;，kotlin中为&lt;in Person&gt;，即PersonList&lt;Student&gt;也可以正常的转化成PersonList&lt;Person&gt;，例如ArrayList&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;();// 子类可以赋值给父类ArrayList&lt;? extends Person&gt; personList = studentList;// 不可以再添加元素// personList.add(new Person());// 可以正常获取到目前这个类型Person person = personList.get(0);因为转化为ArrayList&lt;? extends Person&gt;类型后，若再添加元素，添加的元素并不能保证满足原始ArrayList&lt;Student&gt;类型。使用是危险操作，不被允许。Kotlinkotlin也是支持和Java一样的协变的，在kotlin中操作符为out，但在此基础上，kotlin的out修饰在Class定义时，还会禁止入参使用范型，而只允许出参带范型。例如：class CacheData&lt;out T : Person&gt;(private var data: T) {    fun get(): T = data}fun test(){    val student = CacheData&lt;Student&gt;(Student())    val student1 = student.get()    // 可以赋值给父类    val person: CacheData&lt;Person&gt; = student    // 并且可以获取元素    val person1 = person.get()}在类定义时直接带有out参数后，生成的类直接就可以支持协变。逆变逆变算是反向的继承关系，所以在Java中使用super关键字表示，在Kotlin中用in表示，表示这个子类的引用可以接收父类的实例。例如JavaArrayList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();// 父类list可以转化给子类的listArrayList&lt;? super Student&gt; studentList = personList;// 可以往内部正常的进行添加studentList.add(new Student());// 不再支持获取// Person person = studentList.get(0);和前面的类似，因为ArrayList&lt;Person&gt;赋值给ArrayList&lt;? super Student&gt;后，因为ArrayList&lt;Person&gt;中元素并不能保证是Student，所以当作是Student来获取肯定是会异常，所以获取操作是被禁止的。Kotlin在kotiln中的逆变对应in，也同样可以修饰在类定义上，会直接限制方法的定义，禁止掉返回值为对应范型的方法。例如：// 设置逆变关系class CacheData&lt;in T : Person&gt;() {    private var data: T? = null    fun set(t: T) {        data = t    }}fun test(){    val person = CacheData&lt;Person&gt;()    person.set(Student())    // 可以赋给子类对象    val student : CacheData&lt;Student&gt; = person    // 依然可以正常添加    student.add(Student())}因为父类对象赋值给了子类对象，所以设置参数依然可以保证加入的元素是Person类型的，设置对应in，所以in也代表逆变器。而这里CacheData&lt;Person&gt;时添加的元素并不能保证是满足为Student的，所以是不能进行取操作的。@UnsafeVariance因为对比Java，kotlin的范型限制更加的严格，在有些时候out修饰的class仍需要有范型参数作为输入参数，这是就需要使用@UnsafeVariance来保证能够编译通过，而保证运行时的问题则需要靠自己保证了。例如：class AL&lt;out T : Person&gt;(    private var data: T) {    fun get(): T = data    fun set(t: @UnsafeVariance T) {    }}"
  },
  
  {
    "title": "Activity Result API使用",
    "url": "/posts/result-api/",
    "categories": "Android",
    "tags": "result api",
    "date": "2022-11-28 11:27:00 +0800",
    





    "snippet": "简介  Activity Result API 提供了用于注册结果、启动结果以及在系统分派结果后对其进行处理的组件。是在AndroidX中被引用，并被强烈推荐的组件。使用在activity和fragment中都增加了一个registerForActivityResult方法来注册约定协议以及返回结果@MainThread@NonNull@Overridepublic final &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; registerForActivityResult(        @NonNull final ActivityResultContract&lt;I, O&gt; contract,        @NonNull final ActivityResultCallback&lt;O&gt; callback) {    return prepareCallInternal();}协议class// * @param &lt;I&gt; input type// * @param &lt;O&gt; output typepublic abstract class ActivityResultContract&lt;I, O&gt; {    public abstract @NonNull Intent createIntent(@NonNull Context context, @SuppressLint(\"UnknownNullness\") I input);    @SuppressLint(\"UnknownNullness\")    public abstract O parseResult(int resultCode, @Nullable Intent intent);    }默认协议系统中默认实现了比较多的协议来提供给开发者直接使用大概列了前面的几个在这里，还默认有部分都是在ActivityResultContracts中的，需要再补充"
  },
  
  {
    "title": "AMS分析",
    "url": "/posts/ams/",
    "categories": "Android",
    "tags": "AMS",
    "date": "2022-11-25 19:27:00 +0800",
    





    "snippet": "简介源码使用官方 Android29  ActivityManagerService是Android提供的一个用于管理Activity运行状态的系统进程启动过程启动首先是从SystemService的main方法开始启动的/**    * The main entry point from zygote.    */public static void main(String[] args) {    new SystemServer().run();}从官方注射可以看到，这个是由zygote启动的服务private void run() {    TimingsTraceAndSlog t = new TimingsTraceAndSlog();    try {                // ...        // Prepare the main looper thread (this thread).        android.os.Process.setThreadPriority(                android.os.Process.THREAD_PRIORITY_FOREGROUND);        android.os.Process.setCanSelfBackground(false);        Looper.prepareMainLooper();        Looper.getMainLooper().setSlowLogThresholdMs(                SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS);        SystemServiceRegistry.sEnableServiceNotFoundWtf = true;        // Initialize native services.        System.loadLibrary(\"android_servers\");        // Allow heap / perf profiling.        initZygoteChildHeapProfiling();        //...        // Create the system service manager.        mSystemServiceManager = new SystemServiceManager(mSystemContext);        mSystemServiceManager.setStartInfo(mRuntimeRestart, mRuntimeStartElapsedTime, mRuntimeStartUptime);        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);    } finally {        t.traceEnd();  // InitBeforeStartServices    }    // Setup the default WTF handler    RuntimeInit.setDefaultApplicationWtfHandler(SystemServer::handleEarlySystemWtf);    // Start services.    try {        t.traceBegin(\"StartServices\");        // 启动很多Service        startBootstrapServices(t);        // 启动很多核心的系统服务        startCoreServices(t);        startOtherServices(t);    } catch (Throwable ex) {        Slog.e(\"System\", \"******************************************\");        Slog.e(\"System\", \"************ Failure starting system services\", ex);        throw ex;    } finally {        t.traceEnd(); // StartServices    }    StrictMode.initVmDefaults(null);    if (!mRuntimeRestart &amp;&amp; !isFirstBootOrUpgrade()) {        final long uptimeMillis = SystemClock.elapsedRealtime();        FrameworkStatsLog.write(FrameworkStatsLog.BOOT_TIME_EVENT_ELAPSED_TIME_REPORTED,                FrameworkStatsLog.BOOT_TIME_EVENT_ELAPSED_TIME__EVENT__SYSTEM_SERVER_READY,                uptimeMillis);        final long maxUptimeMillis = 60 * 1000;        if (uptimeMillis &gt; maxUptimeMillis) {            Slog.wtf(SYSTEM_SERVER_TIMING_TAG,                    \"SystemServer init took too long. uptimeMillis=\" + uptimeMillis);        }    }    // Loop forever.    Looper.loop();    throw new RuntimeException(\"Main thread loop unexpectedly exited\");}SystemService启动后也是利用的Handler进行循环处理，期间使用SystemServiceManager启动了很多系统服务，例如Activity栈管理、系统配置、电源管理等。AMS触发Activity生命周期AMS对Activity的生命周期分发主要通过ClientTransaction携带不同的生命周期方法，例如LaunchActivityItem、ResumeActivityItem、PauseActivityItem等来实现的。Acitity栈在AMS上使用ActivityDisplay、ActivityStack、TaskRecord、ActivityRecord等来管理不同进程以及屏幕显示的Activity// TODO 编译调试不同情况下ASM的调用过程"
  },
  
  {
    "title": "LeakCanary使用和解析",
    "url": "/posts/leakcanary/",
    "categories": "Android",
    "tags": "LeakCanary",
    "date": "2022-11-22 19:27:00 +0800",
    





    "snippet": "使用Maven地址debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.10'因为是线下检测，所以依赖模式为debug，其余不用配置也可以直接使用了。源码分析核心原理在Activity、Fragment、View等销毁时，利用弱引用依赖他们，当过5秒之后去进行检测和GC，若还存在未被回收，则表示有泄漏，打印对应的引用信息。初始化internal class MainProcessAppWatcherInstaller : ContentProvider() {    override fun onCreate(): Boolean {        val application = context!!.applicationContext as Application        AppWatcher.manualInstall(application)        return true    }}利用ContentProvider进行初始化，这样的好处是不需要单独手动初始化即可使用，坏处就是若三方库都采用这种方式，会比较影响启动速度。@JvmOverloadsfun manualInstall(    application: Application,    retainedDelayMillis: Long = TimeUnit.SECONDS.toMillis(5),    watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)) {    checkMainThread()    if (isInstalled) {        throw IllegalStateException(            \"AppWatcher already installed, see exception cause for prior install call\", installCause        )    }    check(retainedDelayMillis &gt;= 0) {        \"retainedDelayMillis $retainedDelayMillis must be at least 0 ms\"    }    this.retainedDelayMillis = retainedDelayMillis    if (application.isDebuggableBuild) {        LogcatSharkLog.install()    }    // Requires AppWatcher.objectWatcher to be set    LeakCanaryDelegate.loadLeakCanary(application)    watchersToInstall.forEach {        // 进行初始化        it.install()    }    // Only install after we're fully done with init.    installCause = RuntimeException(\"manualInstall() first called here\")}fun appDefaultWatchers(    application: Application,    reachabilityWatcher: ReachabilityWatcher = objectWatcher): List&lt;InstallableWatcher&gt; {    // 默认能够检测的泄漏类型    return listOf(        ActivityWatcher(application, reachabilityWatcher),        FragmentAndViewModelWatcher(application, reachabilityWatcher),        RootViewWatcher(reachabilityWatcher),        ServiceWatcher(reachabilityWatcher)    )}默认会传入对Activity、Fragment、RootView、Service这四种类型的内存泄漏检测。Activity的installclass ActivityWatcher(  private val application: Application,  private val reachabilityWatcher: ReachabilityWatcher) : InstallableWatcher {    private val lifecycleCallbacks =        object : Application.ActivityLifecycleCallbacks by noOpDelegate() {            override fun onActivityDestroyed(activity: Activity) {                reachabilityWatcher.expectWeaklyReachable(                    activity, \"${activity::class.java.name} received Activity#onDestroy() callback\"                )            }        }    override fun install() {        application.registerActivityLifecycleCallbacks(lifecycleCallbacks)    }    override fun uninstall() {        application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)    }}利用ActivityLifecycleCallbacks在Activity即将销毁的时候去进行监听。当Activity销毁的时候，会调用reachabilityWatcher的expectWeaklyReachable方法传入activityval objectWatcher = ObjectWatcher(    clock = { SystemClock.uptimeMillis() },    checkRetainedExecutor = {        check(isInstalled) {            \"AppWatcher not installed\"        }        // 利用handler发送到主线程进行延时，默认延时5秒        mainHandler.postDelayed(it, retainedDelayMillis)    },    isEnabled = { true })private val queue = ReferenceQueue&lt;Any&gt;()@Synchronized override fun expectWeaklyReachable(    watchedObject: Any,    description: String) {    if (!isEnabled()) {        return    }    removeWeaklyReachableObjects()    val key = UUID.randomUUID().toString()    val watchUptimeMillis = clock.uptimeMillis()    // 用弱引用引用着传入的对象    val reference = KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)    SharkLog.d {        \"Watching \" +        (if (watchedObject is Class&lt;*&gt;) watchedObject.toString() else \"instance of ${watchedObject.javaClass.name}\") +        (if (description.isNotEmpty()) \" ($description)\" else \"\") +        \" with key $key\"    }    // 把生成的对象进行缓存起来    watchedObjects[key] = reference    checkRetainedExecutor.execute {        moveToRetained(key)    }}private fun removeWeaklyReachableObjects() {    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly    // reachable. This is before finalization or garbage collection has actually happened.    var ref: KeyedWeakReference?    do {        ref = queue.poll() as KeyedWeakReference?        if (ref != null) {            watchedObjects.remove(ref.key)        }    } while (ref != null)}会对传入的对象生成一个随机key，然后把对象添加到弱引用当中去，然后传入弱引用队列，当对象被回收后，对象会被添加到队列中。所以第一个removeWeaklyReachableObjects方法则是取出队列中的元素，然后把watchedObjects中的对象移除掉。最后再把任务添加到executor中去。@Synchronized private fun moveToRetained(key: String) {    removeWeaklyReachableObjects()    val retainedRef = watchedObjects[key]    if (retainedRef != null) {        retainedRef.retainedUptimeMillis = clock.uptimeMillis()        onObjectRetainedListeners.forEach { it.onObjectRetained() }    }}在延时过后会再去检测是否有可能泄漏的对象，若还存在，则调用观察者的onObjectRetained方法override fun onObjectRetained() = scheduleRetainedObjectCheck()fun scheduleRetainedObjectCheck() {    if (this::heapDumpTrigger.isInitialized) {        heapDumpTrigger.scheduleRetainedObjectCheck()    }}fun scheduleRetainedObjectCheck(    delayMillis: Long = 0L) {    val checkCurrentlyScheduledAt = checkScheduledAt    if (checkCurrentlyScheduledAt &gt; 0) {        return    }    checkScheduledAt = SystemClock.uptimeMillis() + delayMillis    backgroundHandler.postDelayed({        checkScheduledAt = 0        checkRetainedObjects()    }, delayMillis)}然后会再两秒延时抛送到子线程中去private fun checkRetainedObjects() {    val iCanHasHeap = HeapDumpControl.iCanHasHeap()    val config = configProvider()    if (iCanHasHeap is Nope) {        if (iCanHasHeap is NotifyingNope) {            // Before notifying that we can't dump heap, let's check if we still have retained object.            var retainedReferenceCount = objectWatcher.retainedObjectCount            if (retainedReferenceCount &gt; 0) {                // 先gc再检测数量                gcTrigger.runGc()                retainedReferenceCount = objectWatcher.retainedObjectCount            }            val nopeReason = iCanHasHeap.reason()            // 判断是否达到需要dump的标准，满足达到5个，如果没有持续循环2s的检查            val wouldDump = !checkRetainedCount(                retainedReferenceCount, config.retainedVisibleThreshold, nopeReason            )            if (wouldDump) {                // 达到标准则直接dump                val uppercaseReason = nopeReason[0].toUpperCase() + nopeReason.substring(1)                onRetainInstanceListener.onEvent(DumpingDisabled(uppercaseReason))                showRetainedCountNotification(                    objectCount = retainedReferenceCount,                    contentText = uppercaseReason                )            }        } else {            SharkLog.d {                application.getString(                    R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()                )            }        }        return    }    var retainedReferenceCount = objectWatcher.retainedObjectCount    if (retainedReferenceCount &gt; 0) {        gcTrigger.runGc()        retainedReferenceCount = objectWatcher.retainedObjectCount    }    if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return    val now = SystemClock.uptimeMillis()    val elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis    if (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) {        onRetainInstanceListener.onEvent(DumpHappenedRecently)        showRetainedCountNotification(            objectCount = retainedReferenceCount,            contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)        )        scheduleRetainedObjectCheck(            delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis        )        return    }    dismissRetainedCountNotification()    val visibility = if (applicationVisible) \"visible\" else \"not visible\"    dumpHeap(        retainedReferenceCount = retainedReferenceCount,        retry = true,        reason = \"$retainedReferenceCount retained objects, app is $visibility\"    )}最后的检测泄漏个数，若还存在，先gc再次检测，若泄漏个数达到5个则直接dump堆栈，若没有则持续2s的循环检测。总结LeakCanary利用弱引用的性质，在Activity销毁的时候，把Activity包装成为一个弱引用对象保存到map中，如何发送一个5秒的延迟去检测弱引用队列中是否有刚回收的对象，根据队列的元素key清除之前保存在map中的元素，若map中依然有元素，则表示可能存在内存泄漏。然后发送子线程延迟两秒的事件，去进行gc和检测，若最后map中元素依然不为0，则表示有真实的泄漏。当元素个数小于5时会循环检测。若元素个数大于等于5则dump出对应的堆栈。"
  },
  
  {
    "title": "EventBus使用和解析",
    "url": "/posts/eventbus/",
    "categories": "Android",
    "tags": "Bus",
    "date": "2022-11-21 23:55:00 +0800",
    





    "snippet": "使用依赖Maven地址implementation 'org.greenrobot:eventbus:3.3.1'使用绑定事件@Subscribe(threadMode = ThreadMode.MAIN, sticky = false, priority = 1)fun notice() {}注册对象override fun onCreate(savedInstanceState: Bundle?, persistentState: PersistableBundle?) {    super.onCreate(savedInstanceState, persistentState)    EventBus.getDefault().register(this)}解注册override fun onResume() {    super.onResume()    EventBus.getDefault().unregister(this)}发送事件EventBus.getDefault().post(Event())发送粘性事件EventBus.getDefault().postSticky(Event())源码解析getDefault获取单例public static EventBus getDefault() {    EventBus instance = defaultInstance;    if (instance == null) {        synchronized (EventBus.class) {            instance = EventBus.defaultInstance;            if (instance == null) {                instance = EventBus.defaultInstance = new EventBus();            }        }    }    return instance;}使用双重检测，延迟初始化registerpublic void register(Object subscriber) {    // ...    // 获取传入对象的class类型    Class&lt;?&gt; subscriberClass = subscriber.getClass();    // 遍历查找含有注解的所有方法    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);    synchronized (this) {        for (SubscriberMethod subscriberMethod : subscriberMethods) {            subscribe(subscriber, subscriberMethod);        }    }}先拿到传入对象的class类型，然后根据class类型使用SubscriberMethodFinder去查找解析含有注解的方法以及注解的属性。这里传入参数为对象是因为后续反射调用时需要用到对象。// Class to List&lt;SubscriberMethod&gt; 方法集合的缓存Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = new ConcurrentHashMap&lt;&gt;()；List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) {    // 看是否有缓存    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);    if (subscriberMethods != null) {        return subscriberMethods;    }    if (ignoreGeneratedIndex) {        // 使用反射查找        subscriberMethods = findUsingReflection(subscriberClass);    } else {        subscriberMethods = findUsingInfo(subscriberClass);    }    if (subscriberMethods.isEmpty()) {        throw new EventBusException(\"Subscriber \" + subscriberClass                + \" and its super classes have no public methods with the @Subscribe annotation\");    } else {        // 缓存起来        METHOD_CACHE.put(subscriberClass, subscriberMethods);        return subscriberMethods;    }}private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) {    // 从缓存中获取，使用findState来查找    FindState findState = prepareFindState();    // 初始化findState    findState.initForSubscriber(subscriberClass);    while (findState.clazz != null) {        findUsingReflectionInSingleClass(findState);        findState.moveToSuperclass();    }    // 获取收集到的方法并缓存FindState对象    return getMethodsAndRelease(findState);}// 查找需要的方法private void findUsingReflectionInSingleClass(FindState findState) {    Method[] methods;    try {        // 通过这个方法，手动遍历所有parent        // This is faster than getMethods, especially when subscribers are fat classes like Activities        methods = findState.clazz.getDeclaredMethods();    } catch (Throwable th) {        // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149        try {            methods = findState.clazz.getMethods();        } catch (LinkageError error) { // super class of NoClassDefFoundError to be a bit more broad...            // ...            throw new EventBusException(msg, error);        }        // getMethods方法默认会返回所有public方法，所以直接跳过父查找        findState.skipSuperClasses = true;    }    for (Method method : methods) {        int modifiers = method.getModifiers();        if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) {            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();            // 只有一个入参            if (parameterTypes.length == 1) {                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);                // 含有注解                if (subscribeAnnotation != null) {                    Class&lt;?&gt; eventType = parameterTypes[0];                    if (findState.checkAdd(method, eventType)) {                        ThreadMode threadMode = subscribeAnnotation.threadMode();                        findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));                    }                }            }            // ...        }        // ...    }}SubscriberMethodFinder中对查找过的class类型进行了缓存，如果没有命中缓存，则开始构建FindState，反射查找对应的方法。默认是手动逐层去查找所有的方法，遍历出public的且含有注解且入参只有一个的方法。获取对应的方法以及注解属性放入到FindState中。再回到后面的subscribe方法中// 事件EventClass关联对应接收者的集合，发送事件时使用private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;// 注册对象关联可以接收的EventClass集合private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;// EventClass关联EventObjprivate final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {    Class&lt;?&gt; eventType = subscriberMethod.eventType;    // 把对象和对象中的观察者方法关联起来，方便直接反射调用    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);    // 从缓存中取，EventClass关联接收方法和对象    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);    if (subscriptions == null) {        subscriptions = new CopyOnWriteArrayList&lt;&gt;();        subscriptionsByEventType.put(eventType, subscriptions);    } else {        // 不能重复注册，检查是否注册过了        if (subscriptions.contains(newSubscription)) {            throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \"                    + eventType);        }    }    int size = subscriptions.size();    for (int i = 0; i &lt;= size; i++) {        // 根据优先级添加        if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {            subscriptions.add(i, newSubscription);            break;        }    }    // 注册对象关联的所有事件    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);    if (subscribedEvents == null) {        subscribedEvents = new ArrayList&lt;&gt;();        typesBySubscriber.put(subscriber, subscribedEvents);    }    subscribedEvents.add(eventType);    // 如果是粘性事件。检查是否有缓存的事件    if (subscriberMethod.sticky) {        if (eventInheritance) {            // Existing sticky events of all subclasses of eventType have to be considered.            // Note: Iterating over all events may be inefficient with lots of sticky events,            // thus data structure should be changed to allow a more efficient lookup            // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {                Class&lt;?&gt; candidateEventType = entry.getKey();                if (eventType.isAssignableFrom(candidateEventType)) {                    Object stickyEvent = entry.getValue();                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);                }            }        } else {            // 根据EventClass去获取EventObj            Object stickyEvent = stickyEvents.get(eventType);            checkPostStickyEventToSubscription(newSubscription, stickyEvent);        }    }}private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {    // 如果对象不为空，则去触发对应的方法    if (stickyEvent != null) {        // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)        // --&gt; Strange corner case, which we don't take care of here.        postToSubscription(newSubscription, stickyEvent, isMainThread());    }}这里会把注册的对象和对应的方法封装成Subscription对象，然后添加到Key为事件Class类型的缓存中，value为Subscription的列表，添加到列表中的时候会根据优先级排序。然后也会把注册对象和可以接收的事件集合缓存到另外的map中。如果方法是粘性方法，会去粘性事件的缓存中去查找对应的事件对象，若存在着直接发送事件。post发送事件private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() {    @Override    protected PostingThreadState initialValue() {        return new PostingThreadState();    }};public void post(Object event) {    // 获取当前线程的postState对象    PostingThreadState postingState = currentPostingThreadState.get();    // 把事件添加到队列中    List&lt;Object&gt; eventQueue = postingState.eventQueue;    eventQueue.add(event);    if (!postingState.isPosting) {        postingState.isMainThread = isMainThread();        postingState.isPosting = true;        if (postingState.canceled) {            throw new EventBusException(\"Internal error. Abort state was not reset\");        }        try {            // 持续发送事件            while (!eventQueue.isEmpty()) {                postSingleEvent(eventQueue.remove(0), postingState);            }        } finally {            postingState.isPosting = false;            postingState.isMainThread = false;        }    }}发送事件时，会把对象添加到当前线程的postingState对象的事件队列中。然后持续去发送事件。private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {    Class&lt;?&gt; eventClass = event.getClass();    boolean subscriptionFound = false;    if (eventInheritance) {        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);        int countTypes = eventTypes.size();        for (int h = 0; h &lt; countTypes; h++) {            Class&lt;?&gt; clazz = eventTypes.get(h);            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);        }    } else {        // 直接发送事件        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);    }    if (!subscriptionFound) {        if (logNoSubscriberMessages) {            logger.log(Level.FINE, \"No subscribers registered for event \" + eventClass);        }        if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;                eventClass != SubscriberExceptionEvent.class) {            post(new NoSubscriberEvent(this, event));        }    }}private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) {    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;    synchronized (this) {        // 获取可以接收此事件的集合        subscriptions = subscriptionsByEventType.get(eventClass);    }    if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) {        for (Subscription subscription : subscriptions) {            postingState.event = event;            postingState.subscription = subscription;            boolean aborted;            try {                // 开始去发送事件                postToSubscription(subscription, event, postingState.isMainThread);                aborted = postingState.canceled;            } finally {                postingState.event = null;                postingState.subscription = null;                postingState.canceled = false;            }            if (aborted) {                break;            }        }        return true;    }    return false;}private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {    switch (subscription.subscriberMethod.threadMode) {        case POSTING:        // 不切换线程，直接调用            invokeSubscriber(subscription, event);            break;        case MAIN:            if (isMainThread) {                invokeSubscriber(subscription, event);            } else {                // 添加到主线程的执行队列中                mainThreadPoster.enqueue(subscription, event);            }            break;        case MAIN_ORDERED:            if (mainThreadPoster != null) {                mainThreadPoster.enqueue(subscription, event);            } else {                // temporary: technically not correct as poster not decoupled from subscriber                invokeSubscriber(subscription, event);            }            break;        case BACKGROUND:            if (isMainThread) {                // 添加到子线程队列                backgroundPoster.enqueue(subscription, event);            } else {                invokeSubscriber(subscription, event);            }            break;        case ASYNC:            asyncPoster.enqueue(subscription, event);            break;        default:            throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode);    }}真正发送时会先去根据事件的Class类型去查询可以接收的Subscription对象，然后去循环遍历去逐个判断通知，主要是判断是否需要线程切换。如果当前线程不满足，就会被添加到对应线程的poster队列中，然后发送handler事件一并执行。void invokeSubscriber(Subscription subscription, Object event) {    try {        // 直接反射调用        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);    } catch (InvocationTargetException e) {        handleSubscriberException(subscription, event, e.getCause());    } catch (IllegalAccessException e) {        throw new IllegalStateException(\"Unexpected exception\", e);    }}最后通知就是直接反射调用对应的方法postSticky发送粘性事件public void postSticky(Object event) {    // 如果是粘性事件，就缓存起来    synchronized (stickyEvents) {        stickyEvents.put(event.getClass(), event);    }    // Should be posted after it is putted, in case the subscriber wants to remove immediately    post(event);}粘性事件与普通事件的区别就是粘性事件会被缓存起来，然后就直接调用post发送事件。unregisterpublic synchronized void unregister(Object subscriber) {    // 根据对象获取他所有的EventClass    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);    if (subscribedTypes != null) {        for (Class&lt;?&gt; eventType : subscribedTypes) {            unsubscribeByEventType(subscriber, eventType);        }        typesBySubscriber.remove(subscriber);    } else {        logger.log(Level.WARNING, \"Subscriber to unregister was not registered before: \" + subscriber.getClass());    }}private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) {    // 根据EventClass获取可以接收的对象    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);    if (subscriptions != null) {        int size = subscriptions.size();        for (int i = 0; i &lt; size; i++) {            Subscription subscription = subscriptions.get(i);            // 移除同一个对象，避免内存泄漏            if (subscription.subscriber == subscriber) {                subscription.active = false;                subscriptions.remove(i);                i--;                size--;            }        }    }}解注册时先根据传入的对象类型，查找缓存的EventClass集合，然后根据EventClass查询所有Subscription，依次循环移除掉与当前相等的Subscription对象。总结  EventBus单例创建使用了双重检测的方式  注册监听时EventBus会使用subscriberMethodFinder来查找出注册对象的所有监听方法，subscriberMethodFinder存有Class类型对应方法的集合缓存，然后对注册对象以及解锁出来的所有方法包装成Subscription对象，储存在EventBus中的EventClass对Subscription集合中，添加时会判断优先级插入到对应的位置，方便之后的事件发送时查找关联事件发送。另外还会缓存一份注册对象对应他可以接收事件的集合在另外的一个map。最后如果是注册的粘性事件，会去粘性集合中查找是否有对应的事件，如果有直接触发。  当发送事件时，会根据发送的事件Class查找到可以接收事件的Subscription对象列表，根据设置的线程要求，直接触发或发送到对应的线程的poster队列中去，最后通过反射调用执行。如果是粘性事件，则会单独缓存到一个EventClass to EventObject的集合中。  当解注册时，直接通过注册对象去查找可以接收的事件类型，然后查找可以接收对应事件的Subscription对象集合，然后移除含有与注册对象相同对象的Subscription对象。"
  },
  
  {
    "title": "ARouter使用和解析",
    "url": "/posts/arouter/",
    "categories": "Android",
    "tags": "Route",
    "date": "2022-11-21 15:16:00 +0800",
    





    "snippet": "依赖模块gradle中增加plugins {    id 'kotlin-kapt'}android {    defaultConfig {        kapt {            // 模块名            arguments {                arg(\"AROUTER_MODULE_NAME\": project.getName())            }        }    }}dependencies {    implementation 'com.alibaba:arouter-api:1.5.2'    kapt 'com.alibaba:arouter-compiler:1.5.2'}参考  探索 ARouter 原理"
  },
  
  {
    "title": "Java注解介绍",
    "url": "/posts/annotation/",
    "categories": "Java",
    "tags": "annotation",
    "date": "2022-11-19 18:41:00 +0800",
    





    "snippet": "元注解1、@Documented:用于标记在生成javadoc时是否将注解包含进去，可以看到这个注解和@Override一样，注解中空空如也，什么东西都没有。2、@Target用于定义注解可以在什么地方使用，默认可以在任何地方使用，也可以指定使用的范围，开发中将注解用。            字段      作用                  ElementType.TYPE      类、接口或enum声明              ElementType.FIELD      域(属性)声明              ElementType.METHOD      方法声明              ElementType.PARAMETER      参数声明              ElementType.CONSTRUCTOR      构造方法声明              ElementType.LOCAL_VARIABLE      局部变量声明              ElementType.ANNOTATION_TYPE      注释类型声明              ElementType.PACKAGE      包声明      3、@Inherited允许子类继承父类中的注解，可以通过反射获取到父类的注解4、@Constraint用于校验属性值是否合法5、@Retention注解的声明周期，用于定义注解的存活阶段，可以存活在源码级别、编译级别(字节码级别)、运行时级别。            类型      作用                  RetentionPolicy.SOURCE      源码级别，注解只存在源码中，一般用于和编辑器交互，用于检测代码。如@Override, @SuppressWarings。              RetentionPolicy.CLASS      编译时注解，字节码级别，注解存在于源码和字节码文件中，主要用于编译时生成额外的文件，如XML，Java文件等，但运行时无法获得。 默认注解              RetentionPolicy.RUNTIME      运行时注解，注解存在于源码、字节码、java虚拟机中，主要用于运行时，可以使用反射获取相关的信息。      "
  },
  
  {
    "title": "Retrofit使用和解析",
    "url": "/posts/retrofit/",
    "categories": "Android",
    "tags": "Retrofit",
    "date": "2022-11-18 19:56:00 +0800",
    





    "snippet": "使用众所周知，Retrofit只是对OkHttp的一层封装，目的是为了让OkHttp使用起来更便捷。主要就是对Request对象的构建进行了一层封装，使我们只需要定义好借口的形式就OK，使用起来更偏向方法的直接调用（结合协程）。然后是对Call进行了包装对返回结果进行了处理，加入了解析器，可以直接返回我们所需要的对象。依赖implementation(\"com.squareup.retrofit2:converter-gson:2.9.0\")implementation(\"com.squareup.retrofit2:retrofit:2.9.0\")这里引入的Retrofit中自动包括了OkHttp，所以不需要我们再单独引入了。另外引入了一个gson的json解析器，是常用来解析json的。创建Retrofit对象val retrofit = Retrofit.Builder()    .baseUrl(\"https://coding.jiangker.cn\")    .client(OkHttpClient())    .addConverterFactory(GsonConverterFactory.create())    .build()Retrofit和之前的OkHttp类似的，都是用来做统一管理的，这里也可以自己定义OkHttpClient，不过一般都是保持默认，默认也是使用的OkHttpClient所以可以省略。构建请求接口interface RetrofitService {    @GET(\"demo\")    fun getUser(        @Query(\"name\") name: String,        @Query(\"age\") age: Int    ): retrofit2.Call&lt;User&gt;    @GET(\"demo\")    suspend fun syncGetUser(        @Query(\"name\") name: String,        @Query(\"age\") age: Int    ): User}val service = retrofit.create(RetrofitService::class.java)@Query注解可以相当于往后拼接params参数。常有的还有@Path、@Header、@Body等。对于常规方式是直接返回retrofit2.Call这个对象，较Okhttp的Call对象有更多的能力，但实际发起请求还是依赖OkHttp的call。对于使用kotlin协程的来说，可以直接添加suspend然后直接返回需要的结果。然后直接使用Retrofit来创建相关接口的服务器对象。发起请求call请求userCall.execute()userCall.enqueue(object :retrofit2.Callback&lt;User&gt;{    override fun onResponse(        call: retrofit2.Call&lt;User&gt;,        response: retrofit2.Response&lt;User&gt;    ) {        // 默认主线程返回    }    override fun onFailure(call: retrofit2.Call&lt;User&gt;, t: Throwable) {        // 默认主线程返回    }})可以看出基本上用法和OkHttp一致，这里的切换回主线程经过了一次调度器。可以使用@SkipCallbackExecutor注解去跳过协程请求val user: User = withContext(Dispatchers.IO) {    service.syncGetUser(\"jiangker\", 18)}协程请求看着形式上会比普通的call请求更简单，这里请求实际是使用的execute()发起的，所以需要手动去切换子线程。这里对错误结果也没有进行处理的，一般需要进行catch处理。原理Retrofitpublic final class Retrofit {    // 接口方法缓存    private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();    final okhttp3.Call.Factory callFactory;    final HttpUrl baseUrl;    final List&lt;Converter.Factory&gt; converterFactories;    final List&lt;CallAdapter.Factory&gt; callAdapterFactories;    final @Nullable Executor callbackExecutor;    final boolean validateEagerly;    public &lt;T&gt; T create(final Class&lt;T&gt; service) {    // 先验证    validateServiceInterface(service);    // 动态代理    return (T)        Proxy.newProxyInstance(            service.getClassLoader(),            new Class&lt;?&gt;[] {service},            new InvocationHandler() {              private final Platform platform = Platform.get();              private final Object[] emptyArgs = new Object[0];              @Override              public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)                  throws Throwable {                // If the method is a method from Object then defer to normal invocation.                if (method.getDeclaringClass() == Object.class) {                  return method.invoke(this, args);                }                args = args != null ? args : emptyArgs;                return platform.isDefaultMethod(method)                    ? platform.invokeDefaultMethod(method, service, proxy, args)                    : loadServiceMethod(method).invoke(args);              }            });    }    // 检验传入接口的有效性    private void validateServiceInterface(Class&lt;?&gt; service) {        if (!service.isInterface()) {            throw new IllegalArgumentException(\"API declarations must be interfaces.\");        }        Deque&lt;Class&lt;?&gt;&gt; check = new ArrayDeque&lt;&gt;(1);        check.add(service);        while (!check.isEmpty()) {            Class&lt;?&gt; candidate = check.removeFirst();            if (candidate.getTypeParameters().length != 0) {                StringBuilder message =                    new StringBuilder(\"Type parameters are unsupported on \").append(candidate.getName());                if (candidate != service) {                    message.append(\" which is an interface of \").append(service.getName());                }                throw new IllegalArgumentException(message.toString());            }            Collections.addAll(check, candidate.getInterfaces());        }        // 是否直接解析所有接口，默认是false的        if (validateEagerly) {            Platform platform = Platform.get();            for (Method method : service.getDeclaredMethods()) {                if (!platform.isDefaultMethod(method) &amp;&amp; !Modifier.isStatic(method.getModifiers())) {                loadServiceMethod(method);                }            }        }    }    // 方法解析    ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {        // 查找是否已经解析过了        ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);        if (result != null) return result;        synchronized (serviceMethodCache) {            result = serviceMethodCache.get(method);            if (result == null) {                result = ServiceMethod.parseAnnotations(this, method);                serviceMethodCache.put(method, result);            }        }        return result;    }}Retrofit中有比较多的基础配置，create方法对传入的方法进行动态代理，返回一个接口的代理对象，对方法的解析可以设置为饿汉的形式直接解析全部，也可以是用到一个解析一个。解析是用到了ServiceMethod去进行具体的解析，解析的结果也会缓存到Retrofit的map中。//serviceMethodCache.javastatic &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) {    // 对注解和参数进行解析    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);    Type returnType = method.getGenericReturnType();    if (Utils.hasUnresolvableType(returnType)) {        throw methodError(            method,            \"Method return type must not include a type variable or wildcard: %s\",            returnType);    }    if (returnType == void.class) {        throw methodError(method, \"Service methods cannot return void.\");    }    // 生成请求CallAdapter等    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);}RequestFactory中保存着解析后的所有结果，在build方法中进行真正的解析。final class RequestFactory {    static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {        return new Builder(retrofit, method).build();    }    private final Method method;    private final HttpUrl baseUrl;    final String httpMethod;    private final @Nullable String relativeUrl;    private final @Nullable Headers headers;    private final @Nullable MediaType contentType;    private final boolean hasBody;    private final boolean isFormEncoded;    private final boolean isMultipart;    private final ParameterHandler&lt;?&gt;[] parameterHandlers;    // 是否是协程    final boolean isKotlinSuspendFunction;}可以看出RequestFactory中有一个参数表示是否是协程请求，这个参数是在build过程中确定的，是根据最后一个参数是否为Continuation确定的。再回头看看解析过程HttpServiceMethod.parseAnnotations的内容    static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(        Retrofit retrofit, Method method, RequestFactory requestFactory) {        boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;        boolean continuationWantsResponse = false;        boolean continuationBodyNullable = false;        Annotation[] annotations = method.getAnnotations();        Type adapterType;        if (isKotlinSuspendFunction) {            // 这里会包装成为type为Call            adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);            // 因为协程不需要切换线程，所以确保有跳过注解            annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);        } else {            adapterType = method.getGenericReturnType();        }        // 创建Retrofit的通用CallAdapter，由CallAdapter.Factory创建，返回的是由DefaultCallAdapterFactory创建的匿名内部类        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method, adapterType, annotations);        Type responseType = callAdapter.responseType();        // ...        // 创建解析器        Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType);        okhttp3.Call.Factory callFactory = retrofit.callFactory;        if (!isKotlinSuspendFunction) {            return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);        } else if (continuationWantsResponse) {        //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.        return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)            // 区别是是否需要Response来包裹            new SuspendForResponse&lt;&gt;(                requestFactory,                callFactory,                responseConverter,                (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);        } else {        //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.        return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)            new SuspendForBody&lt;&gt;(                requestFactory,                callFactory,                responseConverter,                (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,                continuationBodyNullable);        }    }主要是创建CallAdapter，这里会根据是是否是协程生成普通的HttpServiceMethod还是SuspendForBody这个HttpServiceMethod。关系如下：请求部分首先线看一下Call的实现类有哪些这里有两个类都实现了Retrofit的Call接口，ExecutorCallbackCall主要是一个代理类，为需要返回结果线程调度的类提供一个线程调度。而OkHttpCall才是真正对OkHttp的Call的封装，里面实现了真正的Call的创建和请求等。然后再看一下创建方法时候的动态代理。public &lt;T&gt; T create(final Class&lt;T&gt; service) {    validateServiceInterface(service);    return (T)        Proxy.newProxyInstance(            service.getClassLoader(),            new Class&lt;?&gt;[] {service},            new InvocationHandler() {                // ...                return platform.isDefaultMethod(method)                    ? platform.invokeDefaultMethod(method, service, proxy, args)                    : loadServiceMethod(method).invoke(args);                }            });}在方法解析完成后直接调用了其的invoke方法@Overridefinal @Nullable ReturnT invoke(Object[] args) {    Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);    return adapt(call, args);}invoke方法创建了真正的OkHttpCall最后再调用了adapt方法，这里因为HttpServiceMethod的具体实现类不同，所以后面再看普通请求接着一般请求的adapt方法@Overrideprotected ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args) {    return callAdapter.adapt(call);}这个callAdapter由Retrofit创建，实际是由DefaultCallAdapterFactory返回的一个匿名内部类final class DefaultCallAdapterFactory extends CallAdapter.Factory {    private final @Nullable Executor callbackExecutor;    DefaultCallAdapterFactory(@Nullable Executor callbackExecutor) {        this.callbackExecutor = callbackExecutor;    }    @Override    public @Nullable CallAdapter&lt;?, ?&gt; get(        Type returnType, Annotation[] annotations, Retrofit retrofit) {        // 对call的代理，主要是返回结果切换线程        if (getRawType(returnType) != Call.class) {            return null;        }                final Executor executor =            Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)                ? null                : callbackExecutor;        return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() {            @Override            public Type responseType() {                return responseType;            }            @Override            public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) {                return executor == null ? call : new ExecutorCallbackCall&lt;&gt;(executor, call);            }        };    }    static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; {        final Executor callbackExecutor;        final Call&lt;T&gt; delegate;        ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) {        this.callbackExecutor = callbackExecutor;        this.delegate = delegate;        }        @Override        public void enqueue(final Callback&lt;T&gt; callback) {        Objects.requireNonNull(callback, \"callback == null\");        delegate.enqueue(            new Callback&lt;T&gt;() {                @Override                public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) {                    callbackExecutor.execute(                        () -&gt; {                            // 切换回主线程                            if (delegate.isCanceled()) {                                callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\"));                            } else {                                callback.onResponse(ExecutorCallbackCall.this, response);                            }                        });                }                @Override                public void onFailure(Call&lt;T&gt; call, final Throwable t) {                    callbackExecutor.execute(() -&gt; callback.onFailure(ExecutorCallbackCall.this, t));                }            });        }        @Override        public Response&lt;T&gt; execute() throws IOException {            return delegate.execute();        }           }}这里的代码比较简单，DefaultCallAdapterFactory内部传入了callbackExecutor来对结果切换线程，在安卓中是主线程的调度器。adapt方法在调用时会根据是否需要切换线程，然后默认的call对象还是有线程调度的call代理。static final class MainThreadExecutor implements Executor {    private final Handler handler = new Handler(Looper.getMainLooper());    @Override    public void execute(Runnable r) {        handler.post(r);    }}使用handler来制作的调度器。execute@Overridepublic Response&lt;T&gt; execute() throws IOException {    okhttp3.Call call;    synchronized (this) {        if (executed) throw new IllegalStateException(\"Already executed.\");        executed = true;        // 这里会创建一个真正的call请求对象        call = getRawCall();    }    if (canceled) {        call.cancel();    }    // 触发请求并解析结果    return parseResponse(call.execute());}因为阻塞请求是不需要调度的，所有跳过那款代码，直接看最后的部分。流程比较简单，就是创建一个OkHttp的call对象，然后执行请求，最后解析结果。enqueuepublic void enqueue(final Callback&lt;T&gt; callback) {    Objects.requireNonNull(callback, \"callback == null\");    okhttp3.Call call;    Throwable failure;    synchronized (this) {      if (executed) throw new IllegalStateException(\"Already executed.\");      executed = true;      call = rawCall;      failure = creationFailure;      if (call == null &amp;&amp; failure == null) {        try {            call = rawCall = createRawCall();        } catch (Throwable t) {            throwIfFatal(t);            failure = creationFailure = t;        }      }    }    if (failure != null) {        callback.onFailure(this, failure);        return;    }    if (canceled) {        call.cancel();    }    call.enqueue(        new okhttp3.Callback() {            @Override            public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {                Response&lt;T&gt; response;                try {                    response = parseResponse(rawResponse);                } catch (Throwable e) {                    throwIfFatal(e);                    callFailure(e);                    return;                }                try {                    callback.onResponse(OkHttpCall.this, response);                } catch (Throwable t) {                    throwIfFatal(t);                    t.printStackTrace(); // TODO this is not great                }            }            @Override            public void onFailure(okhttp3.Call call, IOException e) {                callFailure(e);            }            private void callFailure(Throwable e) {                try {                    callback.onFailure(OkHttpCall.this, e);                } catch (Throwable t) {                    throwIfFatal(t);                    t.printStackTrace(); // TODO this is not great                }            }        });}和同步请求类似，都是创建OkHttp的Call对象，利用OkHttp来发起真正的请求。协程请求协程请求不同与普通的请求，因为方法调用时结果就返回了，而不是通过Call去调用的。所以实际的请求是在解析后直接执行的，那么奥秘就是在adapt方法中。    @Override    protected Object adapt(Call&lt;ResponseT&gt; call, Object[] args) {      call = callAdapter.adapt(call);      Continuation&lt;ResponseT&gt; continuation = (Continuation&lt;ResponseT&gt;) args[args.length - 1];      try {        return isNullable            ? KotlinExtensions.awaitNullable(call, continuation)            : KotlinExtensions.await(call, continuation);      } catch (Exception e) {        return KotlinExtensions.suspendAndThrow(e, continuation);      }    }可以看出一样是使用callAdapter来构建出真实的请求类，实际返回的也是他本身，然后使用协程启动suspend fun &lt;T : Any&gt; Call&lt;T&gt;.await(): T {  return suspendCancellableCoroutine { continuation -&gt;    continuation.invokeOnCancellation {      cancel()    }    // 调用call的enqueue方法启动    enqueue(object : Callback&lt;T&gt; {        override fun onResponse(call: Call&lt;T&gt;, response: Response&lt;T&gt;) {            if (response.isSuccessful) {                val body = response.body()                if (body == null) {                    val invocation = call.request().tag(Invocation::class.java)!!                    val method = invocation.method()                    val e = KotlinNullPointerException(\"Response from \" +                        method.declaringClass.name +                        '.' +                        method.name +                        \" was null but response body type was declared as non-null\")                    continuation.resumeWithException(e)                } else {                    continuation.resume(body)                }            } else {                continuation.resumeWithException(HttpException(response))            }        }        override fun onFailure(call: Call&lt;T&gt;, t: Throwable) {            continuation.resumeWithException(t)        }    })  }}这里和正常的协程调用的是一个enqueue，只是这里并不包含切换线程的代理。总结：  Retrofit在create方法时，会为接口生成一个动态代理，在方法调用时开始解析方法。  解析过程会根据参数是否有Continution区分是否是协程请求，过程会得到一个由DefaultCallAdapter创建的CallAdapter对象，然后构建到解析好的方法中。CallAdapter主要用作适配是否需要线程调度。默认调度器是使用Handler实现的。  创建的方法返回后，会触发invoke方法，方法中都会创建一个OkHttpCall对象，这个对象是真正对Okhttp的Call的封装。然后使用之前的调度器CallAdapter进行代理返回一个被代理的Call。  方法的触发就是直接调用Call的方法，然后在对应的方法中会执行OkHttp Call的构建以及真实的请求，对请求回来的数据然后进行解析。对于协程来说，在解析方法后的invoke转换中就会利用Call的扩展函数来进行协程的请求。"
  },
  
  {
    "title": "Http介绍",
    "url": "/posts/http/",
    "categories": "Android",
    "tags": "OkHttp",
    "date": "2022-11-17 21:30:00 +0800",
    





    "snippet": "MediaType.parse(String)Content-Type、MediaType是什么？  MediaType，即是Internet Media Type，互联网媒体类型，也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。（也就是说MediaType在网络协议的消息头里面叫做Content-Type）它使用两部分的标识符来确定一个类型，是为了表明我们传的东西是什么类型。常见的媒体格式类型如下：  text/html ： HTML格式  text/plain ：纯文本格式  text/xml ：  XML格式  image/gif ：gif图片格式  image/jpeg ：jpg图片格式  image/png：png图片格式以application开头的媒体格式类型  application/xhtml+xml ：XHTML格式  application/xml     ： XML数据格式  application/atom+xml  ：Atom XML聚合格式  application/json    ： JSON数据格式  application/pdf       ：pdf格式  application/msword  ： Word文档格式  application/octet-stream ： 二进制流数据（如常见的文件下载、上传）  application/x-www-form-urlencoded ： &lt;form encType=\"\"&gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）文件上传类型  multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式HTTPS  写一篇最好懂的HTTPS讲解"
  },
  
  {
    "title": "OkHttp使用和解析",
    "url": "/posts/okhttp/",
    "categories": "Android",
    "tags": "OkHttp",
    "date": "2022-11-17 21:30:00 +0800",
    





    "snippet": "使用添加依赖  包含okhttp和其使用的okio库implementation \"com.squareup.okhttp3:okhttp:4.9.3\"创建OkHttpClient对象val httpClient = OkHttpClient.Builder()    .connectTimeout(15, TimeUnit.SECONDS) // 链接超时    .writeTimeout(15, TimeUnit.SECONDS) // 写入超时    .readTimeout(15, TimeUnit.SECONDS) // 读取超时    .addInterceptor( // 添加拦截器        Interceptor { chain -&gt;            val request = chain.request()            // 继续执行            val response = chain.proceed(request)            response        }    )    .cache(Cache(context.cacheDir, 10 * 1024 * 1024))// 设置储存缓存创建承载请求的Request对象空的request对象val request = Request.Builder().build()设置urlval request = Request.Builder()    .url(\"http://coding.jiangker.cn/demo?name=jiangker&amp;age=18\")    .build()使用HttpUrl来构建url的params参数val urlBuilder = \"http://coding.jiangker.cn/demo\".toHttpUrlOrNull()!!.newBuilder()urlBuilder.addQueryParameter(\"name\", name)urlBuilder.addQueryParameter(\"age\", age.toString())val request = Request.Builder()    .url(urlBuilder.build())    .build()默认的请求是get请求，若要发送post请求，则需要添加postjson形式发送body对象// 设置body传递类型val jsonBody: MediaType? = \"application/json; charset=utf-8\".toMediaTypeOrNull()// 构建传递的bodyval builder: RequestBody = \"\"\"{    \"name\": \"jiangker32\",    \"age\": 15}\"\"\".trimIndent()    .toRequestBody(jsonBody)// 构建post类型的requestval request = Request.Builder()    .url(\"http://coding.jiangker.cn/demo\")    .post(builder)    .build()等同于postman中配置Inspectorsbody中携带form-data提交表单val requestBody = FormBody.Builder()    .add(\"name\", \"jiangker\")    .add(\"age\", \"18\")    .build()val request = Request.Builder()    .url(\"http://coding.jiangker.cn/demo\")    .post(requestBody)    .build()等同于postman中发送Inspectors发送请求同步请求val response: Response = client.newCall(request).execute()if (response.isSuccessful) {    val result: String? = response.body?.string()     return result ?: \"empty error\"}异步发送请求client.newCall(request).enqueue(object : Callback {    override fun onFailure(call: Call, e: IOException) {    }    // 子线程的回调    override fun onResponse(call: Call, response: Response) {        val result = response.body?.string()    }})其他读取方式// 输入流val resultStream: InputStream? = response.body()?.byteStream()// 缓冲流val resultSource: BufferedSource? = response.body()?.source()添加header直接添加到request中val request = Request.Builder()    .url(\"http://coding.jiangker.cn/demo\")    .addHeader(\"token\",\"xxxx-xxxx\")    .post(builder)    .build()通过headers添加val headers = Headers.Builder()    .add(\"token\", \"xxxx-xxxx\")    .build()val request = Request.Builder()    .url(urlBuilder.build())    .headers(headers)    .build()headers中的key可能会重复的，可以使用header来替换对应的valueval headers = Headers.Builder()    // 直接添加    .add(\"token\", \"xxxx-xxxx\")    // 清除相同的key的，然后添加    .set(\"token\", \"xxxx-xxxx\")    .build()val request = Request.Builder()    .url(urlBuilder.build())    .headers(headers)    // 清除相同的key的，然后添加    .header(\"token\", \"xxxx-xxxx\")    .build()源码解析OKHttpClientOkHttpClient的构建兼顾Java，使用的Builder模式，有众多参数可以设置，保存着OkHttp的主要公共配置，例如前面的拦截器、超时时间、缓存配置等。在创建Call时会将自己传入，提供公共的配置。override fun newCall(request: Request): Call = RealCall(this, request, forWebSocket = false)Request这个没说明好说的，主要保存的是这个请求的一些关键参数class Request internal constructor(    @get:JvmName(\"url\") val url: HttpUrl,    @get:JvmName(\"method\") val method: String,    @get:JvmName(\"headers\") val headers: Headers,    @get:JvmName(\"body\") val body: RequestBody?,    internal val tags: Map&lt;Class&lt;*&gt;, Any&gt;)RealCall看前面的Call创建，知道OKHttpClient调用newCall时返回的Call实际上是RealCall对象。并且把OkHttpClient和Request都传入了进去。接下来看看请求部分同步请求executeoverride fun execute(): Response {    check(executed.compareAndSet(false, true)) { \"Already Executed\" }    // 设置超时器    timeout.enter()    callStart()    try {        // 把请求添加到同步队列中        client.dispatcher.executed(this)        // 获取责任链结果        return getResponseWithInterceptorChain()    } finally {        // 请求结束后去尝试触发空闲回调        client.dispatcher.finished(this)    }}internal fun getResponseWithInterceptorChain(): Response {    // Build a full stack of interceptors.    val interceptors = mutableListOf&lt;Interceptor&gt;()    interceptors += client.interceptors // 添加自定义的拦截器    interceptors += RetryAndFollowUpInterceptor(client)    interceptors += BridgeInterceptor(client.cookieJar)    interceptors += CacheInterceptor(client.cache) // 缓存拦截器    interceptors += ConnectInterceptor    if (!forWebSocket) {        interceptors += client.networkInterceptors    }    interceptors += CallServerInterceptor(forWebSocket)// 真正强求的拦截器    // 构建责任链    val chain = RealInterceptorChain(        call = this,        interceptors = interceptors,        index = 0,//当前拦截器        exchange = null,        request = originalRequest,        connectTimeoutMillis = client.connectTimeoutMillis,        readTimeoutMillis = client.readTimeoutMillis,        writeTimeoutMillis = client.writeTimeoutMillis    )    var calledNoMoreExchanges = false    try {        val response = chain.proceed(originalRequest)        if (isCanceled()) {            response.closeQuietly()            throw IOException(\"Canceled\")        }        return response    } catch (e: IOException) {        calledNoMoreExchanges = true        throw noMoreExchanges(e) as Throwable    } finally {        if (!calledNoMoreExchanges) {            noMoreExchanges(null)        }    }}这里可以看出是拿出所有的拦截器添加到一个列表中。然后创建RealInterceptorChain这个真正的责任链来依次执行拦截器，最后调用他的proceed方法依次执行。override fun proceed(request: Request): Response {    check(index &lt; interceptors.size)    calls++    if (exchange != null) {        check(exchange.finder.sameHostAndPort(request.url)) {            \"network interceptor ${interceptors[index - 1]} must retain the same host and port\"        }        check(calls == 1) {            \"network interceptor ${interceptors[index - 1]} must call proceed() exactly once\"        }    }    // 创建下一个拦截器    val next = copy(index = index + 1, request = request)    val interceptor = interceptors[index]    // 执行拦截器真正的拦截方法，然后把下一个拦截器传入。拦截器可以决定是否触发下一个拦截器proceed方法。    val response = interceptor.intercept(next) ?: throw NullPointerException(        \"interceptor $interceptor returned null\")    if (exchange != null) {        check(index + 1 &gt;= interceptors.size || next.calls == 1) {            \"network interceptor $interceptor must call proceed() exactly once\"        }    }    check(response.body != null) { \"interceptor $interceptor returned a response with no body\" }    return response}拦截器执行的流程图大概为在RealInterceptorChain会构建出真正的下一个RealInterceptorChain元素，然后调用拦截器的intercept方法传入下一个RealInterceptorChain，当拦截器需要继续执行时，就在拦截器中调用proceed方法传入RealInterceptorChain。否则直接返回response结束拦截器流程。异步请求enqueueoverride fun enqueue(responseCallback: Callback) {    check(executed.compareAndSet(false, true)) { \"Already Executed\" }    callStart()    client.dispatcher.enqueue(AsyncCall(responseCallback))}异步的请求实际会构建一个继承至Runnable的可执行对象，然后交给调度器。internal fun enqueue(call: AsyncCall) {    synchronized(this) {        // 添加到异步容器中        readyAsyncCalls.add(call)        // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to        // the same host.        if (!call.call.forWebSocket) {            // 设置同时对同一个主机的请求关联同一个变量            val existingCall = findExistingCallWithHost(call.host)            if (existingCall != null) call.reuseCallsPerHostFrom(existingCall)        }    }    // 开始执行    promoteAndExecute()}private fun promoteAndExecute(): Boolean {    this.assertThreadDoesntHoldLock()    val executableCalls = mutableListOf&lt;AsyncCall&gt;()    val isRunning: Boolean    synchronized(this) {        val i = readyAsyncCalls.iterator()        while (i.hasNext()) {            val asyncCall = i.next()            if (runningAsyncCalls.size &gt;= this.maxRequests) break // Max capacity.            if (asyncCall.callsPerHost.get() &gt;= this.maxRequestsPerHost) continue // Host max capacity.            i.remove()            // host count + 1            asyncCall.callsPerHost.incrementAndGet()            // 添加到执行队列            executableCalls.add(asyncCall)            // 添加到真正运行的队列            runningAsyncCalls.add(asyncCall)        }        // 同步或者异步请求是否有正在运行的        isRunning = runningCallsCount() &gt; 0    }    for (i in 0 until executableCalls.size) {        val asyncCall = executableCalls[i]        // 去启动请求        asyncCall.executeOn(executorService)    }    return isRunning}大致流程是先把请求添加到待运行队列中，然后再到待执行队列中把元素添加到执行队列，然后触发AsyncCall的executeOn方法fun executeOn(executorService: ExecutorService) {    client.dispatcher.assertThreadDoesntHoldLock()    var success = false    try {        // 使用线程池启动        executorService.execute(this)        success = true    } catch (e: RejectedExecutionException) {        val ioException = InterruptedIOException(\"executor rejected\")        ioException.initCause(e)        noMoreExchanges(ioException)        responseCallback.onFailure(this@RealCall, ioException)    } finally {        if (!success) {            client.dispatcher.finished(this) // This call is no longer running!        }    }}override fun run() {    threadName(\"OkHttp ${redactedUrl()}\") {        var signalledCallback = false        // 启动超时计时        timeout.enter()        try {            val response = getResponseWithInterceptorChain()            signalledCallback = true            responseCallback.onResponse(this@RealCall, response)        } catch (e: IOException) {            if (signalledCallback) {                // Do not signal the callback twice!                Platform.get().log(\"Callback failure for ${toLoggableString()}\", Platform.INFO, e)            } else {                responseCallback.onFailure(this@RealCall, e)            }        } catch (t: Throwable) {            cancel()            if (!signalledCallback) {                val canceledException = IOException(\"canceled due to $t\")                canceledException.addSuppressed(t)                responseCallback.onFailure(this@RealCall, canceledException)            }            throw t        } finally {            client.dispatcher.finished(this)        }    }}internal fun finished(call: AsyncCall) {    // 对同一个主机的请求减一    call.callsPerHost.decrementAndGet()    finished(runningAsyncCalls, call)}executeOn方法就直接把AsyncCall放到线程池中去执行了，当开始执行时，就会启动超时计时。最后流程和同步请求一样，都是调用getResponseWithInterceptorChain()来执行真正的拦截器和请求。最后等待结果的返回，然后回调回去，因为这里是在线程池中，并且回调是没有切换线程的，所以是在子线程返回。最后看一下执行任务的线程池是什么样的。val executorService: ExecutorService    get() {        if (executorServiceOrNull == null) {            executorServiceOrNull = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,                SynchronousQueue(), threadFactory(\"$okHttpName Dispatcher\", false))    }    return executorServiceOrNull!!}这里的线程池是调度器传入的，是使用Java传统的线程池来创建的。是一个无核心线程的非核心线程最大的线程池，比较适合完成这种大量耗时比较短的任务。Dispatcher// 最大异步请求数var maxRequests = 64// 对同一个主机的最大同时请求数var maxRequestsPerHost = 5// 准备的异步请求private val readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()// 正在运行的异步请求private val runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()// 正在运行的同步请求private val runningSyncCalls = ArrayDeque&lt;RealCall&gt;()总结  公共的配置参数主要放在OkHttpClient中、单个请求的信息主要配置在Request中，newCall返回的是一个RealCall对象。  OkHttp中有一个默认的调度器，设置了最大的异步请求，对一个主机的最大同时请求，以及准备的异步请求、正在运行的异步请求和同步请求队列。  当发起同步请求时，会启动超时检测，然后把添加到同步请求队列中，然后调用责任链开始请求。  当发起异步请求时，会先把请求添加到准备队列中，然后去尝试把请求放入正在运行的异步请求队列，若放入成功就会把请求放入线程池开始执行。开始执行后会开始计时以及和同步请求类似的过程，最后回调结果。  责任链的执行首先会收集所有拦截器，然后包装成RealInterceptorChain，主要带入了所有拦截器以及和当前index，然后调用他的process方法开始执行。在process方法中会去构建下一个RealInterceptorChain，然后取出当前拦截器触发intercept方法。依次执行这个流程。在最后的真正的请求的拦截器中会去执行真正的请求，不会再执行next.process方法。然后拦截器也都依次放回结果回去。参考：Okhttp Recipes"
  },
  
  {
    "title": "SparseArray源码解析",
    "url": "/posts/sparsearray/",
    "categories": "Android",
    "tags": "Map",
    "date": "2022-11-17 15:00:00 +0800",
    





    "snippet": "简介对于在HashMap以及ArrayMap中，在存入int类型的key时，也必须有装箱的这一步操作。而SparseArray就是来解决int装箱问题的Map(虽然用法和Map几乎一样，但并没有继承至map，名字上也没有叫map)，同ArrayMap一样，SparseArray也是利用的二分法，但value数组只存value，大概减少1/3的容量，因为key是int，所以也不纯在hash冲突问题了。在此基础上SparseArray也叫做稀疏的Array，所以内部还有延迟回收的机制，用来减少插入以及删除时带来的列表整体移动的性能损耗。另外因为key直接是int，所以key肯定是非空的，而value则是可空的。源码private static final Object DELETED = new Object();private boolean mGarbage = false;// 储存keyprivate int[] mKeys;// 储存valueprivate Object[] mValues;private int mSize;public SparseArray() {    this(10);}public SparseArray(int initialCapacity) {    if (initialCapacity == 0) {        mKeys = EmptyArray.INT;        mValues = EmptyArray.OBJECT;    } else {        mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);        mKeys = new int[mValues.length];    }    mSize = 0;}默认初始容量是为10，分别有储存key的mKeys数组（按大小排序的），和储存value的mValues数组，这两个长度都是相等的，一一对应关系。对应关系如图：gc相比传统的集合，SparseArray做了一个延迟的操作，所以有一个独特的gc方法，用于回收被前面删除的元素。private void gc() {    int n = mSize;    int o = 0;    int[] keys = mKeys;    Object[] values = mValues;    for (int i = 0; i &lt; n; i++) {        Object val = values[i];        if (val != DELETED) {            if (i != o) {                keys[o] = keys[i];                values[o] = val;                // 被移走的位置置空                values[i] = null;            }            o++;        }    }    mGarbage = false;    mSize = o;}代码比较简单，就是判断这个位置value如果已经被delete，则后面的元素依次往前移动。getpublic E get(int key) {    return get(key, null);}public E get(int key, E valueIfKeyNotFound) {    //因为不存在重复值，所以要么找到要么就没有    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);    if (i &lt; 0 || mValues[i] == DELETED) {        return valueIfKeyNotFound;    } else {        return (E) mValues[i];    }}对于SparseArray而言，因为不存在重复元素，所以如果返回的index大于0，则表示有这个key，但如果对应位置的value已经为DELETED，则表示已经被删除了。put// 末尾添加的append方法public void append(int key, E value) {    if (mSize != 0 &amp;&amp; key &lt;= mKeys[mSize - 1]) {        put(key, value);        return;    }    if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) {        gc();    }    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);    mValues = GrowingArrayUtils.append(mValues, mSize, value);    mSize++;}public void put(int key, E value) {    // 二分查找对应的位置或者可以插入的位置取反    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);    if (i &gt;= 0) {        mValues[i] = value;    } else {        i = ~i;        // 如果是当前位置是被DELETED的，直接赋值        if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) {            // 因为可能key并不相等，这个刚好是比他大的第一个位置，所以需要更改key            mKeys[i] = key;            mValues[i] = value;            return;        }        // 如果其他情况需要先回收空余位置        if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) {            gc();            // 重新定位            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);        }        // 插入操作        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);        mSize++;    }}// com.android.internal.util.GrowingArrayUtils.javapublic static boolean[] insert(boolean[] array, int currentSize, int index, boolean element) {    assert currentSize &lt;= array.length;    if (currentSize + 1 &lt;= array.length) {        System.arraycopy(array, index, array, index + 1, currentSize - index);        array[index] = element;        return array;    }    boolean[] newArray = ArrayUtils.newUnpaddedBooleanArray(growSize(currentSize));    System.arraycopy(array, 0, newArray, 0, index);    newArray[index] = element;    System.arraycopy(array, index, newArray, index + 1, array.length - index);    return newArray;}public static int growSize(int currentSize) {    return currentSize &lt;= 4 ? 8 : currentSize * 2;}相比直接插入，这里延迟了一下，若碰到可以直接插入的位置就不用gc了。插入用的工具类的方法，大致是需要扩容时小于4会扩容到8，其余情况都是2倍扩容。removepublic void remove(int key) {    delete(key);}public void delete(int key) {    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);    if (i &gt;= 0) {        if (mValues[i] != DELETED) {            mValues[i] = DELETED;            mGarbage = true;        }    }}public E removeReturnOld(int key) {    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);    if (i &gt;= 0) {        if (mValues[i] != DELETED) {            final E old = (E) mValues[i];            mValues[i] = DELETED;            mGarbage = true;            return old;        }    }    return null;}相比传统的删除移动操作，这里删除之后并不会去移动位置，只会把对应位置元素设置为DELETED。mGarbage表示是否有被删除的元素。containspublic boolean contains(int key) {    return indexOfKey(key) &gt;= 0;}public int indexOfKey(int key) {    if (mGarbage) {        gc();    }    return ContainerHelpers.binarySearch(mKeys, mSize, key);}contains方法会去调用indexOfKey方法，然后是会gc的总结SparseArray是一个延迟删除的Key为int的集合，在删除元素时不会移动数组，只会把value置空，在使用indexOfKey以及插入时插入位置不为空时才会去进行回收操作。所以想看元素内部是否有对应key时，快捷的方式是直接使用get，如果想触发gc则使用contains方法。"
  },
  
  {
    "title": "ArrayMap源码解析",
    "url": "/posts/arraymap/",
    "categories": "Android",
    "tags": "Map",
    "date": "2022-11-17 11:00:00 +0800",
    





    "snippet": "简介ArrayMap是专门针对内存优化设计的，因为HashMap为了快速查询带来了一定的空间浪费。而ArrayMap基于双数组设计，二分法查找，支持缩容，在比较小的数量级情况下拥有不错的效率。原理基本结构// 永远都是false，所以使用的基本为对象的hashcodeprivate final boolean mIdentityHashCode;// hash的数组int[] mHashes;// key value的数组，容量为hash数组的两倍Object[] mArray;int mSize;public ArrayMap() {    this(0, false);}public ArrayMap(int capacity) {    this(capacity, false);}/** {@hide} */public ArrayMap(int capacity, boolean identityHashCode) {    mIdentityHashCode = identityHashCode;    if (capacity &lt; 0) {        mHashes = EMPTY_IMMUTABLE_INTS;        mArray = EmptyArray.OBJECT;    } else if (capacity == 0) {        mHashes = EmptyArray.INT;        mArray = EmptyArray.OBJECT;    } else {        // 初始化的地方        allocArrays(capacity);    }    mSize = 0;}UML图mHashes与mArray基本关系如图，mHashes是有序的hashcode表，而mArray储存的为对应的key与value。如图：缓存相比于其他的数据结构不同，ArrayMap提供一个全局的对于mHashes和mArray的缓存。长度为4和8的缓存结构。private static final int CACHE_SIZE = 10;static Object[] mBaseCache;static int mBaseCacheSize;static Object[] mTwiceBaseCache;static int mTwiceBaseCacheSize;private static final Object sBaseCacheLock = new Object();private static final Object sTwiceBaseCacheLock = new Object();private void allocArrays(final int size) {    if (mHashes == EMPTY_IMMUTABLE_INTS) {        throw new UnsupportedOperationException(\"ArrayMap is immutable\");    }    if (size == (BASE_SIZE*2)) {        synchronized (sTwiceBaseCacheLock) {            if (mTwiceBaseCache != null) {                final Object[] array = mTwiceBaseCache;                mArray = array;                try {                    mTwiceBaseCache = (Object[]) array[0];                    mHashes = (int[]) array[1];                    if (mHashes != null) {                        array[0] = array[1] = null;                        mTwiceBaseCacheSize--;                        if (DEBUG) {                            Log.d(TAG, \"Retrieving 2x cache \" + mHashes                                    + \" now have \" + mTwiceBaseCacheSize + \" entries\");                        }                        return;                    }                } catch (ClassCastException e) {                }                // Whoops!  Someone trampled the array (probably due to not protecting                // their access with a lock).  Our cache is corrupt; report and give up.                Slog.wtf(TAG, \"Found corrupt ArrayMap cache: [0]=\" + array[0]                        + \" [1]=\" + array[1]);                mTwiceBaseCache = null;                mTwiceBaseCacheSize = 0;            }        }    } else if (size == BASE_SIZE) {        synchronized (sBaseCacheLock) {            if (mBaseCache != null) {                final Object[] array = mBaseCache;                mArray = array;                try {                    mBaseCache = (Object[]) array[0];                    mHashes = (int[]) array[1];                    if (mHashes != null) {                        array[0] = array[1] = null;                        mBaseCacheSize--;                        if (DEBUG) {                            Log.d(TAG, \"Retrieving 1x cache \" + mHashes                                    + \" now have \" + mBaseCacheSize + \" entries\");                        }                        return;                    }                } catch (ClassCastException e) {                }                // Whoops!  Someone trampled the array (probably due to not protecting                // their access with a lock).  Our cache is corrupt; report and give up.                Slog.wtf(TAG, \"Found corrupt ArrayMap cache: [0]=\" + array[0]                        + \" [1]=\" + array[1]);                mBaseCache = null;                mBaseCacheSize = 0;            }        }    }    mHashes = new int[size];    mArray = new Object[size&lt;&lt;1];}private static void freeArrays(final int[] hashes, final Object[] array, final int size) {    if (hashes.length == (BASE_SIZE*2)) {        synchronized (sTwiceBaseCacheLock) {            if (mTwiceBaseCacheSize &lt; CACHE_SIZE) {                array[0] = mTwiceBaseCache;                array[1] = hashes;                for (int i=(size&lt;&lt;1)-1; i&gt;=2; i--) {                    array[i] = null;                }                mTwiceBaseCache = array;                mTwiceBaseCacheSize++;                if (DEBUG) Log.d(TAG, \"Storing 2x cache \" + array                        + \" now have \" + mTwiceBaseCacheSize + \" entries\");            }        }    } else if (hashes.length == BASE_SIZE) {        synchronized (sBaseCacheLock) {            if (mBaseCacheSize &lt; CACHE_SIZE) {                array[0] = mBaseCache;                array[1] = hashes;                for (int i=(size&lt;&lt;1)-1; i&gt;=2; i--) {                    array[i] = null;                }                mBaseCache = array;                mBaseCacheSize++;                if (DEBUG) Log.d(TAG, \"Storing 1x cache \" + array                        + \" now have \" + mBaseCacheSize + \" entries\");            }        }    }}这里缓存了一个全局的由mArray的0位置连接的链表，长度为4和8的分别储存，最长支持缓存10个。然后对应的1位置保存mHashes。大致如下图：缓存触发时机  当执行构造函数申请空间时会触发allocArrays()  当执行ensureCapacity()在当前容量小于预期容量的情况下, 先执行allocArrays(),再执行freeArrays()  当执行clear()或者remove()移除最后一个元素是会触发freeArrays()  当执行put()在容量满的情况下, 先执行allocArrays, 再执行freeArrays  当移除元素时size不足1/3并且hash容量大于8时会缩容。执行allocArraysgetpublic V get(Object key) {    final int index = indexOfKey(key);    return index &gt;= 0 ? (V)mArray[(index&lt;&lt;1)+1] : null;}public int indexOfKey(Object key) {    return key == null ? indexOfNull()            : indexOf(key, mIdentityHashCode ? System.identityHashCode(key) : key.hashCode());}int indexOfNull() {    final int N = mSize;    if (N == 0) {        return ~0;    }    int index = binarySearchHashes(mHashes, N, 0);    if (index &lt; 0) {        return index;    }    if (null == mArray[index&lt;&lt;1]) {        return index;    }    int end;    for (end = index + 1; end &lt; N &amp;&amp; mHashes[end] == 0; end++) {        if (null == mArray[end &lt;&lt; 1]) return end;    }    for (int i = index - 1; i &gt;= 0 &amp;&amp; mHashes[i] == 0; i--) {        if (null == mArray[i &lt;&lt; 1]) return i;    }    return ~end;}private static int binarySearchHashes(int[] hashes, int N, int hash) {    try {        return ContainerHelpers.binarySearch(hashes, N, hash);    } catch (ArrayIndexOutOfBoundsException e) {        if (CONCURRENT_MODIFICATION_EXCEPTIONS) {            throw new ConcurrentModificationException();        } else {            throw e; // the cache is poisoned at this point, there's not much we can do        }    }}int indexOf(Object key, int hash) {    final int N = mSize;    if (N == 0) {        return ~0;    }    int index = binarySearchHashes(mHashes, N, hash);    if (index &lt; 0) {        return index;    }    if (key.equals(mArray[index&lt;&lt;1])) {        return index;    }    // Search for a matching key after the index.    int end;    for (end = index + 1; end &lt; N &amp;&amp; mHashes[end] == hash; end++) {        if (key.equals(mArray[end &lt;&lt; 1])) return end;    }    // Search for a matching key before the index.    for (int i = index - 1; i &gt;= 0 &amp;&amp; mHashes[i] == hash; i--) {        if (key.equals(mArray[i &lt;&lt; 1])) return i;    }    return ~end;}get方法主要实现为在hash数组中二分去查找。当存在hash值相等的情况时，向前以及向后去查找。如果最后仍未找到，返回可以插入位置取反。putpublic V put(K key, V value) {    final int osize = mSize;    final int hash;    int index;    if (key == null) {        hash = 0;        index = indexOfNull();    } else {        hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode();        index = indexOf(key, hash);    }    // 如果为正，表示找到了，直接替换    if (index &gt;= 0) {        index = (index&lt;&lt;1) + 1;        final V old = (V)mArray[index];        mArray[index] = value;        return old;    }    // 为负取反获得可以插入的位置    index = ~index;    // 若已经存满了，先扩容    if (osize &gt;= mHashes.length) {        // size大于8则扩容为1.5倍，其余情况则扩容为8或者4，以达到使用缓存的目的。        final int n = osize &gt;= (BASE_SIZE*2) ? (osize+(osize&gt;&gt;1)) : (osize &gt;= BASE_SIZE ? (BASE_SIZE*2) : BASE_SIZE);        if (DEBUG) Log.d(TAG, \"put: grow from \" + mHashes.length + \" to \" + n);        final int[] ohashes = mHashes;        final Object[] oarray = mArray;        allocArrays(n);        if (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) {            throw new ConcurrentModificationException();        }        if (mHashes.length &gt; 0) {            if (DEBUG) Log.d(TAG, \"put: copy 0-\" + osize + \" to 0\");            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);            System.arraycopy(oarray, 0, mArray, 0, oarray.length);        }        freeArrays(ohashes, oarray, osize);    }    // 空出插入位置    if (index &lt; osize) {        if (DEBUG) Log.d(TAG, \"put: move \" + index + \"-\" + (osize-index)                + \" to \" + (index+1));        System.arraycopy(mHashes, index, mHashes, index + 1, osize - index);        System.arraycopy(mArray, index &lt;&lt; 1, mArray, (index + 1) &lt;&lt; 1, (mSize - index) &lt;&lt; 1);    }    // 容量校验，是不支持并发访问的    if (CONCURRENT_MODIFICATION_EXCEPTIONS) {        if (osize != mSize || index &gt;= mHashes.length) {            throw new ConcurrentModificationException();        }    }    mHashes[index] = hash;    mArray[index&lt;&lt;1] = key;    mArray[(index&lt;&lt;1)+1] = value;    mSize++;    return null;}插入元素先二分查找，若查找到已有元素，直接替换返回。若未查找到，则返回的为可以插入的位置。判断是否需要扩容后移动位置插入，因为插入元素涉及到移动位置，所以建议直接按照顺序插入，也提供一个直接append到末尾的方法public void append(K key, V value) {    int index = mSize;    final int hash = key == null ? 0            : (mIdentityHashCode ? System.identityHashCode(key) : key.hashCode());    if (index &gt;= mHashes.length) {        throw new IllegalStateException(\"Array is full\");    }    // 和最后一个比较，若hash值不满足要求，调用普通的put方法    if (index &gt; 0 &amp;&amp; mHashes[index-1] &gt; hash) {        RuntimeException e = new RuntimeException(\"here\");        e.fillInStackTrace();        Log.w(TAG, \"New hash \" + hash                + \" is before end of array hash \" + mHashes[index-1]                + \" at index \" + index + \" key \" + key, e);        put(key, value);        return;    }    mSize = index+1;    mHashes[index] = hash;    index &lt;&lt;= 1;    mArray[index] = key;    mArray[index+1] = value;}append方法会进行hash校验，若满足则直接插入末尾。removepublic V remove(Object key) {    final int index = indexOfKey(key);    if (index &gt;= 0) {        return removeAt(index);    }    return null;}public V removeAt(int index) {    if (index &gt;= mSize &amp;&amp; UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {        throw new ArrayIndexOutOfBoundsException(index);    }    final Object old = mArray[(index &lt;&lt; 1) + 1];    final int osize = mSize;    final int nsize;    // 容量完全清空后回收所有内存    if (osize &lt;= 1) {        // Now empty.        if (DEBUG) Log.d(TAG, \"remove: shrink from \" + mHashes.length + \" to 0\");        final int[] ohashes = mHashes;        final Object[] oarray = mArray;        mHashes = EmptyArray.INT;        mArray = EmptyArray.OBJECT;        freeArrays(ohashes, oarray, osize);        nsize = 0;    } else {        nsize = osize - 1;        // 如果容量利用率不足1/3并且hash容量比8大时，会执行缩容。        if (mHashes.length &gt; (BASE_SIZE*2) &amp;&amp; mSize &lt; mHashes.length/3) {            // 缩容为当前size的1.5倍，即相当于1/3+1/6=1/2,为原来的0.5回收50%的内存            final int n = osize &gt; (BASE_SIZE*2) ? (osize + (osize&gt;&gt;1)) : (BASE_SIZE*2);            if (DEBUG) Log.d(TAG, \"remove: shrink from \" + mHashes.length + \" to \" + n);            final int[] ohashes = mHashes;            final Object[] oarray = mArray;            allocArrays(n);            if (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) {                throw new ConcurrentModificationException();            }            if (index &gt; 0) {                if (DEBUG) Log.d(TAG, \"remove: copy from 0-\" + index + \" to 0\");                System.arraycopy(ohashes, 0, mHashes, 0, index);                System.arraycopy(oarray, 0, mArray, 0, index &lt;&lt; 1);            }            if (index &lt; nsize) {                if (DEBUG) Log.d(TAG, \"remove: copy from \" + (index+1) + \"-\" + nsize                        + \" to \" + index);                System.arraycopy(ohashes, index + 1, mHashes, index, nsize - index);                System.arraycopy(oarray, (index + 1) &lt;&lt; 1, mArray, index &lt;&lt; 1,                        (nsize - index) &lt;&lt; 1);            }        } else {            if (index &lt; nsize) {                if (DEBUG) Log.d(TAG, \"remove: move \" + (index+1) + \"-\" + nsize                        + \" to \" + index);                System.arraycopy(mHashes, index + 1, mHashes, index, nsize - index);                System.arraycopy(mArray, (index + 1) &lt;&lt; 1, mArray, index &lt;&lt; 1,                        (nsize - index) &lt;&lt; 1);            }            mArray[nsize &lt;&lt; 1] = null;            mArray[(nsize &lt;&lt; 1) + 1] = null;        }    }    if (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) {        throw new ConcurrentModificationException();    }    mSize = nsize;    return (V)old;}移除元素也比较简单，分为三种情况  储存完全清空时，回收所有内存  容量利用率不足1/3并且hash容量比8大时，会缩容为原来的50%  一般情况直接拷贝移动位置即可总结  ArrayMap是用两个数组维护的Map，一个为有序的Hash数组，另外一个在对应位置储存着Key与Value，适合小数据量的场景；  使用二分法查找，插入和删除都需要移动位置。所以推荐按hash顺序插入，并且减少容量变更操作；  当hash冲突时，会在相同hash的末尾插入。查找时会向前和向后查找所有相同hash值的进行key比较。  非线程安全容器，支持扩容和缩容，推荐设置默认容量为4或8或4的倍数，以充分利用缓存。参考  深度解读ArrayMap优势与缺陷  Android API 30"
  },
  
  {
    "title": "LinkedHashSet源码解析(JDK8)",
    "url": "/posts/linkedhashset/",
    "categories": "Java",
    "tags": "set",
    "date": "2022-11-17 10:40:00 +0800",
    





    "snippet": "简介LinkedHashSet是一个可以保持添加顺序的Set集合。继承至HashSet，内部使用了HashSet预留的构造方法，内部的HashMap为LinkedHashMap的实现。源码public LinkedHashSet(int initialCapacity, float loadFactor) {    super(initialCapacity, loadFactor, true);}public LinkedHashSet() {    super(16, .75f, true);}从构造函数可以看出，直接使用了HashSet预留的三个元素的构造函数，使用LinkedHashMap实现保持插入顺序。"
  },
  
  {
    "title": "HashSet源码解析(JDK8)",
    "url": "/posts/hashset/",
    "categories": "Java",
    "tags": "set",
    "date": "2022-11-17 10:30:00 +0800",
    





    "snippet": "简介HashSet是一个基于HashMap实现的无重复元素的集合。原理private transient HashMap&lt;E,Object&gt; map;// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object();/**    * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has    * default initial capacity (16) and load factor (0.75).    */public HashSet() {    map = new HashMap&lt;&gt;();}public HashSet(int initialCapacity, float loadFactor) {    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);}HashSet(int initialCapacity, float loadFactor, boolean dummy) {    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);}HashSet内部使用了HashMap来实现功能，HashMap的Key来作为无重复的区分。put进来的元素储存在Map的Key中，Value固定为Object用来区分空的情况。预留了一个defalut范围的构造函数，用于LinkedHashSet来使用，保证可以和Map类似，保留插入顺序。"
  },
  
  {
    "title": "Lrucache源码解析",
    "url": "/posts/lrucache/",
    "categories": "Java",
    "tags": "lru",
    "date": "2022-11-16 18:30:00 +0800",
    





    "snippet": "简介  LruCache是一个范型类，内部使用了一个LinkedHashMap来储存传入的对象。主要提供put和get方法来添加和获取。当添加元素后缓存移出后时，LruCache会移出较早使用的缓存对象。  另外LruCache是一个线程安全的类，内部使用了比较多的锁来维护元素的安全访问。  与HashMap有区别的是，key与value都不支持为null。主要构成public class LruCache&lt;K, V&gt; {    // 真正储存元素的地方    private final LinkedHashMap&lt;K, V&gt; map;    // 当前的大小以及最大支持的大小    private int size;    private int maxSize;    // 一些添加命中等的计数    private int putCount;    private int createCount;    private int evictionCount;    private int hitCount;    private int missCount;    // 设置缓存容量    public LruCache(int maxSize) {        if (maxSize &lt;= 0) {            throw new IllegalArgumentException(\"maxSize &lt;= 0\");        }        this.maxSize = maxSize;        // map使用最近访问模式        this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);    }    // 容量变更    public void resize(int maxSize) {        if (maxSize &lt;= 0) {            throw new IllegalArgumentException(\"maxSize &lt;= 0\");        }        synchronized (this) {            this.maxSize = maxSize;        }        trimToSize(maxSize);    }    public void trimToSize(int maxSize) {        // 依次移除元素，直到当前size不超过容量大小        while (true) {            K key;            V value;            synchronized (this) {                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) {                    throw new IllegalStateException(getClass().getName()                            + \".sizeOf() is reporting inconsistent results!\");                }                if (size &lt;= maxSize) {                    break;                }                Map.Entry&lt;K, V&gt; toEvict = map.eldest();                if (toEvict == null) {                    break;                }                key = toEvict.getKey();                value = toEvict.getValue();                map.remove(key);                size -= safeSizeOf(key, value);                evictionCount++;            }            // 移出元素回调            entryRemoved(true, key, value, null);        }    }}构造方法可以设置可以储存的容量，容量也支持后期的变更。getpublic final V get(K key) {    if (key == null) {        throw new NullPointerException(\"key == null\");    }    V mapValue;    synchronized (this) {        mapValue = map.get(key);        if (mapValue != null) {            hitCount++;            return mapValue;        }        missCount++;    }    V createdValue = create(key);    if (createdValue == null) {        return null;    }    synchronized (this) {        createCount++;        mapValue = map.put(key, createdValue);        if (mapValue != null) {            // There was a conflict so undo that last put            map.put(key, mapValue);        } else {            size += safeSizeOf(key, createdValue);        }    }    if (mapValue != null) {        entryRemoved(false, key, createdValue, mapValue);        return mapValue;    } else {        trimToSize(maxSize);        return createdValue;    }}protected V create(K key) {    return null;}get方法首先会去调用map的get方法，如果没找到支持重载create方法来创建新的对象。putpublic final V put(K key, V value) {    if (key == null || value == null) {        throw new NullPointerException(\"key == null || value == null\");    }    V previous;    synchronized (this) {        putCount++;        size += safeSizeOf(key, value);        previous = map.put(key, value);        if (previous != null) {            size -= safeSizeOf(key, previous);        }    }    if (previous != null) {        entryRemoved(false, key, previous, value);    }    trimToSize(maxSize);    return previous;}put方法也是默认使用map的put方法，然后根据是否命中同一个元素来得到此次put操作对当前size的影响。最后再使用trimToSize来确保不超出容量限制。removepublic final V remove(K key) {    if (key == null) {        throw new NullPointerException(\"key == null\");    }    V previous;    synchronized (this) {        previous = map.remove(key);        if (previous != null) {            size -= safeSizeOf(key, previous);        }    }    if (previous != null) {        entryRemoved(false, key, previous, null);    }    return previous;}这里较put会少一些，只有元素的移除后缩减空间的操作。预留方法// 计算元素所占空间的方法private int safeSizeOf(K key, V value) {    int result = sizeOf(key, value);    if (result &lt; 0) {        throw new IllegalStateException(\"Negative size: \" + key + \"=\" + value);    }    return result;}// 默认都为1，可以重载根据具体大小来实现。例如bitmapprotected int sizeOf(K key, V value) {    return 1;}// 元素移除时的回调，可以重载来缓存到别处protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}总结  LruCache内部使用LinkedHashMap来达到维护缓存的元素，此类key与value皆不可以为null，并且是线程安全的类。  可以重载sizeof方法来给不同元素设置不同大小。  put操作后若超出了容量上限。则会依次移除map中最早使用过的对象，保证缓存的不溢出。  可以重载entryRemoved方法获取元素移除时的回调。leetcode题目146. LRU 缓存"
  },
  
  {
    "title": "LinkedHashMap源码解析(JDK8)",
    "url": "/posts/linkedhashmap/",
    "categories": "Java",
    "tags": "map",
    "date": "2022-11-16 17:30:00 +0800",
    





    "snippet": "简介LinkedHashMap继承至HashMap，对HashMap进行了增强。主要是HashMap是无序的，不能保持插入顺序，而LinkedHashMap对HashMap的Node节点进行了增强。支持了保持插入顺序或者按访问顺序排序。构造函数transient LinkedHashMapEntry&lt;K,V&gt; head;transient LinkedHashMapEntry&lt;K,V&gt; tail;// 设置排序规则，true：访问顺序，false：插入顺序final boolean accessOrder;public LinkedHashMap(int initialCapacity, float loadFactor) {    super(initialCapacity, loadFactor);    accessOrder = false;}public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {    super(initialCapacity, loadFactor);    this.accessOrder = accessOrder;}对比HashMap，主要增加了accessOrder来定义排序规则。Node节点static class LinkedHashMapEntry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {    LinkedHashMapEntry&lt;K,V&gt; before, after;    LinkedHashMapEntry(int hash, K key, V value, Node&lt;K,V&gt; next) {        super(hash, key, value, next);    }}继承至HashMap的Node节点，增加了双链表的结构。getpublic V get(Object key) {    Node&lt;K,V&gt; e;    if ((e = getNode(hash(key), key)) == null)        return null;    // 如果按访问排序，则需要改变顺序，把e移动到末尾    if (accessOrder)        afterNodeAccess(e);    return e.value;}public V getOrDefault(Object key, V defaultValue) {    Node&lt;K,V&gt; e;    if ((e = getNode(hash(key), key)) == null)        return defaultValue;    if (accessOrder)        afterNodeAccess(e);    return e.value;}// 元素访问时调用，把元素移动到末尾void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last    LinkedHashMapEntry&lt;K,V&gt; last;    if (accessOrder &amp;&amp; (last = tail) != e) {        LinkedHashMapEntry&lt;K,V&gt; p = (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after;        p.after = null;        if (b == null)            head = a;        else            b.after = a;        if (a != null)            a.before = b;        else            last = b;        if (last == null)            head = p;        else {            p.before = last;            last.after = p;        }        tail = p;        ++modCount;    }}当元素倍访问后，若是按访问排序，则会把被访问元素放置末尾。containspublic boolean containsValue(Object value) {    for (LinkedHashMapEntry&lt;K,V&gt; e = head; e != null; e = e.after) {        V v = e.value;        if (v == value || (value != null &amp;&amp; value.equals(v)))            return true;    }    return false;}contains相关操作不改变排序顺序，所以几乎是复用的HashMap的replace@Overridepublic V replace(K key, V value) {    Node&lt;K,V&gt; e;    if ((e = getNode(hash(key), key)) != null) {        V oldValue = e.value;        e.value = value;        afterNodeAccess(e);        return oldValue;    }    return null;}同样是用的HashMap的实现。但是值的更改会触发afterNodeAccess方法来更新顺序。putNode&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {    LinkedHashMapEntry&lt;K,V&gt; p = new LinkedHashMapEntry&lt;K,V&gt;(hash, key, value, e);    linkNodeLast(p);    return p;}依旧是复用的HashMap的put方法，不过这里重写了构造node节点的方法，返回的是双链表结构的node节点removevoid afterNodeRemoval(Node&lt;K,V&gt; e) { // unlink    LinkedHashMapEntry&lt;K,V&gt; p = (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after;    p.before = p.after = null;    if (b == null)        head = a;    else        b.after = a;    if (a == null)        tail = b;    else        a.before = b;}remove也是直接调用的HashMap中的实现，然后再HashMap提供的勾子函数中实现了元素的移除操作。勾子方法void afterNodeInsertion(boolean evict) { // possibly remove eldest    LinkedHashMapEntry&lt;K,V&gt; first;    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {        K key = first.key;        removeNode(hash(key), key, null, false, true);    }}protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {    return false;}前面已经看过了HashMap留下的访问以及删除回调，以及新增节点直接添加到末尾的重写。最后看一下afterNodeInsertion方法，这个就是当插入元素后，通过removeEldestEntry判断是否需要删除最旧的元素。这个实现可以在Android中的LruCache中看到。总结  LinkedHashMap是继承至HashMap的增强Map，增加了对插入顺序和最近访问顺序的支持，使用的是双向链表。最新数据放置在末尾。  LinkedHashMap主要重写了HashMap的afterNodeAccess、afterNodeInsertion、afterNodeRemoval三个勾子方法，来在对应的时刻更新顺序。  在把accessOrder设置为true后（默认false），replace、get、remove、put都会把最新的数据放到末尾。"
  },
  
  {
    "title": "HashMap源码解析(JDK8)",
    "url": "/posts/hashmap/",
    "categories": "Java",
    "tags": "map",
    "date": "2022-11-16 14:30:00 +0800",
    





    "snippet": "简介Hashmap是key-value格式的键值对储存容器，key与value都支持null，但非线程安全，若需要线程安全可以使用ConcurrentHashMap。原理构造函数// 最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 默认因子为0.75，即size达到最大容量的0.75时执行扩容static final float DEFAULT_LOAD_FACTOR = 0.75f;final float loadFactor;public HashMap(int initialCapacity, float loadFactor) {    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(\"Illegal initial capacity: \" +                                            initialCapacity);    if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor);    this.loadFactor = loadFactor;    this.threshold = tableSizeFor(initialCapacity);}public HashMap(int initialCapacity) {    this(initialCapacity, DEFAULT_LOAD_FACTOR);}public HashMap() {    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted}// 使数像上取整为2的次方，例如cap=7(111)之后会返回8(1000)static final int tableSizeFor(int cap) {    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}tab长度需要为2的整数倍，当容量超过容量因子*tab长度后会执行扩容。最大tab长度为1 « 30，再大也不会再扩容。size最大为int值。Node节点// Node槽，hash冲突时会先形成链表或者红黑树transient Node&lt;K,V&gt;[] table;static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final int hash;    final K key;    V value;    Node&lt;K,V&gt; next;    Node(int hash, K key, V value, Node&lt;K,V&gt; next) {        this.hash = hash;        this.key = key;        this.value = value;        this.next = next;    }}// LinkedHashMap.LinkedHashMapEntry是继承至HashMap.Node的static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.LinkedHashMapEntry&lt;K,V&gt; {    TreeNode&lt;K,V&gt; parent;  // red-black tree links    TreeNode&lt;K,V&gt; left;    TreeNode&lt;K,V&gt; right;    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion    boolean red;    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {        super(hash, key, val, next);    }}getpublic V get(Object key) {    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;}public V getOrDefault(Object key, V defaultValue) {    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;}// 前16位与后16为进行异或，充分利用hash值，减少hash冲突static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    // 若对应hash槽有元素    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) {        // always check first node        if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        // 如果还有元素，就开始根据是树还是链表依次查找        if ((e = first.next) != null) {            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            do {                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            } while ((e = e.next) != null);        }    }    return null;}hash计算利用前16位与后16位异或，减少冲突。containspublic boolean containsKey(Object key) {    return getNode(hash(key), key) != null;}public boolean containsValue(Object value) {    Node&lt;K,V&gt;[] tab; V v;    if ((tab = table) != null &amp;&amp; size &gt; 0) {        for (int i = 0; i &lt; tab.length; ++i) {            for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {                if ((v = e.value) == value ||                    (value != null &amp;&amp; value.equals(v)))                    return true;            }        }    }    return false;}可以看出，containsKey几乎和get一致,containsValue会按照值去依次比较，找到第一个相等的返回true，效率较低。replace@Overridepublic boolean replace(K key, V oldValue, V newValue) {    Node&lt;K,V&gt; e; V v;    if ((e = getNode(hash(key), key)) != null &amp;&amp; ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) {        e.value = newValue;        afterNodeAccess(e);        return true;    }    return false;}@Overridepublic V replace(K key, V value) {    Node&lt;K,V&gt; e;    if ((e = getNode(hash(key), key)) != null) {        V oldValue = e.value;        e.value = value;        afterNodeAccess(e);        return oldValue;    }    return null;}可以看出，只有元素存在时才可以替换。putstatic final int TREEIFY_THRESHOLD = 8;public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}// 如果有值不修改public V putIfAbsent(K key, V value) {    return putVal(hash(key), key, value, true, true);}// @onlyIfAbsent 如果存在就不要修改值了final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    // 如果tab没有初始化，则先进行初始化操作    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    if ((p = tab[i = (n - 1) &amp; hash]) == null)        // 如果槽上无元素，则直接插入        tab[i] = newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        // 第一个元素就相等了，表示找到了        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            for (int binCount = 0; ; ++binCount) {                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    // 链表中元素大于等于8时转化为树                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                }                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }        if (e != null) { // 如果已经存在，则返回原来的旧值。            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    // 大于了因子容量    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    if (oldCap &gt; 0) {        // 如果已经达到槽的最大限制，则不再扩容，继续在树上添加        if (oldCap &gt;= MAXIMUM_CAPACITY) {            threshold = Integer.MAX_VALUE;            return oldTab;        }        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // double threshold    }    else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else {               // zero initial threshold signifies using defaults        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }    if (newThr == 0) {        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);    }    threshold = newThr;    @SuppressWarnings({\"rawtypes\",\"unchecked\"})        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    if (oldTab != null) {        for (int j = 0; j &lt; oldCap; ++j) {            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) {                oldTab[j] = null;                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)                    // 分组，若相同hash值元素小于等于6时，会转化为链表，否则依然构建为树                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else { // preserve order                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    // 从头到位依次与之前容量-1进行与操作，间接得到第一位，然后依次形成链表，最后插入到其中。                    do {                        next = e.next;                        if ((e.hash &amp; oldCap) == 0) {                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        } else {                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        }                    } while ((e = next) != null);                    if (loTail != null) {                        loTail.next = null;                        newTab[j] = loHead;                    }                    if (hiTail != null) {                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    }                }            }        }    }    return newTab;}static final int MIN_TREEIFY_CAPACITY = 64;final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {    int n, index; Node&lt;K,V&gt; e;    // 若槽数小于64，因为很容易冲突，所以优先扩容。    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {        TreeNode&lt;K,V&gt; hd = null, tl = null;        do {            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);            if (tl == null)                hd = p;            else {                p.prev = tl;                tl.next = p;            }            tl = p;        } while ((e = e.next) != null);        if ((tab[index] = hd) != null)            hd.treeify(tab);    }}  首先会对为空的情况进行初始化，初始化默认为16。  槽位置计算为length - 1 &amp; hash          若对应位置上无元素直接插入      若对应位置有元素为链表，则依次遍历，往最后位置插入，插入后元素若大于等于8且tab长度大于等于64，则转变成树。      若对应位置为树，则查找插入。        最后会与容量因子进行比较，若超过则进行扩容。          扩容是成倍操作。      扩容操作为获取当前槽元素的第一位hash值来进行划分。      树在分槽后若元素小于等于6则变更为列表，否则依然保持为树。      removepublic V remove(Object key) {    Node&lt;K,V&gt; e;    return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;}public boolean remove(Object key, Object value) {    return removeNode(hash(key), key, value, true, true) != null;}final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) {        Node&lt;K,V&gt; node = null, e; K k; V v;        if(p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            node = p;        else if ((e = p.next) != null) {            if (p instanceof TreeNode)                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);            else {                do {                    if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {                        node = e;                        break;                    }                    p = e;                } while ((e = e.next) != null);            }        }        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) {            if (node instanceof TreeNode)                // 移出元素，当树已经特别小的时候会转化为链表                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);            else if (node == p)                tab[index] = node.next;            else                p.next = node.next;            ++modCount;            --size;            afterNodeRemoval(node);            return node;        }    }    return null;}移出操作比较简单，先确认是否有元素以及是否能移出。迭代器public Set&lt;K&gt; keySet() {    Set&lt;K&gt; ks = keySet;    if (ks == null) {        ks = new KeySet();        keySet = ks;    }    return ks;}public Collection&lt;V&gt; values() {    Collection&lt;V&gt; vs = values;    if (vs == null) {        vs = new Values();        values = vs;    }    return vs;}public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;}迭代器比较简单，通ArrayList一样，在迭代过程中不允许元素的增加或删除一些额外的方法// Callbacks to allow LinkedHashMap post-actions// 节点访问void afterNodeAccess(Node&lt;K,V&gt; p) { }// 新节点插入void afterNodeInsertion(boolean evict) { }// 节点移除void afterNodeRemoval(Node&lt;K,V&gt; p) { }HashMap提供的几个空实现的方法，主要用在LinkedHashMap继承HashMap后得到操作的回掉。总结  hashMap由数组组成，使用链表或者红黑树来解决hash冲突。  默认数组长度为2的次方。  添加元素时，若存在hash冲突，则会从链表尾部插入元素。若链表长度大于等于8时，tab长度小于64会优先扩容。否则会转化为红黑树。  当容量超过容量因子上限时会执行扩容操作。扩容时hash值取最新的一位确定位置。树扩容后若元素小于等于6个会转化为链表。  不支持并发操作。支持迭代快速失败。"
  },
  
  {
    "title": "Bitmap简介",
    "url": "/posts/bitmap/",
    "categories": "Android",
    "tags": "bitmap",
    "date": "2022-11-16 04:16:00 +0800",
    





    "snippet": "简介bitmap翻译为位图，指的是一张图片。是安卓中常用于操作图像的一个类，提供图片加载、裁剪、旋转等诸多操作。创建Bitmap提供多种构建方式Bitmap.createBitmap()的一系列重载BitmapFactory的一系列方法加载图片可以使用BitmapFactory来从文件系统、资源、输入流以及字节数组中加载出一个bitmap对象。因为Bitmap占用空间比较大，尤其是加载大图时，而往往并不需要那么清晰的图片时，还全量加载的话会照成资源的浪费，并且更严重会导致OOM的发生。BitmapFactory提供一个Options来优化加载图片，Options可以设置采样率，通过设置inSampleSize参数来控制。当inSampleSize=2时，表示长宽都为原始尺寸的一半，总大小就为原来的1/4了。inSampleSize会向下取整为2的指数。val options = BitmapFactory.Options()options.inSampleSize = 2而往往我们并不知道图片的尺寸大小。这时可以通过设置inJustDecodeBounds来解析图片大小。val options = BitmapFactory.Options()// 只测量宽高不加载到内存options.inJustDecodeBounds = trueBitmapFactory.decodeResource(resources, R.drawable.img, options)// 获取测量的宽高val height = options.outHeightval width = options.outWidth还可以通过设置加载的格式来进一步优化空间，默认图片为Bitmap.Config.ARGB_8888，占4个字节。若不关心透明度，可以使用Bitmap.Config.RGB_565。这种模式图片质量几乎没有差别但只占用2个字节，可以使图片所占内存减小到之前的一半。（ARGB_4444）因为质量较差已被废弃。val options = BitmapFactory.Options()options.inPreferredConfig = Bitmap.Config.RGB_565图片所占内存 = 长 x 宽 x 单像素空间Drawable 缩放规则系统首先会去加载对应dpi的图片，当没有时会向上查找。当dpi不匹配时，会进行一定程度的缩放。例如（宽度举例）：当使用460dpi的手机去加载一个250像素的图片，图片位于xxxhdpi下即640dpi。这时实际图片大小就为460/640*250=179.68会向下取整为179。当然如果我们手动更改系统的densityDpi，这里的图片也会受到相应的影响。参考  Android Bitmap 详解：关于 Bitamp 你所要知道的一切"
  },
  
  {
    "title": "Android Density屏幕适配",
    "url": "/posts/density/",
    "categories": "Android",
    "tags": "density",
    "date": "2022-11-15 23:03:00 +0800",
    





    "snippet": "简介对于常见的项目中，UI都会以宽为基准来出图，这时就会以固定的屏幕宽度来定稿。但是安卓屏幕各异，密度各不相同，所以不能简单的直接使用dp来定义UI的样式。DPI在Android中，DPI表示屏幕像素密度。表示单位长度上对应的像素个数。在resource中有一个displayMetrics管理着对应的值。displayMetrics中有两个重要的参数  densityDpi，表示屏幕的dpi，dpi的基准为160，即160的dpi时1dp=1px，480的dpi时1dp=3px  density，即表示上面的比例关系，480dp时density为3。屏幕宽度=density*宽度总dp屏幕适配所以这时我们要使屏幕的宽度dp数固定，则density需要为屏幕总宽度/期望dp数，densityDpi再等于计算所得density乘160.大概就可以写出如下简单的适配方法了，这个更改会影响图片的加载放大比例，也会影响到第三方库中 UI相关dp的定义，但一般不会直接使用三方库的UI，所以影响不大在Application中添加class App : Application() {    init {        registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacks {            override fun onActivityPreCreated(activity: Activity, savedInstanceState: Bundle?) {                super.onActivityPreCreated(activity, savedInstanceState)                // 在activity onCreate之前去更改，因为在setContentView时就会开始去生成view树了                val appDisplayMetrics = resources.displayMetrics                val activityDisplayMetrics = activity.resources.displayMetrics                activityDisplayMetrics.density = appDisplayMetrics.density                activityDisplayMetrics.densityDpi = appDisplayMetrics.densityDpi            }                        //其实在onActivityCreated中也可以，这个方法使super.onCreate中调用的            // ...        })    }    override fun onCreate() {        super.onCreate()        val appDisplayMetrics = resources.displayMetrics        // 这里举例期望的宽度为375dp        val targetDensity = 1.0f * appDisplayMetrics.widthPixels / 375        val targetDensityDpi = (targetDensity * 160).toInt()        // 更改app中默认的参数        appDisplayMetrics.density = targetDensity        appDisplayMetrics.densityDpi = targetDensityDpi    }    companion object {        var activity: Activity? = null    }}参考  一文读懂 Android 主流屏幕适配方案"
  },
  
  {
    "title": "Binder进程间通信",
    "url": "/posts/binder/",
    "categories": "Android",
    "tags": "binder",
    "date": "2022-11-15 15:03:00 +0800",
    





    "snippet": "简介同一个程序中的两个函数之间能直接调用的根本原因是处于相同的内存空间中，虚拟地址的映射规则完全一致，所以可以直接相互调用。而两个不同的进程，是没有办法通过内存地址来访问对方内部函数和变量的，既然无法直接访问对方进程的内容，这时就可以用到Binder来间接访问对方的内容。binder主要分为一下四部分内容：  Binder驱动  Service Manager  Binder Client  Binder Server智能指针概括  Android中的智能指针是基于引用计数的强指针SP以及弱指针WP两种。  通常情况下目标对象的父类是RefBase，这个提高了weakrf_impl类型的引用计数，可以同时进行强弱引用的控制（内部由mStrong和mWeak提供计数）  当incStrong增加强引用时，也会增加弱引用。  当incWeak时只增加弱引用计数。  使用者可以通过extend ObjectLifetime设置引用计数的规则，不同规则下对删除目标对象的时机判断也是不一样的。  使用者可以根据程序需求来选择合适的智能指针类型和计数器规则。BinderBinder驱动和协议Binder Driver会通过misc_register()将自己注册成一个misc device，并向上层提供一个/dev/binder节点，binder节点并不对应真实的硬件设备。binder驱动运行于内核态，可以提供binder_open(),binder_ioctl(),binder_mmap()等常用的文件操作。  打开Binder驱动-binder_open，会返回一个binder_proc实体，之后的binder操作都依赖这个对象。  binder_mmap把设备指定的内存块直接映射到应用程序的内存空间中。这个通过虚拟内存的转换也是指向的物理内存的某个位置。会返回一个binder_proc-&gt;buffer来表示内存地址。TODO 后期再补参考  《深入理解Android内核设计思想》  Android Binder设计与实现 - 设计篇"
  },
  
  {
    "title": "ArrayList源码解析(JDK8)",
    "url": "/posts/arraylist/",
    "categories": "Java",
    "tags": "list",
    "date": "2022-11-14 18:30:00 +0800",
    





    "snippet": "简介  ArrayList是基于数组的非线程安全的列表，提供O(1)的随机访问能力，增加和删除效率较低。构造方法private static final Object[] EMPTY_ELEMENTDATA = {};private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};transient Object[] elementData;public ArrayList() {    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;}public ArrayList(int initialCapacity) {    if (initialCapacity &gt; 0) {        this.elementData = new Object[initialCapacity];    } else if (initialCapacity == 0) {        this.elementData = EMPTY_ELEMENTDATA;    } else {        throw new IllegalArgumentException(\"Illegal Capacity: \"+                                            initialCapacity);    }}public ArrayList(Collection&lt;? extends E&gt; c) {    elementData = c.toArray();    if ((size = elementData.length) != 0) {        // c.toArray might (incorrectly) not return Object[] (see 6260652)        if (elementData.getClass() != Object[].class)            elementData = Arrays.copyOf(elementData, size, Object[].class);    } else {        // replace with empty array.        this.elementData = EMPTY_ELEMENTDATA;    }}含有三个构造方法，默认为空列表，也可以手动指定容量。因为扩容需要拷贝整个列表，所有对于已知容量大小的规模，初始化时最好一步到位。更改容量// 重新生成一份和数据量等同大小的列表public void trimToSize() {    modCount++;    if (size &lt; elementData.length) {        elementData = (size == 0)            ? EMPTY_ELEMENTDATA            : Arrays.copyOf(elementData, size);    }}// 对外的扩容方法public void ensureCapacity(int minCapacity) {    int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)        // any size if not default element table        ? 0        // larger than default for default empty table. It's already        // supposed to be at default size.        : DEFAULT_CAPACITY;    if (minCapacity &gt; minExpand) {        ensureExplicitCapacity(minCapacity);    }}private static final int DEFAULT_CAPACITY = 10;private void ensureCapacityInternal(int minCapacity) {    // 第一次添加元素会直接扩容到10    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);    }    ensureExplicitCapacity(minCapacity);}private void ensureExplicitCapacity(int minCapacity) {    modCount++;    // 不能比当前容量更小    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);}private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    // 扩容1.5倍    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    // 取大的    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    // 如果新容量大于标定值，则用小容量尝试    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);}// 会留8个余量，再大最多等于int最大值private static int hugeCapacity(int minCapacity) {    if (minCapacity &lt; 0) // overflow        throw new OutOfMemoryError();    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;}trimToSize可以去除数组多余空间，ensureCapacity可以实现空间的扩容，当容量为零时的一次扩容会设置为10，之后的每一次扩容都是1.5倍扩容。查找public boolean contains(Object o) {    return indexOf(o) &gt;= 0;}public int indexOf(Object o) {    if (o == null) {        for (int i = 0; i &lt; size; i++)            if (elementData[i]==null)                return i;    } else {        for (int i = 0; i &lt; size; i++)            if (o.equals(elementData[i]))                return i;    }    return -1;}public int lastIndexOf(Object o) {    if (o == null) {        for (int i = size-1; i &gt;= 0; i--)            if (elementData[i]==null)                return i;    } else {        for (int i = size-1; i &gt;= 0; i--)            if (o.equals(elementData[i]))                return i;    }    return -1;}public E get(int index) {    if (index &gt;= size)        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));    return (E) elementData[index];}替换public E set(int index, E element) {    if (index &gt;= size)        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));    E oldValue = (E) elementData[index];    elementData[index] = element;    return oldValue;}增加// 容量确认public boolean add(E e) {    ensureCapacityInternal(size + 1);  // Increments modCount!!    elementData[size++] = e;    return true;}public void add(int index, E element) {    if (index &gt; size || index &lt; 0)        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));    ensureCapacityInternal(size + 1);  // Increments modCount!!    System.arraycopy(elementData, index, elementData, index + 1,                        size - index);    elementData[index] = element;    size++;}删除// 移除元素并不会有缩容量操作，需要手动public E remove(int index) {    if (index &gt;= size)        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));    modCount++;    E oldValue = (E) elementData[index];    int numMoved = size - index - 1;    if (numMoved &gt; 0)        System.arraycopy(elementData, index+1, elementData, index,                            numMoved);    elementData[--size] = null; // clear to let GC do its work    return oldValue;}// 从头到位，只会移除一个public boolean remove(Object o) {    if (o == null) {        for (int index = 0; index &lt; size; index++)            if (elementData[index] == null) {                fastRemove(index);                return true;            }    } else {        for (int index = 0; index &lt; size; index++)            if (o.equals(elementData[index])) {                fastRemove(index);                return true;            }    }    return false;}private void fastRemove(int index) {    modCount++;    int numMoved = size - index - 1;    if (numMoved &gt; 0)        System.arraycopy(elementData, index+1, elementData, index,                            numMoved);    elementData[--size] = null; // clear to let GC do its work}清除public void clear() {    modCount++;    // clear to let GC do its work    for (int i = 0; i &lt; size; i++)        elementData[i] = null;    size = 0;}SubList// 使用subList可以获得一个ArrayList的片段public List&lt;E&gt; subList(int fromIndex, int toIndex) {    subListRangeCheck(fromIndex, toIndex, size);    return new SubList(this, 0, fromIndex, toIndex);}private class SubList extends AbstractList&lt;E&gt; implements RandomAccess {    private final AbstractList&lt;E&gt; parent;    private final int parentOffset;    private final int offset;    int size;    SubList(AbstractList&lt;E&gt; parent,            int offset, int fromIndex, int toIndex) {        this.parent = parent;        this.parentOffset = fromIndex;        this.offset = offset + fromIndex;        this.size = toIndex - fromIndex;        this.modCount = ArrayList.this.modCount;    }    public E set(int index, E e) {        if (index &lt; 0 || index &gt;= this.size)            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));        if (ArrayList.this.modCount != this.modCount)            throw new ConcurrentModificationException();        E oldValue = (E) ArrayList.this.elementData[offset + index];        ArrayList.this.elementData[offset + index] = e;        return oldValue;    }    public E get(int index) {        if (index &lt; 0 || index &gt;= this.size)            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));        if (ArrayList.this.modCount != this.modCount)            throw new ConcurrentModificationException();        return (E) ArrayList.this.elementData[offset + index];    }        // ...}SubList是ArrayList的一个片段，返回的SubList可以进行List的操作，并且会响应到父容器上。当父容器进行size变化的操作(add、remove等)之后，SubList不可再进行操作，否则会抛出异常。Itr迭代器public Iterator&lt;E&gt; iterator() {    return new Itr();}private class Itr implements Iterator&lt;E&gt; {    protected int limit = ArrayList.this.size;    int cursor;       // index of next element to return    int lastRet = -1; // index of last element returned; -1 if no such    int expectedModCount = modCount;    public boolean hasNext() {        return cursor &lt; limit;    }    @SuppressWarnings(\"unchecked\")    public E next() {        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        int i = cursor;        if (i &gt;= limit)            throw new NoSuchElementException();        Object[] elementData = ArrayList.this.elementData;        if (i &gt;= elementData.length)            throw new ConcurrentModificationException();        cursor = i + 1;        return (E) elementData[lastRet = i];    }    public void remove() {        if (lastRet &lt; 0)            throw new IllegalStateException();        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        try {            ArrayList.this.remove(lastRet);            cursor = lastRet;            lastRet = -1;            expectedModCount = modCount;            limit--;        } catch (IndexOutOfBoundsException ex) {            throw new ConcurrentModificationException();        }    }}iterator方法会返回一个迭代器。迭代过程中会校验modCount，若出现变化，则会抛出异常。listItr迭代器public ListIterator&lt;E&gt; listIterator() {    return new ListItr(0);}private class ListItr extends Itr implements ListIterator&lt;E&gt; {    ListItr(int index) {        super();        cursor = index;    }    public boolean hasPrevious() {        return cursor != 0;    }    public int nextIndex() {        return cursor;    }    public int previousIndex() {        return cursor - 1;    }    @SuppressWarnings(\"unchecked\")    public E previous() {        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        int i = cursor - 1;        if (i &lt; 0)            throw new NoSuchElementException();        Object[] elementData = ArrayList.this.elementData;        if (i &gt;= elementData.length)            throw new ConcurrentModificationException();        cursor = i;        return (E) elementData[lastRet = i];    }    public void set(E e) {        if (lastRet &lt; 0)            throw new IllegalStateException();        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        try {            ArrayList.this.set(lastRet, e);        } catch (IndexOutOfBoundsException ex) {            throw new ConcurrentModificationException();        }    }    public void add(E e) {        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        try {            int i = cursor;            ArrayList.this.add(i, e);            cursor = i + 1;            lastRet = -1;            expectedModCount = modCount;            limit++;        } catch (IndexOutOfBoundsException ex) {            throw new ConcurrentModificationException();        }    }}对比普通的迭代器多了更多的元素操作以及可以向前移动。总结      默认长度为0，当增加元素时，容量首先会扩充为10.当容量比较大时，会按照1.5倍的方式进行扩容，容量上限为int最大值。移除元素时不会缩容。        SubList可以获取ArrayList元素片段，对片段的操作会同步到ArrayList上。当对ArrayList操作改变了modCount，SubList就不可以再使用了。        对size有改变的操作都会增加modCount，再快速迭代的过程中有改变就会报错。  "
  },
  
  {
    "title": "Handler分析",
    "url": "/posts/handler/",
    "categories": "Android",
    "tags": "handler",
    "date": "2022-11-14 14:38:00 +0800",
    





    "snippet": "使用创建哪个线程的handler，这个线程必须要有looperhandler的时间指的是开机之后的毫秒数SystemClock.uptimeMillis()主线程handler的一般使用//创建主线程的handlerprivate val handler = object :Handler(Looper.getMainLooper()){    override fun handleMessage(msg: Message) {        super.handleMessage(msg)    }}//发送消息到消息队列，消息由这个handler的handleMessage处理handler.sendMessage(Message.obtain())//或val handler = Handler(Looper.getMainLooper(), Handler.Callback {    // 返回true，发送的消息由这个callback处理    return@Callback true})//打包成message发送，最后回调这个runnablehandler.post {  }子线程handler的创建//创建当前线程的looper对象Looper.prepare()val handler = object :Handler(Looper.myLooper()){    override fun handleMessage(msg: Message) {        super.handleMessage(msg)    }}//开启循环Looper.loop()原理  Android App是由事件驱动的GUI程序，所以应用程序的主入口mian函数的职责如下：      初始化    进入死循环，处理各种事件    所以handler总的来说就是：Looper不断获取MessageQueue中的一个Message，然后由Handler来处理。1 Handler1.1 Handler的主要职责  处理Message，这是它作为“处理者”的本职所在  将某个Message压入MessageQueue中1.2 Handler的事件分发1.2.1 代码分析public class Handler {    final Callback mCallback;    final Looper mLooper;    final MessageQueue mQueue;    //默认只能发同步消息，所以一般为false    final boolean mAsynchronous;    /**     * 对外的方法必须要传looper，之前未传looper的方法已被废弃，     * 保证使用handler的线程都有looper，handler直接关联looper     */    public Handler(@NonNull Looper looper) {        this(looper, null, false);    }    public Handler(@NonNull Looper looper, @Nullable Callback callback) {        this(looper, callback, false);    }        @UnsupportedAppUsage    public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) {        mLooper = looper;        mQueue = looper.mQueue;        mCallback = callback;        mAsynchronous = async;    }    // 所有发送的消息都会走到这里，所以每个事件都会有一个期望执行的事件，队列就会根据这个时间进行排序。    private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) {        msg.target = this;        if (mAsynchronous) {            //设置为异步消息            msg.setAsynchronous(true);        }        return queue.enqueueMessage(msg, uptimeMillis);    }    public void dispatchMessage(@NonNull Message msg) {        if (msg.callback != null) {            //如果发送的是一个runable对象，则回调run方法            handleCallback(msg);        } else {            if (mCallback != null) {                //如果handler设置了统一处理的callback，则交由处理                if (mCallback.handleMessage(msg)) {                    return;                }            }            //handler自己处理            handleMessage(msg);        }    }    /**     * 重写这个方法，处理消息     * @param msg     */    public void handleMessage(@NonNull Message msg) {    }    private static void handleCallback(Message message) {        message.callback.run();    }    public interface Callback{        boolean handleMessage(@Nullable Message msg);    }}1.2.2 派发事件逻辑图1.3 Handler与Thread的联系  每个Thread只对应一个Looper (Looper中的静态ThreadLocal中，只能初始化一次，Looper的操作方法都是操作的对应自己线程的looper对象)  每个Looper只对应一个MessageQueue（Looper中有一个MessageQueue对象）  每个MessageQueue中有N个Message  每个Message最多由一个handler处理2. MessageQueue消息队列，具有“队列”的所有常规操作。2.1 常用方法            方法名称      说明                  boolean enqueueMessage(Message msg, long when)      元素入队              Message next()      元素出队              void removeMessages(Handler h, int what, Object object)      元素出队              void removeMessages(Handler h, Runnable r, Object object)      元素出队              void quit(boolean safe)      true表示推出当前时间之后的事件，false表示全部事件      public final class MessageQueue {    private final boolean mQuitAllowed;    private boolean mQuitting;    Message mMessages;    private final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;&gt;();    MessageQueue(boolean quitAllowed){        mQuitAllowed = mQuitting;    }    public int postSyncBarrier() {        return postSyncBarrier(SystemClock.uptimeMillis());    }    private int postSyncBarrier(long when) {        synchronized (this) {            final int token = mNextBarrierToken++;            final Message msg = Message.obtain();            msg.markInUse();            msg.when = when;            msg.arg1 = token;            Message prev = null;            Message p = mMessages;            if (when != 0) {                while (p != null &amp;&amp; p.when &lt;= when) {                    prev = p;                    p = p.next;                }            }            if (prev != null) { // invariant: p == prev.next                msg.next = p;                prev.next = msg;            } else {                msg.next = p;                mMessages = msg;            }            return token;        }    }        public void removeSyncBarrier(int token) {        // Remove a sync barrier token from the queue.        // If the queue is no longer stalled by a barrier then wake it.        synchronized (this) {            Message prev = null;            Message p = mMessages;            while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) {                prev = p;                p = p.next;            }            if (p == null) {                throw new IllegalStateException(\"The specified message queue synchronization \"                        + \" barrier token has not been posted or has already been removed.\");            }            final boolean needWake;            if (prev != null) {                prev.next = p.next;                needWake = false;            } else {                mMessages = p.next;                needWake = mMessages == null || mMessages.target != null;            }            p.recycleUnchecked();            // If the loop is quitting then it is already awake.            // We can assume mPtr != 0 when mQuitting is false.            if (needWake &amp;&amp; !mQuitting) {                nativeWake(mPtr);            }        }    }    boolean enqueueMessage(Message msg, long when) {        if (msg.target == null) {            throw new IllegalArgumentException(\"Message must have a target.\");        }        //如果已经插入到了队列中的消息不能重复放入        if (msg.isInUse()) {            throw new IllegalStateException(msg + \" This message is already in use.\");        }        synchronized (this) {            if (mQuitting) {                IllegalStateException e = new IllegalStateException(                        msg.target + \" sending message to a Handler on a dead thread\");                Log.w(TAG, e.getMessage(), e);                msg.recycle();                return false;            }            msg.markInUse();            msg.when = when;            Message p = mMessages;            boolean needWake;            if (p == null || when == 0 || when &lt; p.when) {                // New head, wake up the event queue if blocked.                msg.next = p;                mMessages = msg;                needWake = mBlocked;            } else {                // Inserted within the middle of the queue.  Usually we don't have to wake                // up the event queue unless there is a barrier at the head of the queue                // and the message is the earliest asynchronous message in the queue.                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();                Message prev;                for (;;) {                    prev = p;                    p = p.next;                    //相同时间的消息，插入到之后                    if (p == null || when &lt; p.when) {                        break;                    }                    if (needWake &amp;&amp; p.isAsynchronous()) {                        needWake = false;                    }                }                msg.next = p; // invariant: p == prev.next                prev.next = msg;            }            // We can assume mPtr != 0 because mQuitting is false.            if (needWake) {                nativeWake(mPtr);            }        }        return true;    }    @UnsupportedAppUsage    Message next() {        int pendingIdleHandlerCount = -1; // -1 only during first iteration        int nextPollTimeoutMillis = 0;        for (;;) {            synchronized (this) {                // Try to retrieve the next message.  Return if found.                final long now = SystemClock.uptimeMillis();                Message prevMsg = null;                Message msg = mMessages;                if (msg != null &amp;&amp; msg.target == null) {                    // Stalled by a barrier.  Find the next asynchronous message in the queue.                    do {                        prevMsg = msg;                        msg = msg.next;                    } while (msg != null &amp;&amp; !msg.isAsynchronous());                }                if (msg != null) {                    if (now &lt; msg.when) {                        // Next message is not ready.  Set a timeout to wake up when it is ready.                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);                    } else {                        // Got a message.                        mBlocked = false;                        if (prevMsg != null) {                            prevMsg.next = msg.next;                        } else {                            mMessages = msg.next;                        }                        msg.next = null;                        msg.markInUse();                        return msg;                    }                } else {                    // No more messages.                    nextPollTimeoutMillis = -1;                }                // Process the quit message now that all pending messages have been handled.                if (mQuitting) {                    return null;                }                // If first time idle, then get the number of idlers to run.                // Idle handles only run if the queue is empty or if the first message                // in the queue (possibly a barrier) is due to be handled in the future.                if (pendingIdleHandlerCount &lt; 0                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {                    pendingIdleHandlerCount = mIdleHandlers.size();                }                if (pendingIdleHandlerCount &lt;= 0) {                    // No idle handlers to run.  Loop and wait some more.                    mBlocked = true;                    continue;                }                if (mPendingIdleHandlers == null) {                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];                }                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);            }            // Run the idle handlers.            // We only ever reach this code block during the first iteration.            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {                final android.os.MessageQueue.IdleHandler idler = mPendingIdleHandlers[i];                mPendingIdleHandlers[i] = null; // release the reference to the handler                boolean keep = false;                try {                    keep = idler.queueIdle();                } catch (Throwable t) {                    Log.wtf(TAG, \"IdleHandler threw exception\", t);                }                if (!keep) {                    synchronized (this) {                        mIdleHandlers.remove(idler);                    }                }            }            // Reset the idle handler count to 0 so we do not run them again.            pendingIdleHandlerCount = 0;            // While calling an idle handler, a new message could have been delivered            // so go back and look again for a pending message without waiting.            nextPollTimeoutMillis = 0;        }    }    void quit(boolean safe) {        if (!mQuitAllowed) {            throw new IllegalStateException(\"Main thread not allowed to quit.\");        }        synchronized (this) {            if (mQuitting) {                return;            }            mQuitting = true;            if (safe) {                // 安全退出只移出当前时间之后的事件，保证已经到了的事件全部执行                removeAllFutureMessagesLocked();            } else {                // 移除所有                removeAllMessagesLocked();            }            // We can assume mPtr != 0 because mQuitting was previously false.            nativeWake(mPtr);        }    }    private void removeAllMessagesLocked() {        Message p = mMessages;        while (p != null) {            Message n = p.next;            p.recycleUnchecked();            p = n;        }        mMessages = null;    }    private void removeAllFutureMessagesLocked() {        final long now = SystemClock.uptimeMillis();        Message p = mMessages;        if (p != null) {            if (p.when &gt; now) {                removeAllMessagesLocked();            } else {                Message n;                for (;;) {                    n = p.next;                    if (n == null) {                        return;                    }                    if (n.when &gt; now) {                        break;                    }                    p = n;                }                p.next = null;                do {                    p = n;                    n = p.next;                    p.recycleUnchecked();                } while (n != null);            }        }    }    public static interface IdleHandler {        boolean queueIdle();    }}3 Looperpublic final class Looper {        static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;&gt;();    private static Looper sMainLooper;    final MessageQueue mQueue;    final Thread mThread;        private Looper(boolean quitAllowed){        mQueue = new MessageQueue(quitAllowed);        mThread = Thread.currentThread();    }        public static void prepare(){        prepare(true);    }        private static void prepare(boolean quitAllowed){        //一个线程中只能有一个Looper对象        if (sThreadLocal.get() != null) {            throw new RuntimeException(\"Only one Looper may be created per thread\");        }        sThreadLocal.set(new Looper(quitAllowed));    }        public void quit(){        mQueue.quit(false);    }        public void quitSafely(){        mQueue.quit(true);    }    public static void prepareMainLooper() {        prepare(false);        synchronized (Looper.class) {            //确保主线程只有一个            if (sMainLooper != null) {                throw new IllegalStateException(\"The main Looper has already been prepared.\");            }            sMainLooper = myLooper();        }    }    public static @Nullable Looper myLooper() {        return sThreadLocal.get();    }    public static void loop() {        final Looper me = myLooper();        if (me == null) {            throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");        }        final MessageQueue queue = me.mQueue;        //无限的去拿消息，防止线程结束        for (;;) {            Message msg = queue.next(); // might block            if (msg == null) {                // No message indicates that the message queue is quitting.                return;            }            try {                msg.target.dispatchMessage(msg);            } catch (Exception exception) {                //捕获异常，防止线程退出            }        }    }}4 Messagepublic final class Message implements Parcelable {    // 用户自定义，主要用于辨别Message的类型    public int what;    // 用于存储一些整型数据    public int arg1;    public int arg2;    // 可放入一个可序列化对象    public Object obj;    // Bundle数据    Bundle data;    // Message处理的时间。开机时间而言的    // 对用户不可见    public long when;    // 处理这个Message的Handler    // 对用户不可见    Handler target;    // 当我们使用Handler的post方法时候就是把runnable对象封装成Message    // 对用户不可见    Runnable callback;    // MessageQueue是一个链表，next表示下一个    // 对用户不可见    Message next;}总结  quit()立即退出，清空所有消息。quitSafely()清除当前时间之后的消息，已到期未执行的继续执行。  Handler的添加Message方法可以把消息添加到头部，也可以添加到末尾或者延时以及添加指定时间的。  Handler中有一个不对外开放的值mAsynchronous，可以设置为true，这个handler发生的都是同步消息了，通过对msg设置一个标志实现的，当然也可以直接调用来使消息为同步消息，当从队列中获取消息时，碰到了target为空的消息则表示开启消息屏障，只处理异步消息。  添加了同步屏障之后，完成了同步消息需要及时移除同步屏障。  Handler中同时持有Looper和MessageQueue对象，用于向队列中添加Message。  因为添加到队列时会设置一个标志，同一个message不能被添加两次，不同的队列也不行。  post方式发送的消息都由Runnable自己处理，message的消息可以由handleMessage以及Handler中的Callback一起处理。  msg中的时间时SystemLock时间，手机开机的时间。  空闲时间执行的IdleHandler，可以通过Looper来获取队列，向队列中添加空闲任务，当队列为空时或没到队列第一个任务执行时间时（即屏障状态下没有异步任务也不会执行），开始执行空闲队列的任务，会一次性执行完空闲列表中的所有当前存在的任务。空闲任务继承至IdleHandler接口，若queueIdle()返回为true则这个任务不主动移除，每次都会执行。  获取消息时最好使用obtain从缓存里面获取，处理完的消息默认都会放入消息缓存，最大容量为50。类似于MessageQueue一样的利用next的链表队列。  当MessageQueue中没有消息时，nativePollOnce会阻塞队列，等待下一个消息的入栈时触发nativeWake唤醒队列。当最近的消息执行时间还未到达时，nativePollOnce会进入超时等待状态。"
  },
  
  {
    "title": "JNI的基础使用",
    "url": "/posts/jni/",
    "categories": "Android",
    "tags": "android, jni",
    "date": "2022-11-11 22:03:00 +0800",
    





    "snippet": "JNI介绍主要使用场景  应用程序需要一些平台相关的feature的支持，而Java无法满足。  兼容以前的用其他语言书写的代码库。使用JNI技术可以让Java层的代码访问到这些旧库，实现一定程度的代码复用。  应用程序的某些关键操作对运行速度要求较高。这部分代码可以用底层语言如汇编写，再通过JNI向 Java层提供访问接口。使用步骤  将需要本地实现的Java方法加上native声明；  使用javac命令编译Java类；  使用javah生成.h头文件；  在本地代码中实现native方法；  编译上述的本地方法，生成动态链接库；  在 Java类中加载这一动态链接库；  Java代码中的其他方法可以正常调用者一native方法。1.主要文件介绍展开可以看到C和Java对应文件的位置，C中文件的注册主要是通过CMake文件来指定的在CMakeLists.txt文件中//引入cpp和h文件add_library( \t//第一个参数就是库的名称,在Java中引入时需要，也对应target_link_libraries的前一个参数    native-lib    SHARED    //cpp文件的相对路径，可以为多个，在同一个library中注册了都才能相互引用    native-lib.cpp)在java引入的类中添加，用于引入上面定义的动态库static {\t//对应上面申明的名字    System.loadLibrary(\"native-lib\");}下面native-lib.cpp中默认生成的C方法extern \"C\" JNIEXPORT jstring JNICALLJava_com_ponovo_jnitest_MainActivity_stringFromJNI(        JNIEnv *env,        jobject /* this */) {    std::string hello = \"Hello from C++\";    return env-&gt;NewStringUTF(hello.c_str());}这是JNI中注册方法的比较固定的写法，对应的是java的native方法，jstring为返回值类型，方法名由Java_包名_类名_方法名 构成，其中点由下划线表示，若方法或路径中存在下划线，则由阿拉伯数字1加下划线表示。然后参数前两个为固定的格式，其中JNIEnv相对于native世界中Java环境的代码，一切Java对象相关的操作都需要依赖于他，而native中的c语言是可以直接使用的。2.java与jni数据类型的对应关系Java中的基础数据类型和String在jni中都有相应的对应，对象统一对应jobject            Java      Jni      Signature                  byte      jbyte      B              char      jchar      C              double      jdouble      D              float      jfloat      F              int      jint      I              short      jshort      S              long      jlong      J              boolean      jboolean      Z              void      void      V              所有对象      jobject      L路径;      Class jclass Ljava/lang/Class;String jstring Ljava/lang/String;Throwable jthrowable Ljava/lang/Throwable;若为数组对象，基础数据类型签名是在前面前面加上[，而对象类型则全部都等同于jobject，例如| Java | Jni | Signature || —  | — |  —      ||int[]| jintArray| [I ||String[]|jobjectArray|[Ljava/lang/String;|注意，对象签名为路径的，后面的分号是不能省略的，与java交互的部分，例如方法的参数和返回值等都需要用对应的jni类型，例如上面的native方法对应java中的为public native String stringFromJNI();public native也是属于类似的固定字段，只需要关注方法特征即可3.字符串的相关操作因为基本数据类型操作都一样的，string稍微特殊一点，所以主要介绍这个，java中的string默认是utf的，所以在把java在jni中jstring转化为c中的变量时，通常就需要使用带有UTF的那个方法，字符串相关方法如下//获取字符串长度jsize GetStringLength(jstring string)//第二个参数接收一个jboolean指针，表示是拷贝一份到本地，还是直接指向Java的数组const char* GetStringUTFChars(jstring string, jboolean* isCopy)//这个方法是获取局部的字符串，start为起始位置，len为长度void GetStringRegion(jstring str, jsize start, jsize len, jchar* buf)//调用前面两个方法之后都需要调用这个来释放，因为操作是在native区域，就和c一样了void ReleaseStringUTFChars(jstring string, const char* utf)//若是C中的字符串要回传给Java，这时需要转化为jstring再使用jstring NewStringUTF(const char* bytes)可以发现jni中的很多对象都可以通过类似的New来生成的4.jni对java类的操作Java的类主要可以分为成员变量和方法，Class包含着类所有的信息，所有要知道一个object对象的变量和方法首先需要获取他的Class信息，对应的就是jclass，可以通过jclass jcls = env-&gt;FindClass(“绝对路径”)的形式获取到public class StringTokObj{\tprivate String str1;\tString str2;\tpublic StringTokObj(String str){\t\tthis.str1 = str;\t}\tpublic String getStr1(){\t\treturn str1;\t}}例如获取StringTokObj的jclass对象就可以表示为jclass jcls = env-&gt;FindClass(\"com/ponovo/jniwork/StringTokObj\");获取到jclass之后便可以通过这个对象去获取成员变量和方法的idjfieldID GetFieldID(jclass clazz, const char* name, const char* sig)上面的方法可以获取到对应成员的id，其中第一个参数为前面获取到的jclass，第二个参数为Java类中这个成员的name字符串，最后一个参数为前面表格中的签名字段例如此处若要获取str1则为：jfieldID str1Id = env-&gt;GetFieldID(strClass, \"str1\", \"Ljava/lang/String;\");当获取到这个成员id时，我们便可以对相应对象的这个成员进行读取或赋值的操作了//赋值void SetObjectField(jobject obj, jfieldID fieldID, jobject value)//读取：jobject GetObjectField(jobject obj, jfieldID fieldID)传入参数的jobject是对应的对象实例，因为是对实例对象的操作注意，这里的因为是对应的String对象，所以使用的是object，需要对返回值强制转换为jstring来使用，而若成员变量为基础数据类型，都会有对应的方法，入参和返回值也为所选类型//如果是基础类型int的话jint GetIntField(jobject obj, jfieldID fieldID)void SetIntField(jobject obj, jfieldID fieldID, jint value)对应的获取方法也是类似的，jmethodID GetMethodID(jclass clazz, const char* name, const char* sig)首先第一个参数仍然和成员变量一样，而第二个参数因为有特殊的构造方法，所以若为构造方法时，则写为”\"（类似于字节码中构造函数一样，需要注意的是AS中这个是会报错，但是可以正常编译使用），其余方法都是按照方法名来写的，对于签名字段来说，因为是方法，所以方法的特征除了方法名还有就是入参以及返回值，所以签名的格式为\" ()V\",括号内为入参的签名，括号后是返回值的签名，若参数为空则不写，若返回值为空则写void对应的签名V，返回参数只能有一个，所以入参存在多个的时候就依次写入，例如int add(int a,int b) 对应的签名就为\" (II)I\"（有点像kotlin的方法写法）注意这里的签名里面是没有空格以及标点符号分割的，所以特殊对象的签名分号也不能省，不然就分辨不清楚了，例如String add(String a,String b)//签名--&gt; \"(Ljava/lang/String; Ljava/lang/String;) Ljava/lang/String;\"若获取到的是构造方法id，则可以用来构造此类的对象，这里一共有三个方法//第三个参数为动态参数列表jobject NewObject(jclass clazz, jmethodID methodID, ...)这里的第三个参数为参数数组jobject NewObjectA(jclass clazz, jmethodID methodID, const jvalue* args)这里的第三个参数为指向列表的指针jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args)//若为一般的方法，则对应的也有三种方法void CallVoidMethod(jobject obj, jmethodID methodID, ...)void CallVoidMethodV(jobject obj, jmethodID methodID, va_list args)void CallVoidMethodA(jobject obj, jmethodID methodID, const jvalue* args)需要注意的是，方法名中的Void也和之前对成员变量的操作类似，方法名中的中间字段对应了这个方法返回值的类型//对于java中的静态的方法和成员，只需要使用对应的带有static参数的方法即可，例如：jint GetStaticIntField(jclass clazz, jfieldID fieldID)jfieldID GetStaticFieldID(jclass clazz, const char* name, const char* sig)void SetStaticObjectField(jclass clazz, jfieldID fieldID, jobject value)当我们需要保存一个传入的object对象以及对应的class之类的信息，就可以使用变量或者结构体来保存，比如struct CallBackStruct {    jobject obj;    jclass clazz;    jmethodID callBack;    jmethodID callBackStr;};static CallBackStruct callBackStruct;需要注意的是，Native方法返回的时候，本地的引用也会随之被JVM虚拟机给回收，所以对于对象类型的保存需要通过这个方法来进行转换为全局引用jobject NewGlobalRef(jobject obj)例如jobject对象以及jclass对象等，但一般的基本数据类型以及jfieldID，jmethodID是不需要转换的当然，转化为全局引用之后以及不属于JVM管理了，所以引用也是需要手动释放的，调用void DeleteGlobalRef(jobject globalRef)5.数组对象的使用对于数组对象的操作，和上面表格一样，主要可以分为两类，一是基础数据类型，还有就是对象类型，基础数据类型都有对应的Array类型，而对象类型都是为jobjectArray类型创建一个jintArray类型的数组，参数为数组长度jintArray NewIntArray(jsize length)获取数组长度都为jsize GetArrayLength(jarray array)获取数组元素首地址，jint* GetIntArrayElements(jintArray array, jboolean* isCopy)// 对应于上一个方法还有其对应的释放的方法，需要对应使用，void ReleaseIntArrayElements(jintArray array, jint* elems,jint mode)// mode = 0 // 原始数据: 对象数组将不会被限制.// 拷贝数据: 数据将会拷贝回原始数据, 同时释放拷贝数据.// mode = JNI_COMMIT// 原始数据: 什么都不作.// 拷贝数据: 数据将会拷贝回原始数据, 不释放拷贝数据.// mode = JNI_ABORT// 原始数据: 对象数组将不会被限制, 之前的数据操作有效// 拷贝数据: 释放拷贝数据, 之前的任何数据操作会丢弃.从jint数组指针复制对应的元素到jintArray中void SetIntArrayRegion(jintArray array, jsize start, jsize len, const jint* buf)对应的获取jintArray的元素到jint数组中void GetIntArrayRegion(jintArray array, jsize start, jsize len, jint* buf)对于对象数组的操作//创建对象数组，elementClass表示创建数组的类型，initialElement表示数组每个元素的初始化值jobjectArray NewObjectArray(jsize length, jclass elementClass, jobject initialElement)//获取对应位置的对象jobject GetObjectArrayElement(jobjectArray array, jsize index)//设置对应位置的对象void SetObjectArrayElement(jobjectArray array, jsize index, jobject value)6.方法总结总的来说，主要是通过Get方法来是java中传过来的数据转化为C中的数据，最后在返回的时候再生成java对应的jni数据类型7.动态注册静态注册是根据方法名将Java方法和JNI函数建立关联的，在初次调用时需要建立native方法和jni方法的关联，影响效率动态注册Jni中有一个结构体定义了native方法与jni方法的关联关系，我们可以通过模仿系统中native方法的注册方式即可typedef struct {    const char* name; //java方法的name    const char* signature; //方法参数和返回值类型    void*       fnPtr; //jni中方法的签名} JNINativeMethod;当java native方法为public native String sayHello(long lo);jni方法为jstring sayHello(JNIEnv *env, jobject, jlong lo)这时注册结构体时就可以写为{\"sayHello\",\"(J)Ljava/lang/String;\", (void *) sayHello}这里的jni方法与java的方法名可以不同，方法签名也与前面获取Java方法的写法是一样的。这里列出动态注册代码基本的注册写在代码中的#ifdef __cplusplusextern \"C\" {#endifstatic const char *dynamicName = \"com/ponovo/jniwork/utils/DynamicLib\";jstring sayHello(JNIEnv *env, jobject, jlong handle) {    return env-&gt;NewStringUTF(\"Hello\");}static const JNINativeMethod gJni_Methods_table[] = {        {\"sayHello\",    \"(J)Ljava/lang/String;\",     (void *) sayHello},};// 注册的部分jint jniRegisterNativeMethods(JNIEnv *env, const char *name,                              const JNINativeMethod *methods, jint nMethods) {    //找到这个类对应的Java的类    jclass jcls = env-&gt;FindClass(name);    if (jcls == nullptr) {        return JNI_FALSE;    }    //注册为native方法的方法，    //第一个是jclass，第二个是JNINativeMethod*，最后一个参数为方法个数    //返回值若成功为JNI_OK值为0，其余所有状态都为小于0的，所以这样判断    if ((env)-&gt;RegisterNatives(jcls, methods, nMethods) &lt; 0) {        return JNI_FALSE;    }    return JNI_TRUE;}//jni部分初始化会调用的方法JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {    JNIEnv *env;    if (vm-&gt;GetEnv(reinterpret_cast&lt;void **&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) {        return JNI_FALSE;    }    jniRegisterNativeMethods(env, dynamicName, gJni_Methods_table,                             sizeof(gJni_Methods_table) / sizeof(JNINativeMethod));    return JNI_VERSION_1_6;}#ifdef __cplusplus}#endif8.旧项目添加ndk支持前面的介绍是重新创建的工程来实现的jni过程，若要给以前的项目增加jni功能，则需要添加相应的文件即可，主要的更改就为图中的两个地方第一个为一个cpp目录以及cpp的文件，定义jni方法的，CMakeLists文件主要定义的是jni方法与java native方法之间的关系，第二个地方是对应项目结构的build.gradle文件，不是主项目的这个文件，这个文件主要是配置编译的环境以及项目的依赖文件，主要新增在android下添加，表明CMake文件路径和使用的版本externalNativeBuild {    cmake {        path \"src/main/cpp/CMakeLists.txt\"        version \"3.10.2\"    }}还可以指定C++使用的版本，在android下的defaultConfig中添加externalNativeBuild {    cmake {        cppFlags \"-std=c++14\"    }}若你之前新建项目时候使用的是default，则这里会是cppFlags “”参考文章本文主要介绍了jni中对java的基本使用，不涉及太过庞大的原理等，主要参考  Android Developers NDK指南  Android JNI(一)——NDK与JNI基础  JNI完全指南(一)——数据类型  配置 CMake"
  },
  
  {
    "title": "Android进程通信",
    "url": "/posts/ipc/",
    "categories": "Android",
    "tags": "ipc",
    "date": "2022-11-11 18:38:00 +0800",
    





    "snippet": "Android多进程为什么要使用多进程      系统为App每一个进程分配的内存是有限的，超过系统分配的内存上限就会出现OOM。        当加载比较大的图片预览时        后台播放音乐  开启多进程模式  单个应用使用多进程只有一种方法，那就是给四大组件在AndroiMenifest中指定android:process属性。另外还有就是可以通过JNI的native层去fork一个新的进程。  如果没有特别的指定运行的进程，那么运行的进程名字为自己的包名  若设置android:process=\":remote\",”:”的含义是指要在当前的进程名前加上当前的包名，则进程名为 &lt;package&gt;:remote,并且以”:”开头的进程属于当前应用的私有进程。  若设置为别的形式，例如com.jiangker.process，则这种进程为全局进程，其他应用可以通过ShareUID的方式可以和它跑到同一个进程中。Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。多进程带来的问题1 静态成员和单例模式完全失效因为Android系统给每一个应用都分配了一个独立的虚拟机，所以内存空间是不相同的，所以不能通过内存来共享数据。2 线程同步机制完全失效线程中的同步机制作用于的是同一个对象，因为不是在一个进程中了，对象也不相同了，所以不能使用3 SharedPreferences的可靠性下降SharedPreferences不支持多个进程去同时读写xml文件，否则会导致一定几率的数据丢失。4 Application会多次创建多进程的通信方式Linux经典进程间通信方式  共享内存（Shared Memory）  管道（Pipe）  UNIX Domain SocketAndroid中常用进程通信方式  Intent 、Bundle ：要求传递数据能被序列化，实现 Parcelable、Serializable ，适用于四大组件通信。  文件共享 ：适用于交换简单的数据实时性不高的场景。  AIDL：AIDL 接口实质上是系统提供给我们可以方便实现 BInder 的工具。  Messenger：基于 AIDL 实现，服务端串行处理，主要用于传递消息，适用于低并发一对多通信。  ContentProvider：基于 Binder 实现，适用于一对多进程间数据共享。（通讯录 短信 等）  Socket：TCP、UDP，适用于网络数据交换Binder的通信过程  server在SM容器中注册、  Client若要调用Server的add方法，就需要先获取server对象，但是SM不会把真正的server对象返回给Client，而是把Server的一个代理对象Proxy返回给Client。  Client调用Proxy的add方法，ServiceManager会帮它去调用Server的add方法，并把结果返回给ClientAIDL跨进程通信1 默认支持的数据类型  Java中的八种基本数据类型，包括 byte，short，int，long，float，double，boolean，char。  String类型和CharSequence类型。  List类型：只支持ArrayList，里面的每个元素都必须要被AIDL支持；  Map类型：只支持HashMap，里面的每个元素都必须要被AIDL支持，包括key和value；  Parcelable：所有实现了Parcelable接口的对象；  AIDL：所有的AIDL接口本身也可以在AIDL文件中使用  其中自定义的Parcelable对象和AIDL对象必须要显示的import进来2 in out inout的区别AIDL中的定向 tag 表示了在跨进程通信中数据的流向，其中in表示数据只能由客户端流向服务端，out表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。in 为定向 tag 的话表现为服务端将会接收到一个那个对象的完整数据，但是客户端的那个对象不会因为服务端对传参的修改而发生变动；out 的话表现为服务端将会接收到那个对象的参数为空的对象，但是在服务端对接收到的空对象有任何修改之后客户端将会同步变动；inout 为定向 tag 的情况下，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。3 使用示例3.1 AIDL文件的定义aidl文件路径下//Book.aidlpackage com.jiangker.testitem.lib;parcelable Book;对应java文件路径下//Book.javapackage com.jiangker.testitem.libimport android.os.Parcelimport android.os.Parcelable class Book(    var name: String?,    var price: Int) : Parcelable {    constructor(parcel: Parcel) : this(        parcel.readString(),        parcel.readInt()    )    override fun writeToParcel(parcel: Parcel, flags: Int) {        parcel.writeString(name)        parcel.writeInt(price)    }    override fun describeContents(): Int {        return 0    }    companion object CREATOR : Parcelable.Creator&lt;Book&gt; {        override fun createFromParcel(parcel: Parcel): Book {            return Book(parcel)        }        override fun newArray(size: Int): Array&lt;Book?&gt; {            return arrayOfNulls(size)        }    }}AIDL接口定义//IBookManager.aidlpackage com.jiangker.testitem.lib;import com.jiangker.testitem.lib.Book;interface IBookManager{    List&lt;Book&gt; getBookList();    void addBook(in Book book);}3.2 Server端class MainService : Service() {    private val bookLists = ArrayList&lt;Book&gt;()    private val manager = object : IBookManager.Stub() {        override fun addBook(book: Book) {            bookLists.add(book)        }        override fun getBookList(): MutableList&lt;Book&gt; {            return bookLists        }    }    override fun onBind(intent: Intent) = manager}3.3 Client端class MainActivity : AppCompatActivity() {    private var bookService: IBookManager? = null    private val connection = object : ServiceConnection {        override fun onServiceDisconnected(name: ComponentName?) {        }        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {            bookService = IBookManager.Stub.asInterface(service)        }    }    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        val binding =            DataBindingUtil.setContentView&lt;ActivityMainBinding&gt;(this, R.layout.activity_main)        //绑定服务        bindService(Intent(this,MainService::class.java),connection,Context.BIND_AUTO_CREATE)        binding.apply {            btnInsert.setOnClickListener                 val book = Book(\"jiangker ${SystemClock.uptimeMillis()}\", 528)                bookService?.addBook(book)                Log.i(TAG, \"addBook $book - ${book.hashCode()}\")            }            btnQuery.setOnClickListener {                bookService?.bookList?.forEachIndexed {index,book -&gt;                    Log.i(TAG, \"list index: $index : - : $book - ${book.hashCode()}\")                }            }        }    }}对应的生成的Java文件public interface IBookManager extends IInterface{    /** server端继承的抽象类*/    public static abstract class Stub extends Binder implements IBookManager    {        //binder的唯一标识        private static final String DESCRIPTOR = \"com.jiangker.testitem.lib.IBookManager\";        public Stub() {            this.attachInterface(this, DESCRIPTOR);        }        /**         * 判断IBinder对象是否和自己处于同一进程，如果是就直接使用，否则把服务端的IBinder包装为一个客户端所需的AIDL接口的Proxy代理对象         */        public static IBookManager asInterface(IBinder obj) {            if ((obj==null)) {                return null;            }            IInterface iin = obj.queryLocalInterface(DESCRIPTOR);            if (((iin!=null)&amp;&amp;(iin instanceof IBookManager))) {                return ((IBookManager)iin);            }            return new IBookManager.Stub.Proxy(obj);        }        //返回当前Binder对象        @Override        public IBinder asBinder() {            return this;        }        /**         * 接收客户端传递过来的数据。运行在服务端中的Binder线程池中，当客户端发起请求时，远程请求会通过系统底层封装后交由此方法来处理         */        @Override        public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {            String descriptor = DESCRIPTOR;            switch (code)            {                case INTERFACE_TRANSACTION:                {                    reply.writeString(descriptor);                    return true;                }                case TRANSACTION_getBookList:                {                    data.enforceInterface(descriptor);                    List&lt;Book&gt; _result = this.getBookList();                    reply.writeNoException();                    reply.writeTypedList(_result);                    return true;                }                case TRANSACTION_addBook:                {                    data.enforceInterface(descriptor);                    Book _arg0;                    if ((0!=data.readInt())) {                        _arg0 = Book.CREATOR.createFromParcel(data);                    }                    else {                        _arg0 = null;                    }                    this.addBook(_arg0);                    reply.writeNoException();                    return true;                }                case TRANSACTION_registerListener:                {                    data.enforceInterface(descriptor);                    IOnNewBookArrivedListener _arg0;                    _arg0 = IOnNewBookArrivedListener.Stub.asInterface(data.readStrongBinder());                    this.registerListener(_arg0);                    reply.writeNoException();                    return true;                }                case TRANSACTION_unRegisterListener:                {                    data.enforceInterface(descriptor);                    IOnNewBookArrivedListener _arg0;                    _arg0 = IOnNewBookArrivedListener.Stub.asInterface(data.readStrongBinder());                    this.unRegisterListener(_arg0);                    reply.writeNoException();                    return true;                }                default:                {                    return super.onTransact(code, data, reply, flags);                }            }        }        private static class Proxy implements IBookManager        {            private IBinder mRemote;            Proxy(IBinder remote)            {                mRemote = remote;            }            @Override             public IBinder asBinder() {                return mRemote;            }            public String getInterfaceDescriptor() {                return DESCRIPTOR;            }            //运行在客户端，会把该方法的信息参数打包发给server端，等待方法返回            @Override             public List&lt;Book&gt; getBookList() throws RemoteException {                //把要传递的数据写入_data                Parcel _data = Parcel.obtain();                //把要接收的函数返回值写入_reply                Parcel _reply = Parcel.obtain();                List&lt;Book&gt; _result;                try {                    _data.writeInterfaceToken(DESCRIPTOR);                    //最后使用transact方法，就可以把数据传递给Binder的server端了                    boolean _status = mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);                    if (!_status &amp;&amp; getDefaultImpl() != null) {                        return getDefaultImpl().getBookList();                    }                    _reply.readException();                    _result = _reply.createTypedArrayList(Book.CREATOR);                }                finally {                    _reply.recycle();                    _data.recycle();                }                return _result;            }            @Override public void addBook(Book book) throws RemoteException            {                Parcel _data = Parcel.obtain();                Parcel _reply = Parcel.obtain();                try {                    _data.writeInterfaceToken(DESCRIPTOR);                    if ((book!=null)) {                        _data.writeInt(1);                        book.writeToParcel(_data, 0);                    }                    else {                        _data.writeInt(0);                    }                    boolean _status = mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);                    if (!_status &amp;&amp; getDefaultImpl() != null) {                        getDefaultImpl().addBook(book);                        return;                    }                    _reply.readException();                }                finally {                    _reply.recycle();                    _data.recycle();                }            }            @Override public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException            {                Parcel _data = Parcel.obtain();                Parcel _reply = Parcel.obtain();                try {                    _data.writeInterfaceToken(DESCRIPTOR);                    _data.writeStrongBinder((((listener!=null))?(listener.asBinder()):(null)));                    boolean _status = mRemote.transact(Stub.TRANSACTION_registerListener, _data, _reply, 0);                    if (!_status &amp;&amp; getDefaultImpl() != null) {                        getDefaultImpl().registerListener(listener);                        return;                    }                    _reply.readException();                }                finally {                    _reply.recycle();                    _data.recycle();                }            }            @Override public void unRegisterListener(IOnNewBookArrivedListener listener) throws RemoteException            {                Parcel _data = Parcel.obtain();                Parcel _reply = Parcel.obtain();                try {                    _data.writeInterfaceToken(DESCRIPTOR);                    _data.writeStrongBinder((((listener!=null))?(listener.asBinder()):(null)));                    boolean _status = mRemote.transact(Stub.TRANSACTION_unRegisterListener, _data, _reply, 0);                    if (!_status &amp;&amp; getDefaultImpl() != null) {                        getDefaultImpl().unRegisterListener(listener);                        return;                    }                    _reply.readException();                }                finally {                    _reply.recycle();                    _data.recycle();                }            }            public static IBookManager sDefaultImpl;        }        static final int TRANSACTION_getBookList = (IBinder.FIRST_CALL_TRANSACTION + 0);        static final int TRANSACTION_addBook = (IBinder.FIRST_CALL_TRANSACTION + 1);        static final int TRANSACTION_registerListener = (IBinder.FIRST_CALL_TRANSACTION + 2);        static final int TRANSACTION_unRegisterListener = (IBinder.FIRST_CALL_TRANSACTION + 3);        public static boolean setDefaultImpl(IBookManager impl) {            if (Stub.Proxy.sDefaultImpl == null &amp;&amp; impl != null) {                Stub.Proxy.sDefaultImpl = impl;                return true;            }            return false;        }        public static IBookManager getDefaultImpl() {            return Stub.Proxy.sDefaultImpl;        }    }    public List&lt;Book&gt; getBookList() throws RemoteException;    public void addBook(Book book) throws RemoteException;    public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException;    public void unRegisterListener(IOnNewBookArrivedListener listener) throws RemoteException;}  Stub继承至binder，需要由提供服务的一方实现，最后返回binder对象给SM  Proxy是接口的代理，当Client通过asInterface(IBinder)去获取接口对象时，在同一进程会直接返回实际对象，若不在同一进程就会返回服务端Proxy的代理对象，Proxy是组合模式，会持有远程Binder的引用。  当调用server的方法时，会把数据进行序列化，然后调用远程binder的transact方法来把数据写入，如何阻塞等待server的结果返回。  当方法进行调用时，服务端的onTransact方法会被执行，然后根据code去解析参数然后再调用具体的方法实现，最后再把返回结果写入返回。  binder的线程都为子线程。binder的调用可以在主线程执行，会阻塞等待结果返回。死亡代理binder提供两个方法，通过linkToDeath就可以给Binder设置一个死亡代理，在Binder死亡时通知我们，这个触发是在客户端的Binder线程池里面的，不可以进行UI操作//定义死亡代理private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() {    @Override    public void binderDied() {        if (bookServer == null) return;        bookServer.asBinder().unlinkToDeath(mDeathRecipient,0);        bookServer = null;//            binderServer();    }};//设置绑定private ServiceConnection connection = new ServiceConnection{    @Override    public void onServiceDisConnected(ComponentName name){}        @Override    public void onServiceConnected(ComponentName name,IBinder service){        service.linkToDeath(mDeathRecipient,0)    }}也可以在onServiceDisConnected中进行重连操作，这个是主线程中触发的权限校验在服务端定义权限&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"com.example.sourcecode\"&gt;    &lt;permission android:name=\"com.jinagker.permission.Test\"        android:protectionLevel=\"normal\"/&gt;&lt;/manifest&gt;可以在两个地方进行拦截  onBind方法处（使用Context类的checkCallingOrSelfPermission(String permission)方法）     override fun onBind(intent: Intent): IBinder? {     val result =         checkCallingOrSelfPermission(\"com.jinagker.permission.Test\")     if (result == PackageManager.PERMISSION_DENIED) return null     return messageManager.binder }        使用，需要申明权限     &lt;uses-permission android:name=\"com.jinagker.permission.Test\"/&gt;            在服务端的onTransact中进行验证（重写服务端的onTransact方法，校验失败返回false）     val server = object : ISaveSp.Stub() {     override fun onTransact(code: Int, data: Parcel, reply: Parcel?, flags: Int): Boolean {         val result =             checkCallingOrSelfPermission(\"com.jinagker.permission.Test\")         if (result == PackageManager.PERMISSION_DENIED) return false         return super.onTransact(code, data, reply, flags)     } }        直接在服务端属性处增加android:poermission，没有申明的onServiceConnected不会有返回Messenger方式Messenger其实也是对Binder的一种封装，结合handler的方式，使用message来携带消息。public Messenger(Handler target) {    mTarget = target.getIMessenger();}public Messenger(IBinder target) {    mTarget = IMessenger.Stub.asInterface(target);}使用private val messenger = Messenger(MessengerHandler())override fun onBind(intent: Intent): IBinder {    return messenger.binder}class MessengerHandler : Handler(Looper.getMainLooper()) {    override fun handleMessage(msg: Message) {        when (msg.what) {            MessengerActivity.CLIENT_MSG -&gt; {                // replyTo也是一个messenger对象                val client = msg.replyTo                val message = Message.obtain(null, SERVER_MSG)                val bundle = Bundle()                bundle.putParcelable(\"bitmap\", Bitmap.createBitmap(1000, 1000, Bitmap.Config.ARGB_8888))                message.data = bundle                client.send(message)            }            else -&gt; super.handleMessage(msg)        }    }}跨进程传递大图片  对于如果图片本为本地图片的，可以直接传递文件路径。  若是下载到内存中的图片，写入储存再传递路径，再在另外的进程读取，这样的方式性能很低。  使用Socket、管道等方式需要两次拷贝，从用户空间到内核空间，再从内核空间到用户空间。  使用binder若使用intent传递数据，数据量比较大时，会抛出异常val intent = Intent(this, PoolService::class.java)intent.putExtra(\"bitmap\",Bitmap.createBitmap(1000, 1000, Bitmap.Config.ARGB_8888))bindService(intent, connection, Context.BIND_AUTO_CREATE)正常情况推荐使用intent的putBinder方式来传递，然后通过binder中的bitmap方法传递数据package cn.jiangker.android.ipc.pool;import android.graphics.Bitmap;interface BitmapTranslate{    void translate(in Bitmap origin);}大致原因为intent方式传递时，系统会禁止掉文件引用符的传递方式，强制走序列化和反序列化流程。而使用binder传递时，若文件大于16kb时，会开辟一个匿名共享内存，无需拷贝，提高传递效率。参考  Android中怎么跨进程传输大图片  面试官：跨进程如何传递大图？又蒙圈了……代码地址https://gitlab.jiangker.cn/jiangker/androidipc"
  },
  
  {
    "title": "View的事件分发机制",
    "url": "/posts/dispatch-touch-event/",
    "categories": "Android",
    "tags": "view",
    "date": "2022-11-01 23:38:00 +0800",
    





    "snippet": "点击事件的传递规则  源码使用Android32当我们电机屏幕时，就产生了点击事件，这个点击事件会被封装成MotionEvent，然后由系统传递给View的层级，MotionEvent在View中的层级传递过程就是点击事件分发。事件分发中最重要的方法有如下三个：      boolean dispatchTouchEvent(MotionEvent event)用来进行事件的分发。如果事件能够传递给当前的View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示当前View是否消费当前事件。        boolean onInterceptTouchEvent(MotionEvent ev)在dispatchTouchEvent()内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一事件序列中，此方法不会被再次调用，返回结果表示是否拦截当前事件。        boolean onTouchEvent(MotionEvent event)在dispatchTouchEvent()方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前view无法再次接受到事件。  View的事件分发机制当事件产生后，事件首先会传递给当前的Activity，这就会触发Activity的dispatchTouchEvent()方法// Activity.java/**    * Called to process touch screen events.  You can override this to    * intercept all touch screen events before they are dispatched to the    * window.  Be sure to call this implementation for touch screen events    * that should be handled normally.    * @param ev The touch screen event.    * @return boolean Return true if this event was consumed.    */public boolean dispatchTouchEvent(MotionEvent ev) {    if (ev.getAction() == MotionEvent.ACTION_DOWN) {        onUserInteraction();    }    if (getWindow().superDispatchTouchEvent(ev)) {        return true;    }    return onTouchEvent(ev);}当Activity接收到事件后，会把事件传递给Window来处理，众所周知Window只有一个实现类是PhoneWindow// PhoneWindow.java@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) {    return mDecor.superDispatchTouchEvent(event);}// DecorView.javapublic boolean superDispatchTouchEvent(MotionEvent event) {    return super.dispatchTouchEvent(event);}PhoneWindow直接又把事件传递给DecorView，而DecorView又是继承至FrameLayout(ViewGroup)即调用到的是ViewGroup的dispatchTouchEvent()方法。// ViewGroup.java@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) {    // ...    boolean handled = false;    if (onFilterTouchEventForSecurity(ev)) {        final int action = ev.getAction();        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;        // 如果是DOWN事件，进行初始化        if (actionMasked == MotionEvent.ACTION_DOWN) {            cancelAndClearTouchTargets(ev);            resetTouchState();        }        // Check for interception.        final boolean intercepted;        // mFirstTouchTarget为空，表示没有可以接收事件的子view        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {            // 根据标志判断子view是否禁止自身拦截            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;            if (!disallowIntercept) {                intercepted = onInterceptTouchEvent(ev);                ev.setAction(action); // restore action in case it was changed            } else {                intercepted = false;            }        } else {            // 在除DOWN事件以外的事件时，若没有子View接收事件，则设置为true            intercepted = true;        }        // Check for cancelation.        final boolean canceled = resetCancelNextUpFlag(this)                || actionMasked == MotionEvent.ACTION_CANCEL;        // Update list of touch targets for pointer down, if needed.        final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE;        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0                &amp;&amp; !isMouseEvent;        TouchTarget newTouchTarget = null;        boolean alreadyDispatchedToNewTouchTarget = false;        if (!canceled &amp;&amp; !intercepted) {                removePointersFromTouchTargets(idBitsToAssign);                final int childrenCount = mChildrenCount;                if (newTouchTarget == null &amp;&amp; childrenCount != 0) {                    final float x =                            isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);                    final float y =                            isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);                    final View[] children = mChildren;                    // 倒序遍历，后添加的View在上层位置，优先考虑处理                    for (int i = childrenCount - 1; i &gt;= 0; i--) {                        newTouchTarget = getTouchTarget(child);                        if (newTouchTarget != null) {                            newTouchTarget.pointerIdBits |= idBitsToAssign;                            break;                        }                        resetCancelNextUpFlag(child);                        if (dispatchTransformedTouchEvent(ev, false, child,idBitsToAssign)) {                            // Child wants to receive touch within its bounds.                            mLastTouchDownTime = ev.getDownTime();                            if (preorderedList != null) {                                // childIndex points into presorted list, find original index                                for (int j = 0; j &lt; childrenCount; j++) {                                    if (children[childIndex] == mChildren[j]) {                                        mLastTouchDownIndex = j;                                        break;                                    }                                }                            } else {                                mLastTouchDownIndex = childIndex;                            }                            mLastTouchDownX = ev.getX();                            mLastTouchDownY = ev.getY();                            newTouchTarget = addTouchTarget(child, idBitsToAssign);                            alreadyDispatchedToNewTouchTarget = true;                            break;                        }                        // The accessibility focus didn't handle the event, so clear                        // the flag and do a normal dispatch to all children.                        ev.setTargetAccessibilityFocus(false);                    }                    if (preorderedList != null) preorderedList.clear();                }                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {                    // Did not find a child to receive the event.                    // Assign the pointer to the least recently added target.                    newTouchTarget = mFirstTouchTarget;                    while (newTouchTarget.next != null) {                        newTouchTarget = newTouchTarget.next;                    }                    newTouchTarget.pointerIdBits |= idBitsToAssign;                }            }        }        // Dispatch to touch targets.        if (mFirstTouchTarget == null) {            // No touch targets so treat this as an ordinary view.            handled = dispatchTransformedTouchEvent(ev, canceled, null,                    TouchTarget.ALL_POINTER_IDS);        } else {            // Dispatch to touch targets, excluding the new touch target if we already            // dispatched to it.  Cancel touch targets if necessary.            TouchTarget predecessor = null;            TouchTarget target = mFirstTouchTarget;            while (target != null) {                final TouchTarget next = target.next;                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {                    handled = true;                } else {                    final boolean cancelChild = resetCancelNextUpFlag(target.child)                            || intercepted;                    if (dispatchTransformedTouchEvent(ev, cancelChild,                            target.child, target.pointerIdBits)) {                        handled = true;                    }                    if (cancelChild) {                        if (predecessor == null) {                            mFirstTouchTarget = next;                        } else {                            predecessor.next = next;                        }                        target.recycle();                        target = next;                        continue;                    }                }                predecessor = target;                target = next;            }        }        // Update list of touch targets for pointer up or cancel, if needed.        if (canceled                || actionMasked == MotionEvent.ACTION_UP                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {            resetTouchState();        } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {            final int actionIndex = ev.getActionIndex();            final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);            removePointersFromTouchTargets(idBitsToRemove);        }    }    if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) {        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);    }    return handled;}事件序列都是以DOWN开始，UP结束。所以当DOWN事件来临时，会初始化相应的一些状态。然后会去调用onInterceptTouchEvent()方法看是否拦截事件。若不拦截的情况下，就会去for循环遍历子View，判断子View是否可以接收到点击事件，若子View可以处理点击事件，则由子View来处理。for循环为倒序遍历的，相当于从上层View开始往下层遍历。接收事件的View需要满足点击位置需要在View上且View不能处于播放动画中。其中有一个比较关键的方法dispatchTransformedTouchEvent()，用来调用子View的dispatchTouchEvent()方法或者当没有子View能够处理时调用自己的super.dispatchTouchEvent()尝试自己处理事件。// ViewGroup.javapublic boolean onInterceptTouchEvent(MotionEvent ev) {    if (ev.isFromSource(InputDevice.SOURCE_MOUSE)            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) {        return true;    }    return false;}这个方法多用于自定义ViewGroup时拦截传达给子View的事件来起到解决滑动冲突的问题。// ViewGroup.javaprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,        View child, int desiredPointerIdBits) {    final boolean handled;    // cancel为true时，更改事件属性，传递cancel事件，当父view不再向他发送事件时会产生    final int oldAction = event.getAction();    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {        event.setAction(MotionEvent.ACTION_CANCEL);        if (child == null) {            handled = super.dispatchTouchEvent(event);        } else {            handled = child.dispatchTouchEvent(event);        }        event.setAction(oldAction);        return handled;    }    // Calculate the number of pointers to deliver.    final int oldPointerIdBits = event.getPointerIdBits();    final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;    // If for some reason we ended up in an inconsistent state where it looks like we    // might produce a motion event with no pointers in it, then drop the event.    if (newPointerIdBits == 0) {        return false;    }    // If the number of pointers is the same and we don't need to perform any fancy    // irreversible transformations, then we can reuse the motion event for this    // dispatch as long as we are careful to revert any changes we make.    // Otherwise we need to make a copy.    final MotionEvent transformedEvent;    if (newPointerIdBits == oldPointerIdBits) {        if (child == null || child.hasIdentityMatrix()) {            if (child == null) {                handled = super.dispatchTouchEvent(event);            } else {                final float offsetX = mScrollX - child.mLeft;                final float offsetY = mScrollY - child.mTop;                event.offsetLocation(offsetX, offsetY);                handled = child.dispatchTouchEvent(event);                event.offsetLocation(-offsetX, -offsetY);            }            return handled;        }        transformedEvent = MotionEvent.obtain(event);    } else {        transformedEvent = event.split(newPointerIdBits);    }    // Perform any necessary transformations and dispatch.    if (child == null) {        handled = super.dispatchTouchEvent(transformedEvent);    } else {        final float offsetX = mScrollX - child.mLeft;        final float offsetY = mScrollY - child.mTop;        transformedEvent.offsetLocation(offsetX, offsetY);        if (! child.hasIdentityMatrix()) {            transformedEvent.transform(child.getInverseMatrix());        }        handled = child.dispatchTouchEvent(transformedEvent);    }    // Done.    transformedEvent.recycle();    return handled;}dispatchTransformedTouchEvent()方法主要用来处理传递给自身或者传递给子View的事件。// View.javapublic boolean dispatchTouchEvent(MotionEvent event) {    boolean result = false;    final int actionMasked = event.getActionMasked();    if (actionMasked == MotionEvent.ACTION_DOWN) {        // Defensive cleanup for new gesture        stopNestedScroll();    }    if (onFilterTouchEventForSecurity(event)) {        if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) {            result = true;        }        //noinspection SimplifiableIfStatement        ListenerInfo li = mListenerInfo;        if (li != null &amp;&amp; li.mOnTouchListener != null                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {                // 当设置了mOnTouchListener并返回了true之后，表示事件已经被处理            result = true;        }        // onTouchEvent中会去触发click事件        if (!result &amp;&amp; onTouchEvent(event)) {            result = true;        }    }    if (!result &amp;&amp; mInputEventConsistencyVerifier != null) {        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);    }    // Clean up after nested scrolls if this is the end of a gesture;    // also cancel it if we tried an ACTION_DOWN but we didn't want the rest    // of the gesture.    if (actionMasked == MotionEvent.ACTION_UP ||            actionMasked == MotionEvent.ACTION_CANCEL ||            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) {        stopNestedScroll();    }    return result;}在View的dispatchTouchEvent()中，首先会去判断是否设置了mOnTouchListener，若设置并返回true，则onTouchEvent()不会再被调用// View.javapublic boolean onTouchEvent(MotionEvent event) {    final float x = event.getX();    final float y = event.getY();    final int viewFlags = mViewFlags;    final int action = event.getAction();    final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;    if ((viewFlags &amp; ENABLED_MASK) == DISABLED            &amp;&amp; (mPrivateFlags4 &amp; PFLAG4_ALLOW_CLICK_WHEN_DISABLED) == 0) {        if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) {            setPressed(false);        }        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;        // A disabled view that is clickable still consumes the touch        // events, it just doesn't respond to them.        return clickable;    }    if (mTouchDelegate != null) {        if (mTouchDelegate.onTouchEvent(event)) {            return true;        }    }    if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) {        switch (action) {            case MotionEvent.ACTION_UP:                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;                if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {                        // This is a tap, so remove the longpress check                        removeLongPressCallback();                        // Only perform take click actions if we were in the pressed state                        if (!focusTaken) {                            // Use a Runnable and post this rather than calling                            // performClick directly. This lets other visual state                            // of the view update before click actions start.                            if (mPerformClick == null) {                                mPerformClick = new PerformClick();                            }                            if (!post(mPerformClick)) {                                performClickInternal();                            }                        }                    }                }                break;            case MotionEvent.ACTION_DOWN:                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;                }                mHasPerformedLongPress = false;                if (!clickable) {                    checkForLongClick(                            ViewConfiguration.getLongPressTimeout(),                            x,                            y,                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);                    break;                }                if (performButtonActionOnTouchDown(event)) {                    break;                }                // Walk up the hierarchy to determine if we're inside a scrolling container.                boolean isInScrollingContainer = isInScrollingContainer();                // For views inside a scrolling container, delay the pressed feedback for                // a short period in case this is a scroll.                if (isInScrollingContainer) {                    mPrivateFlags |= PFLAG_PREPRESSED;                    if (mPendingCheckForTap == null) {                        mPendingCheckForTap = new CheckForTap();                    }                    mPendingCheckForTap.x = event.getX();                    mPendingCheckForTap.y = event.getY();                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());                } else {                    // Not inside a scrolling container, so show the feedback right away                    setPressed(true, x, y);                    checkForLongClick(                            ViewConfiguration.getLongPressTimeout(),                            x,                            y,                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);                }                break;        }        return true;    }    return false;}在onTouchEvent()的UP事件中会使用mPerformClick触发click事件。若设置了View是可点击的，则onTouchEvent()都会返回true.// View.javapublic boolean post(Runnable action) {    final AttachInfo attachInfo = mAttachInfo;    if (attachInfo != null) {        return attachInfo.mHandler.post(action);    }    // Postpone the runnable until we know on which thread it needs to run.    // Assume that the runnable will be successfully placed after attach.    getRunQueue().post(action);    return true;}private boolean performClickInternal() {    notifyAutofillManagerOnClick();    return performClick();}public boolean performClick() {    notifyAutofillManagerOnClick();    final boolean result;    final ListenerInfo li = mListenerInfo;    if (li != null &amp;&amp; li.mOnClickListener != null) {        playSoundEffect(SoundEffectConstants.CLICK);        // 触发点击事件        li.mOnClickListener.onClick(this);        result = true;    } else {        result = false;    }    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);    notifyEnterOrExitForAutoFillIfNeeded(true);    return result;}UP事件会先post到handler中，然后最后由handler来触发performClick()完成点击事件的调用。点击事件分发的伪代码示例public boolean dispatchTouchEvent(MotionEvent ev) {    boolean consume = false;    if(onInterceptTouchEvent(ev)) {        consume = onTouchEvent(ev);    } else {        consume = child.dispatchTouchEvent(ev);    }    return consume;}参考  Android开发艺术探索  Android进阶之光"
  },
  
  {
    "title": "PWM 舵机控制",
    "url": "/posts/pwm_control/",
    "categories": "hardware",
    "tags": "pwm",
    "date": "2022-10-03 18:00:00 +0800",
    





    "snippet": "PWM控制舵机简介通常情况下，伺服电机（舵机）是由一个标准的直流系统和一个内部反馈控制装置（一个减速齿轮和电位计）来组成的。伺服电机（舵机）的主要作用是将齿轮轴旋转到一个预定义的方向上。伺服电机（舵机）有3个输入引脚，GND、VCC和Signal。脉冲宽度调制技术（PWM）被应用于舵机的控制，轴的方向由脉冲的持续时间决定（参见树莓派3 B+Servoblaster 舵机控制，了解更多关于PWM的信息）。需要记住的是，舵机转动的方向不是由占空比决定的，而是由脉冲长度 t 决定的。有的舵机使用的PWM频率为 fPWM=50HZ，其对应于的PWM周期 T=20 ms。脉冲长度 t 和转动方向之间的关系是线性的，但也取决于电机和齿轮的配合。对于常见的SG90舵机，其角度与脉冲对应长度关系如上图。常见的三根信号线如下：树莓派引脚树莓派控制舵机0度：0.5 / 20 = 2.5%180度：2.5 / 20 = 12.5%任意角度：2.5 + i / 180 * 20特殊电平与电压对应关系# 0 vp.ChangeDutyCycle(0)# 0.67 vp.ChangeDutyCycle(20)# 3.3 vp.ChangeDutyCycle(100)控制舵机180度来回import RPi.GPIO as GPIOimport timeimport atexitatexit.register(GPIO.cleanup)servopin = 21GPIO.setmode(GPIO.BCM)GPIO.setup(servopin, GPIO.OUT, initial=False)p = GPIO.PWM(servopin, 50)p.start(0)time.sleep(2)while True:    for i in range(0, 181, 10):        p.ChangeDutyCycle(2.5 + 20 * i / 180)        time.sleep(0.02)    for i in range(181, 0, -10):        p.ChangeDutyCycle(2.5 + 20 * i / 180)        time.sleep(0.02)"
  },
  
  {
    "title": "Applink跳转",
    "url": "/posts/applink/",
    "categories": "Android",
    "tags": "applink",
    "date": "2022-09-10 20:00:00 +0800",
    





    "snippet": "为传入链接添加 intent 过滤器  可以为URI指定首选应用，当在浏览器中点击链接时，Android系统可以选择直接打开App定位对应页面。官方案例中XML配置如下&lt;activity    android:name=\"com.example.android.GizmosActivity\"    android:label=\"@string/title_gizmos\" &gt;    &lt;intent-filter android:label=\"@string/filter_view_http_gizmos\"&gt;        &lt;action android:name=\"android.intent.action.VIEW\" /&gt;        &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;        &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;        &lt;!-- Accepts URIs that begin with \"http://www.example.com/gizmos” --&gt;        &lt;data android:scheme=\"http\"                android:host=\"www.example.com\"                android:pathPrefix=\"/gizmos\" /&gt;        &lt;!-- note that the leading \"/\" is required for pathPrefix--&gt;    &lt;/intent-filter&gt;    &lt;intent-filter android:label=\"@string/filter_view_example_gizmos\"&gt;        &lt;action android:name=\"android.intent.action.VIEW\" /&gt;        &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;        &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;        &lt;!-- Accepts URIs that begin with \"example://gizmos” --&gt;        &lt;data android:scheme=\"example\"                android:host=\"gizmos\" /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;这几个属性都是必须要的，其中category中android.intent.category.BROWSABLE表示如果需要从网络浏览器中访问intent过滤器，才有可能点击链接时才能链接到对应应用。以上两组intent过滤器唯一区别都在data上，是因为当同一个intent目录下，若出现多组data，其scheme和host属性是会进行组合，形成更多组的组合情况。例如：&lt;intent-filter&gt;    ...    &lt;data android:scheme=\"https\" android:host=\"www.example.com\" /&gt;    &lt;data android:scheme=\"app\" android:host=\"open.my.app\" /&gt;&lt;/intent-filter&gt;对应的组合就会支持https://www.example.com、app://open.my.app、app://www.example.com和https://open.my.app这四种情况的链接。配置应用链接若想使浏览器中的uri可以正确跳转到对应的app，还需要在对应域名网站的对应URL下托管一下json文件，声明网站链接与app之间的关系。尽管data中可能配置的scheme为http链接，但这里的网址必须要为https的。https://domain.name/.well-known/assetlinks.json例如https://static.jiangker.cn/.well-known/assetlinks.json在json文件中添加[    {        \"relation\": [            \"delegate_permission/common.handle_all_urls\"        ],        \"target\": {            \"namespace\": \"android_app\",            \"package_name\": \"cn.jiangker.jrouter\",            \"sha256_cert_fingerprints\": [                \"16:C6:BF:9D:66:E5:D5:93:2E:2A:53:31:C7:1F:8A:BE:E3:8A:D4:CF:C6:9F:10:ED:B9:2F:71:11:D4:E6:11:43\"            ]        }    }]此json文件的生成可以使用Statement List Generator and Tester来生成，并测试能否正确配置网站。生成json文件需要获取app的sha256，可以使用./gradlew signingReport命令来生成AS配置intent以及生成json文件intent的配置以及json文件的生成都可以由AS来完成，在Tools -&gt; App Links Assistant来完成我目前AS的Associate website有一点问题，所以不在这里演示了。adb测试链接支持情况adb shell dumpsys package domain-preferred-apps// oradb shell dumpsys package d在Android11以及之前App verification status:    Package: cn.jiangker.jrouter    Domains: static.jiangker.cn    Status:  always : 20000000b读取传入的intent当通过url跳转到app之后，可以通过intent来获取对应的url，以便解析对应的url来获取参数。override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    setContentView(R.layout.main)    val action: String? = intent?.action    val data: Uri? = intent?.data}Applink测试adb shell am start -a android.intent.action.VIEW \\        -c android.intent.category.BROWSABLE \\        -d &lt;URI&gt;例如adb shell am start -a android.intent.action.VIEW \\        -c android.intent.category.BROWSABLE \\        -d \"https://static.jiangker.cn\"在app中进行测试，浏览器中经常不太能跳转过去，浏览器中目前测试&lt;a/&gt;标签的形式手动点击才行，别的都只能在浏览器中跳转。但是如果是短信中的链接就比较顺利。参考链接      处理 Android 应用链接        Debugging App Links in Android 12  "
  },
  
  {
    "title": "Dockerfile构建部署React项目",
    "url": "/posts/dockerfile_react_app/",
    "categories": "Other",
    "tags": "dockerfile, react",
    "date": "2022-09-03 23:56:00 +0800",
    





    "snippet": "要想构建react项目的镜像，目前采用的方式是在镜像编译以及运行，所以依赖的镜像为node镜像。我们可以在react项目的根目录下创建Dockerfile文件FROM nodeWORKDIR /homeRUN mkdir xxxWORKDIR /home/xxxCOPY / . RUN npm installRUN npm run build RUN npm install -g serveCMD [\"serve\", \"build\"]在项目目录下，使用Dockerfile生成镜像docker build -t jiangker/app:1.0 .这样构建完成的镜像中已经包含了我们项目的代码，执行完成了编译以及安装了serve。这时可以直接使用docker目录运行容器启动服务。docker run -d --rm -p xxx:3000 jiangker/app:1.0"
  },
  
  {
    "title": "Dockerfile构建部署Springboot项目",
    "url": "/posts/dockerfile_spring_boot/",
    "categories": "Other",
    "tags": "dockerfile, spring boot",
    "date": "2022-09-03 23:30:00 +0800",
    





    "snippet": "目前我开发使用的为Java11，所以指定使用Java11的JDK，把打包完成的jar包放入到Dockerfile的工作目录下，新建Dockerfile文件。FROM openjdk:20-ea-11-jdkCOPY /*.jar /web.jarCMD [\"java\", \"-jar\", \"web.jar\"]在工作目录下，使用Dockerfile生成镜像docker build -t jiangker/web:1.0 .这样构建完成的镜像中就已经含有我们的jar包了，这是可以直接使用docker目录运行容器。docker run -d --rm -p xxx:8080 jiangker/web:1.0"
  },
  
  {
    "title": "C 文件读写",
    "url": "/posts/file_options/",
    "categories": "C",
    "tags": "file",
    "date": "2022-09-01 00:30:00 +0800",
    





    "snippet": "open() write() read()  open是linux下的底层系统调用函数，在linux下如果需要对设备进行明确的控制，那最好使用底层系统调用（open）导包，引入依赖#include &lt;libc.h&gt;open()/** * @params pathname 文件路径，可以为相对路径或绝对路径。如：\"test.txt\" * @params flags 文件打开方式，例如： *    \"O_RDONLY\" 以只读方式打开文件，该文件必须存在。 *    \"O_WRONLY\" 以只写方式打开文件 *    \"O_RDWR\" 以可读写方式打开文件.和O_RDONLY和O_WRONLY都不能同时使用 *    \"O_CREAT\" 若欲打开的文件不存在则自动建立该文件.经常和上面的同时使用。 *    \"O_EXCL\" 如果O_CREAT 也被设置, 此指令会去检查文件是否存在. 文件若不存在则建立该文件, 否则将导致打开文件错误. 此外, 若O_CREAT * @params mode 文件权限，只有在建立新文件时才会生效。 * @return 成功  返回文件句柄 ，失败  返回-1 */int open(const char * pathname, int flags);int open(const char * pathname, int flags, mode_t mode);close()/** * @params handle 文件句柄 * @return  */int close(int handle)write()/** * @params handle 为要获取文件指针的文件句柄 * @params *buf 为要写入的内容 * @params len 为要写入文件的长度 * @return 返回实际写入文件内容的长度 */int write(int handle,void *buf,int len);例子#include &lt;libc.h&gt;int main() {    // 1.打开/创建    int fd = open(\"file.txt\", O_WRONLY | O_CREAT);    if (-1 == fd) // 创建文件失败,则异常返回    {        printf(\"can't not open file\\n\");        return -1;    }    char buffer[1024] = \"*send!\";    // 2.写入    write(fd, buffer, strlen(buffer));    // 3.关闭    close(fd);    return 0;}read()/** * @params stream 为要读取的文件的文件句柄 * @params *buf 读取到的缓冲区 * @params len 读取文件长度 * @return 实际读取到的字节数 */ int read(int handle,void *buf,int len);例子#include &lt;libc.h&gt;int main() {    // 1. 打开/创建    int fd = open(\"file.txt\", O_RDONLY | O_CREAT);  //  |O_TRUNC    if (-1 == fd) // 创建文件失败,则异常返回    {        return -1;    }    // 2. 读取    char buffer[1024];    size_t flag = read(fd, buffer, strlen(buffer));    printf(\"read str is :len: %zu, content: %s\\n\", flag, buffer);   // 3. 关闭    close(fd);    return 0;}fopen() fwrite() fread()  linux下的fopen是open的封装函数，fopen最终还是要调用底层的系统调用open。fopen是c/c++下的标准I/O库函数，带输入/输出缓冲。这三个函数都在stdio.h里，所以想要使用需要先进行include#include &lt;stdio.h&gt;fopen()  在C语言中fopen()函数用于打开指定路径的文件，获取指向该文件的指针。/** * @params path 文件路径，可以为相对路径或绝对路径。如：\"test.txt\"或\"F:\\Visual Stdio 2012\\test.txt\" * @params mode 文件打开方式，例如： *    \"r\" 以只读方式打开文件，该文件必须存在。 *    \"w\" 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。 *    \"w+\" 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。 *    \"a\" 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留） *    \"a+\" 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。（原来的EOF符不保留） *    \"wb\" 只写打开或新建一个二进制文件，只允许写数据。 *    \"wb+\" 读写打开或建立一个二进制文件，允许读和写。 *    \"ab\" 追加打开一个二进制文件，并在文件末尾写数据。 *    \"ab+\"读写打开一个二进制文件，允许读，或在文件末追加数据。    * @return 文件顺利打开后，指向该流的文件指针就会被返回，会指向文件首或者文件末位，跟随文件的读写往后移动。如果文件打开失败则返回NULL，并把错误代码存在errno中。 */FILE * fopen(const char * path,const char * mode);fclose()写完数据后要调用fclose()关闭流，不关闭流的情况下，每次读或写数据后，文件指针都会指向下一个待写或者读数据位置的指针。如果需要读写，需要在一个操作完成后close后，再重新打开文件。fwrite()  在C语言中fwrite()函数常用语将一块内存区域中的数据写入到本地文本。/** * @params buffer 指向数据块的指针 * @params size 每个数据的大小，单位为Byte(例如：sizeof(int)就是4) * @params count 数据个数 * @params stream 文件指针 * @return 写入的count */size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);返回值会根据写入的形式而不同。      推荐 fwrite(buf,sizeof(buf),1,fp);，成功写入返回值为1(即count)        fwrite(buf,1,sizeof(buf),fp); 成功写入则返回实际写入的数据个数(单位为Byte)，即int就为4  例子#include &lt;stdio.h&gt;#include \"string.h\"int main() {    int age = 18;    FILE *fp = fopen(\"file.txt\", \"w\");    if (fp == NULL)        printf(\"can't not open file\");    // 写入int    fwrite(&amp;age, sizeof(int), 1, fp);    char* name = \"jiangker\";    // 写入 char[]    fwrite(name, sizeof(char), strlen(name), fp);    fclose(fp);    return 0;}打开文本文件可以看到，最前面的int乱码当然还可以使用fprintf()来输出到文件/** * @params stream 文件指针 * @params buffer 指向数据块的指针 * @params ... 格式化匹配 * @return 写入的count */int\t fprintf(FILE * stream, const char * buffer, ...) 例子#include &lt;stdio.h&gt;#include \"string.h\"int main() {    int age = 18;    char *name = \"jiangker\";    FILE *fp = fopen(\"file.txt\", \"w\");    if (fp == NULL)        printf(\"can't not open file\");    // 类似于输出到控制台的函数。    fprintf(fp,\"%d%s\",age,name);    fclose(fp);    return 0;}这里直接拼接到char *中进行写入，所以最终显示看起来正常。fread()  从一个文件流中读取数据/** * @params buffer 指向数据块的指针 * @params size 每个数据的大小，单位为Byte(例如：sizeof(int)就是4) * @params count 数据个数 * @params stream 文件指针 * @return 读取到count */size_t fread(void *buffer, size_t size, size_t count, FILE *stream);返回值随着调用格式的不同而不同：      推荐 fread(buf,sizeof(buf),1,fp); 读取成功时：当读取的数据量正好是sizeof(buf)个Byte时，返回值为1(即count)，否则返回值为0(读取数据量小于sizeof(buf))        fread(buf,1,sizeof(buf),fp); 读取成功返回值为实际读回的数据个数(单位为Byte)  例子#include &lt;stdio.h&gt;#include \"string.h\"int main() {    FILE *fp = fopen(\"file.txt\", \"r\");`    if (fp == NULL)        printf(\"can't not open file\");    fread(&amp;read, sizeof(int), 1, fp);    // 对于第一处直接使用int来写入的地方，这个可以正确读取会原来的值。而对于第二种char *方式写入则不能。    printf(\"read count %d\", read);    fclose(fp);    return 0;}参考文档      C语言open()函数:打开一个文件        C语言write()函数:写文件        C语言read()函数:用于读取打开文件的内容        linux c 底层系统调用函数 open()        fopen()、fwrite()、fread()函数使用说明与示例  "
  },
  
  {
    "title": "java匿名内部类不能修改外部闭包参数",
    "url": "/posts/java-closure/",
    "categories": "Java",
    "tags": "闭包",
    "date": "2022-08-30 13:00:00 +0800",
    





    "snippet": "闭包中的变量一般为局部变量，若是int这种基础变量类型的以及String这种特殊类型的变量。变量是创建在栈上的。当传入这种类型的参数时，相当于重新拷贝了一份对象的引用到内部类中。此时参数也并非和外部类相同的引用了，只是指向同一个地址而已，所以只能去修改指向对象的属性，而不能修改其指向。public class UndefineTest {    private String name = \"demo\";    public void testFun(int x) {        new Thread(new Runnable() {            @Override            public void run() {                name = \"jiangker\"; // OK            }        });    }}从编译最后生成的文件来看，实则是把外部对象通过构造函数给传入到了内部对象中class UndefineTest$1 implements Runnable {    UndefineTest$1(UndefineTest this$0) {        this.this$0 = this$0;    }    public void run() {        UndefineTest.access$002(this.this$0, \"jiangker\");    }}若是方法里的参数，则不能修改public class UndefineTest {    public void testFun(int x) {         String name = \"demo\";        new Thread(new Runnable() {            @Override            public void run() {                name = \"jiangker\"; // not work            }        });    }}实际传入是引用传递，指向相同的对象。需要为final，不能修改。public class UndefineTest {    public void testFun(int x) {        String name = \"demo\";        new Thread(new Runnable() {            @Override            public void run() {                String localName = name;            }        });    }}// toclass UndefineTest$1 implements Runnable {    UndefineTest$1(UndefineTest this$0, String var2) {        this.this$0 = this$0;        this.val$name = var2;    }    public void run() {        String localName = this.val$name;    }}但是在kotlin中，此类的写法又是OK的。class UndefineKtTest {    fun testFun() {        var name = \"demo\"        Thread(object : Runnable {            override fun run() {                name = \"jiangker\"            }        })    }}反编译之后可以看到，kotlin实际是进行了一次语法糖上的封装。public final class UndefineKtTest {   public final void testFun() {      final ObjectRef name = new ObjectRef();      name.element = \"demo\";      new Thread((Runnable)(new Runnable() {         public void run() {            name.element = \"jiangker\";         }      }));   }}参考文档  java为什么匿名内部类的参数引用时final？ - 胖君的回答 - 知乎"
  },
  
  {
    "title": "JavaPoet的使用和示例",
    "url": "/posts/javapoet/",
    "categories": "Java",
    "tags": "java",
    "date": "2022-08-27 08:43:00 +0800",
    





    "snippet": "JavaPoet的使用和示例JavaPoet使用面向对象的方式来构建类，其中主要分为三个部分，类，属性和方法。一般构建顺序为先属性，再方法，最后创建类的时候把前面创建的属性和方法都添加到类中即可。导入依赖implementation 'com.squareup:javapoet:1.13.0'关键APIType &amp;&amp; TypeNameTypeType表示类的基础class类型，例如常见的基础类型int.class，又或者对象类型String.class、File.class等，以及数组类型File[].class，使用这个不用手动导包，便捷方便。TypeName当有些库不在标准库中，而我们又不想在这个模块中引入过多的别的三方库时，我们可以使用TypeName来实现导入对应库的能力。当然可以使用Type的地方都是可以使用TypeName的。      基础变量类型可以使用TypeName.BOOLEAN        数组类型可以使用ArrayTypeName.of(boolean.class)又或者ArrayTypeName.of(TypeName.BOOLEAN)        不能直接使用到的类可以使用ClassName.get(“java.io”, “File”)来获取TypeName并导入对应的包。当需要使用TypeName的地方也可以使用ClassName.get(File.class)来获取对呀的TypeName类型。        属性支持范型，需要使用ParameterizedTypeName.get()，使用ParameterizedTypeName.get(List.class, Integer.class)可以得到List&lt;Integer&gt;，因为范型是不支持基础变量类型的，所以不能使用int.class或TypeName.INT。当然也可以使用TypeName来构建，ParameterizedTypeName.get(ClassName.get(\"java.util\", \"Map\"), TypeName.get(Integer.class), TypeName.get(String.class)，这个构建比较曲折，因为在此处Type类型的并不能与TypeName进行混用。        范型属性，TypeVariableName.get(\"T\")        通配符类型，这个需要用在类或者支持范型的属性中，WildcardTypeName.subtypeOf(String.class)，输出? extends String  属性构建属性使用FieldSpec，通过builder(type，name，...modifiers)，可以指定属性的类型、名称以及修饰符。通过addModifiers()同样可以设置对应的修饰符。通过使用initializer()可以给属性赋初始值。通过addAnnotation()可以增加注解，具体看如下例子基础变量属性期望private volatile int age = 18;FieldSpec age = FieldSpec.builder(int.class, \"age\")        .initializer(\"18\")        .addModifiers(Modifier.VOLATILE)        .addModifiers(Modifier.PRIVATE)        .build();通过手动设置对象路径的方式期望public static Object lock = new Object;FieldSpec lock = FieldSpec.builder(                ClassName.get(\"java.lang\", \"Object\"),                \"lock\",                Modifier.PUBLIC, Modifier.STATIC        ).initializer(\"new Object()\")        .build();使用Map期望public Map&lt;String, Integer&gt; cacheMap;FieldSpec name = FieldSpec.builder(                ParameterizedTypeName.get(Map.class, String.class, Integer.class),                \"cacheMap\"        )        .addModifiers(Modifier.PUBLIC)        .build();使用范型期望private T data;，需要类也设置范型。FieldSpec data = FieldSpec.builder(TypeVariableName.get(\"T\"), \"data\")        .addModifiers(Modifier.PRIVATE)        .build();使用通配符期望private List&lt;? extends String&gt; list;FieldSpec list = FieldSpec.builder(                ParameterizedTypeName.get(                        ClassName.get(List.class),                        WildcardTypeName.subtypeOf(String.class)                ), \"list\"        )        .addModifiers(Modifier.PRIVATE)        .build();方法方法使用MethodSpec来创建。方法修饰符、注解和属性基本一致，使用addTypeVariable()来增加方法范型，returns()来设置方法返回类型，通过addParameter()增加方法入参，使用addException()来设置方法可以抛出的异常。比较困难的就是方法体里面的内容了，方法体里的内容可以使用CodeBlock来表示，最后通过addCode()方式添加。CodeBlockCodeBlock主要用来构建方法内容，主要添加代码的方式为addStatement()来逐行添加。同样的，MethodSpec也是可以使用这个方法的，CodeBlock主要提供一个方便的解耦方式。addStatement()提供三种代码替换的方式：  addStatement(\"$T file\", File.class)=&gt;File file;,$T表示会主动把对应的包import进来。  addStatement(\"$L = null\", \"file\")=&gt;file = null;,$L只是简单的替换。  addStatement(\"$S.length()\", \"foo\")=&gt;\"foo\".length();，$S表示字符串替换，会带有双引号。常规的addStatement()都会在语句的末位自动带上“;“作为结束，而在一些语句中并不需要如此，例如if语句等，这是需要用到如下语句来制定作用域。括号之间需要满足Java的支持语法规范。  beginControlFlow()会在代码结束为止补上\"{\"。  nextControlFlow()会在代码开始钱补上\"}\"，在开始位置补上\"{\".  endControlFlow()则会在开始位置补上\"}\"。对于不需要“;“、\"{\"和“}\"，可以直接使用addCode(String)的方式来添加，例如switch语句代码段示例if语句/*** if(i &gt; 10) {    * System.out.println(\"true\");* } else if(i &lt; 10) {    * System.out.println(\"false\");* } else {    * System.out.println(\"undefine\");* }*/CodeBlock codeBlock = CodeBlock.builder()        .beginControlFlow(\"if(i &gt; 10)\")        .addStatement(\"System.out.println($S)\", \"true\")        .nextControlFlow(\"else if(i &lt; 10)\")        .addStatement(\"System.out.println($S)\", \"false\")        .nextControlFlow(\"else\")        .addStatement(\"System.out.println($S)\", \"undefine\")        .endControlFlow()        .build();for循环/*** for (int i = 0; i &lt; 5; i++) {*     System.out.print(\"str1 value\" + i);* }*/CodeBlock codeBlock = CodeBlock.builder()        .beginControlFlow(\"for (int i = 0; i &lt; 5; i++)\")        .addStatement(\"System.out.print($S + i)\", \"str1 value\")        .endControlFlow()        .build();while语句/*** while(i &gt; 10) {*     System.out.println(\"currentCount: \" + i);*     i--;* }*/CodeBlock codeBlock = CodeBlock.builder()        .beginControlFlow(\"while(i &gt; 10)\")        .addStatement(\"System.out.println($S + i)\", \"currentCount: \")        .addStatement(\"i--\")        .endControlFlow()        .build();do while语句/*** do {* } while (i &gt; 10);*/do {} while (i &gt; 10);try catch语句/*** try {* } catch (Exception e) {    * e.printStackTrace();* } finally {* }*/CodeBlock codeBlock = CodeBlock.builder()        .beginControlFlow(\"try\")        .nextControlFlow(\"catch ($T e)\", Exception.class)        .addStatement(\"e.printStackTrace()\")        .nextControlFlow(\"finally\")        .endControlFlow()        .build();类类使用TypeSpec来创建。修饰符、范型都与方法是一样的。另外还可以使用addMethod()来添加方法，addField()来增加属性。正常类/* * public class Main { * } */TypeSpec typeSpec = TypeSpec.classBuilder(\"Main\")        .addModifiers(Modifier.PUBLIC)        .build();枚举类/* * enum Main { *   DEMO * } */TypeSpec typeSpec = TypeSpec.enumBuilder(\"Main\")        .addEnumConstant(\"DEMO\")        .build();注解类/* * @interface Main { * } */TypeSpec typeSpec = TypeSpec.annotationBuilder(\"Main\")        .build();接口/* * interface Main { * } */TypeSpec typeSpec = TypeSpec.interfaceBuilder(\"Main\")        .build();匿名内部类//  void test() {//    new Thread(new Runnable() {//      @Override//      public void run() {//      }//    });;//  }TypeSpec typeSpec = TypeSpec.anonymousClassBuilder(\"\")        .superclass(Runnable.class)        .addMethod(                MethodSpec.methodBuilder(\"run\")                        .addModifiers(Modifier.PUBLIC)                        .addAnnotation(Override.class)                        .build()        )        .build();MethodSpec methodSpec = MethodSpec        .methodBuilder(\"test\")        .addStatement(\"new $T($L);\", Thread.class, typeSpec)        .build();参考文档      JavaPoet GitHub        JavaPoet 看这一篇就够了  "
  },
  
  {
    "title": "C 字符串操作",
    "url": "/posts/string_options/",
    "categories": "C",
    "tags": "string",
    "date": "2022-08-26 13:10:00 +0800",
    





    "snippet": "字符串拷贝strcpy复制到数组中，会覆盖原有内容#include &lt;string&gt;char result[100] = \"&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\";//result 结果为 new strstrcpy(result, \"new str\");strcat往数组末尾拼接内容char result[100] = \"origin\";strcat(result, \" after\");//result 结果为 origin after字符串长度strlen获取字符串长度char result[100] = \"origin\";size_t len = strlen(result); // len = 6sizeofchar result[100] = \"origin\";size_t size = sizeof(result); // size = 100snprintfchar result[100] = \"origin\";char len[20];// 这个也是覆盖，所以需要用新的数组来接受snprintf(len, sizeof(len), \"len: %d,\", strlen(result));// len = len: 6"
  },
  
  {
    "title": "C 锁的使用",
    "url": "/posts/c_lock/",
    "categories": "C",
    "tags": "lock",
    "date": "2022-08-26 13:00:00 +0800",
    





    "snippet": "C 互斥锁 mutex函数初始化#include &lt;pthread.h&gt;/**  * pthread_mutex_init 使用指定的attr属性初始化一个互斥锁mutex 。 * 如果 atrr 设为 NULL 或者使用一个默认的 pthread_mutexattr_t 类型都是使用默认属性进行初始化。 * 重复初始化一个已经初始化过的锁会导致未知行为。 */int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);除了使用 pthread_mutex_init 函数对 mutex 进行初始化，还可以使用特定的宏在声明 mutex 的时候直接赋值进行静态初始化#include &lt;pthread.h&gt;// 普通mutexpthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER;// 可重复加锁pthread_mutex_t recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER;pthread_mutex_t recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;// 有错误检查的mutex，同一线程重复加锁报错pthread_mutex_t errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER;pthread_mutex_t errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;// 上面那个带不带NP后缀取决于系统，我用的Ubuntu18.04对应的宏为PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP。去初始化与初始化对应的为去初始化，去初始化之后的锁可以再次进行初始化操作。/** * 可以销毁一个初始化过的锁。使用此函数销毁一个mutex，可以再次初始化。 * 如果尝试销毁一个锁定状态的mutex会导致未知行为。 */int pthread_mutex_destroy(pthread_mutex_t *mutex);加锁// 普通加锁，重复加锁会阻塞进程int pthread_mutex_lock (pthread_mutex_t *__mutex);/** *  重复加锁返回异常 */int pthread_mutex_trylock (pthread_mutex_t *__mutex);// 带有超时功能加锁int pthread_mutex_timedlock(pthread_mutex_t *mutex, const struct timespec *abs_timeout);pthread_mutex_lock 对一个 mutex 加锁。如果一个线程试图锁定一个已经被另一个线程锁定的互斥锁，那么该线程将被挂起，直到拥有该互斥锁的线程先解锁该互斥锁。默认的 mutex 为不可重入锁，如果定义 mutex 为 PTHREAD_MUTEX_RECURSIVE 类型，则为可重入锁，可以对其进行多次加锁。解锁// 解锁int pthread_mutex_unlock (pthread_mutex_t *__mutex);代码测试#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;/*初始化互斥锁*/pthread_cond_t  cond = PTHREAD_COND_INITIALIZER;//init condvoid *thread1(void*);void *thread2(void*);int i = 1; //globalint main(void){    pthread_t t_a;    pthread_t t_b;//two thread    pthread_create(&amp;t_a,NULL,thread2,(void*)NULL);    pthread_create(&amp;t_b,NULL,thread1,(void*)NULL);//Create thread    printf(\"t_a:0x%x, t_b:0x%x: \\n\", t_a, t_b);    pthread_join(t_b,NULL);//wait a_b thread end    pthread_mutex_destroy(&amp;mutex);    pthread_cond_destroy(&amp;cond);    exit(0);}void *thread1(void *junk){    sleep(3); // 等待让2先获取到锁    pthread_mutex_lock(&amp;mutex); //互斥锁，会等待2释放锁    printf(\"thread1 lock\\n\");    sleep(2);    pthread_cond_signal(&amp;cond); // 发送信号唤醒2，但锁仍然在自己这    printf(\"thread1 send signal\\n\");    sleep(2);    pthread_mutex_unlock(&amp;mutex);    printf(\"thread1 end\\n\");    return 0;}void *thread2(void*junk){    pthread_mutex_lock(&amp;mutex); // 获取锁    printf(\"thread2 lock\\n\");    sleep(5);    pthread_cond_wait(&amp;cond,&amp;mutex); // 释放锁，等待信号唤醒    printf(\"thread2 wait end \\n\");    sleep(1);    pthread_mutex_unlock(&amp;mutex);    printf(\"thread2 end\\n\");    return 0;}t_a:0x3720000, t_b:0x37a3000: thread2 lockthread1 lockthread1 send signalthread1 endthread2 wait end Program ended with exit code: 0读写锁  读写锁，顾名思义用在读写的地方，读写的地方要求就是如果是写的话只能一个线程拥有，防止写错覆盖新的值。如果是读状态可以多个线程拥有，这样就提高了效率，读写锁用于对数据结构读的次数远大于写的情况。读写锁可以设置为两种加锁状态，即读锁定和写锁定状态。  当处于写锁定状态时，所有加锁操作都会被阻塞.  当处于读锁定状态时，所有试图设置读锁定都会成功，所有试图设置写锁定都会被阻塞，并且还会阻塞后续所有的读锁定加锁操作，直到所有的读锁定都被解锁。初始化#include &lt;pthread.h&gt;int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);// 使用常量进行初始化pthread_rwlock_t rwlock=PTHREAD_RWLOCK_INITIALIZER;锁去初始化#include &lt;pthread.h&gt;int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);加锁读状态的锁int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);// 不阻塞，成功则返回0int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);写状态的锁int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);// 不阻塞，成功则返回0int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);解锁解锁不区分读写，统一使用这个解锁int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);代码例子读线程1先启动，再启动线程2写，当线程2请求写权限后，验证线程3是否能够正常去读#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;pthread_rwlock_t rwlock=PTHREAD_RWLOCK_INITIALIZER;void *thread1(void*);void *thread2(void*);void *thread3(void*);int i = 1; //globalint main(void){    pthread_t t_a;    pthread_t t_b;//two thread    pthread_t t_c;//two thread        pthread_create(&amp;t_a,NULL,thread1,(void*)NULL);    pthread_create(&amp;t_b,NULL,thread2,(void*)NULL);    pthread_create(&amp;t_c,NULL,thread3,(void*)NULL);        pthread_join(t_c,NULL);//wait a_b thread end    pthread_rwlock_destroy(&amp;rwlock);    exit(0);}void *thread3(void* junk){        // 暂停2秒，等待线程2先去请求锁    sleep(2);        printf(\"thread3 request lock\\n\");        pthread_rwlock_rdlock(&amp;rwlock);        printf(\"thread3 lock\\n\");        sleep(2);        printf(\"thread3 sleep end\\n\");        pthread_rwlock_unlock(&amp;rwlock);        printf(\"thread3 end\\n\");        return  0;}void *thread1(void *junk){        pthread_rwlock_rdlock(&amp;rwlock);        printf(\"thread1 lock\\n\");        sleep(5);        printf(\"thread1 sleep end\\n\");        pthread_rwlock_unlock(&amp;rwlock);        printf(\"thread1 end\\n\");    return 0;}void *thread2(void*junk){        printf(\"thread2 request lock\\n\");        pthread_rwlock_wrlock(&amp;rwlock);        printf(\"thread2 lock\\n\");        sleep(2);        printf(\"thread2 sleep end\\n\");        pthread_rwlock_unlock(&amp;rwlock);        printf(\"thread2 end\\n\");    return 0;}有线程请求写之后，后续读线程不能再获取到锁，得等待写线程释放锁之后才能继续读。thread1 lockthread2 request lockthread3 request lockthread1 sleep endthread1 endthread2 lockthread2 sleep endthread2 endthread3 lockthread3 sleep endthread3 endProgram ended with exit code: 0"
  },
  
  {
    "title": "腾讯云ubuntu系统设置root登录",
    "url": "/posts/tecent-cloud/",
    "categories": "Ubuntu",
    "tags": "cloud",
    "date": "2022-08-22 10:11:00 +0800",
    





    "snippet": "腾讯云主机，选择ubuntu系统之后，默认登录的用户都是ubuntu用户，如果想直接使用root用户，必须要手动切换，并且不可以直接登录root用户。若想直接使用root账户进行登录，则需要自己进行一些相关配置首先要确保已有root账户，然后切换到root账户下su root修改ssh配置sudo vim /etc/ssh/sshd_config修改PermitRootLogin参数# 搜索找到对应位置/PermitRootLogin# 把此熟悉设置为true，若没有自己手动添加一行PermitRootLogin true# 保存并退出:wq重启ssh服务sudo service ssh restart"
  },
  
  {
    "title": "docker安装todo看板软件",
    "url": "/posts/docker_todo/",
    "categories": "Other",
    "tags": "docker",
    "date": "2022-08-21 21:50:00 +0800",
    





    "snippet": "安装使用的开源库为taskcafe(github)官方介绍图需要有首先安装docker和docker-compose然后获取项目git clone https://github.com/JordanKnott/taskcafe &amp;&amp; cd taskcafe默认运行的端口为3333，有需要就提前修改一下docker-compose.yml里面的配置运行docker-compose -p taskcafe up -d访问http://localhost:3333"
  },
  
  {
    "title": "ajax的使用和跨域问题",
    "url": "/posts/ajax/",
    "categories": "web, ajax",
    "tags": "ajax",
    "date": "2022-08-21 12:43:00 +0800",
    





    "snippet": "ajax请求AJAX and APIsajax跨域同源概念最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓”同源”指的是”三个相同”。  协议相同（host,同为http://或https://）  域名相同（顶级域名和二级域名之类的也是不同的）  端口相同（不同端口之间的访问也是跨域）限制范围      Cookie、LocalStorage 和 IndexDB 无法读取。        DOM 无法获得。        AJAX 请求不能发送。  ajax跨域问题一般表现为接口成功返回了，status code为200，但是最后被ajax拦截了。服务器端后台允许OPTIONS请求,并且接口也允许OPTIONS请求,但是头部匹配时出现不匹配现象，比如origin头部检查不匹配,比如少了一些头部的支持(如常见的X-Requested-With头部),然后服务端就会将response返回给前端,前端检测到这个后就触发XHR.onerror,导致前端控制台报错。解决办法需要后端增加对应的支持。// 配置过滤器，在返回值中携带对应的头@WebFilter(filterName = \"CustomFilter\", urlPatterns = [\"/*\"])class CommonFilter : Filter {    override fun doFilter(request: ServletRequest, response: ServletResponse, chain: FilterChain) {        val servletResponse = response as HttpServletResponse        servletResponse.apply {            setHeader(\"Access-Control-Allow-Origin\", \"*\")            setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, DELETE, HEAD\")            setHeader(\"Access-Control-Max-Age\", \"3600\")            setHeader(                \"Access-Control-Allow-Headers\",                \"access-control-allow-origin, authority, content-type, version-info, X-Requested-With\"            )            chain.doFilter(request, response)        }    }}参考  浏览器同源政策及其规避方法  ajax跨域，这应该是最全的解决方案了"
  },
  
  {
    "title": "Jekyll博客搭建",
    "url": "/posts/jekyll/",
    "categories": "Other",
    "tags": "jekyll",
    "date": "2022-08-20 10:07:00 +0800",
    





    "snippet": "jekyll安装相关ruby环境搭建  jekyll官网  jekyll主题安装基础环境sudo apt-get install ruby-full build-essential zlib1g-dev配置环境变量echo '# Install Ruby Gems to ~/gems' &gt;&gt; ~/.bashrcecho 'export GEM_HOME=\"$HOME/gems\"' &gt;&gt; ~/.bashrcecho 'export PATH=\"$HOME/gems/bin:$PATH\"' &gt;&gt; ~/.bashrcsource ~/.bashrczsh 版echo '# Install Ruby Gems to ~/gems' &gt;&gt; ~/.zshrcecho 'export GEM_HOME=\"$HOME/gems\"' &gt;&gt; ~/.zshrcecho 'export PATH=\"$HOME/gems/bin:$PATH\"' &gt;&gt; ~/.zshrcsource ~/.zshrc安装Jekyll和bundler gems(-V可以看到安装过程的输出)gem install jekyll bundler -V创建新的jekyll博客# 创建myblog在当前目录下jekyll new myblog# 进入对应目录cd myblog运行博客（本机才能访问）# 下载依赖bundle install# 启动运行bundle exec jekyll serve访问链接 http://localhost:4000局域网访问启动bundle exec jekyll serve -w --host=0.0.0.0或者tools下也有启动命令./tools/run.sh# bundle exec jekyll s -H 0.0.0.0 -l使用jekyll-theme-chirpy主题搭建安装运行  首先得完成ruby相关配置的安装才行  jekyll-theme-chirpy克隆项目到本地，在git目录下下载依赖bundle运行local serverbundle exec jekyll sdocker 运行docker run -it -v $PWD:/srv/jekyll --name blog -p 4000:4000 jekyll/jekyll jekyll serve &amp;!可能会存在没有权限的问题如下是因为jekyll运行依赖对应的一些文件，而在docker运行时候没有文件目录下的一些权限，所以导致了运行失败。可以对整个文件夹赋予权限或者创建好对应的一些文件（推荐）touch Gemfile.lock &amp;&amp; mkdir _site &amp;&amp; mkdir .jekyll-cachechmod 777 Gemfile.lock _site .jekyll-cache一般使用docker部署，本地可以访问本地的进行开发。远程使用nginx转发，也可以实现外网访问。jekyll配置使用更改主页相关信息显示  img_cdn 注释是使用本地相对路径图片或者直接使用图片库的图片在_data目录下有share.yml文件，可以配置文章的内容分享形式在_data目录下有contact.yml文件可以配置页面左下角支持的联系方式支持plantuml  jekyll-spaceship在Gemfile中增加，若有别的插件，直接写到里面group :jekyll_plugins do  gem 'jekyll-spaceship'end然后在_config.yml中新增，同理也是有别的插件，直接添加即可plugins:  - jekyll-spaceship选择开启指定的插件，在_config.yml目录下增加# Where things arejekyll-spaceship:  # default enabled processors  processors:    - table-processor    - mathjax-processor    - plantuml-processor    - mermaid-processor    - polyfill-processor    - media-processor    - emoji-processor    - element-processor  mathjax-processor:    src:      - https://polyfill.io/v3/polyfill.min.js?features=es6      - https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js    config:      tex:        inlineMath:          - ['$','$']          - ['\\(','\\)']        displayMath:          - ['$$','$$']          - ['\\[','\\]']      svg:        fontCache: 'global'    optimize: # optimization on building stage to check and add mathjax scripts      enabled: true # value `false` for adding to all pages      include: []   # include patterns for math expressions checking (regexp)      exclude: []   # exclude patterns for math expressions checking (regexp)  plantuml-processor:    mode: default  # mode value 'pre-fetch' for fetching image at building stage    css:      class: plantuml    syntax:      code: 'plantuml'      custom: ['&lt;img class=\"plantuml\" src=\"https://www.plantuml.com/plantuml/svg/~h407374617274756d6c272c202740656e64756d6c\"&gt;']    src: http://www.plantuml.com/plantuml/svg/  mermaid-processor:    mode: default  # mode value 'pre-fetch' for fetching image at building stage    css:      class: mermaid    syntax:      code: 'mermaid!'      custom: ['&lt;img class=\"mermaid\" src=\"https://mermaid.ink/svg/eyJjb2RlIjoiJywgJyIsIm1lcm1haWQiOnsidGhlbWUiOiJkZWZhdWx0In19\"&gt;']    config:      theme: default    src: https://mermaid.ink/svg/  media-processor:    default:      id: 'media-{id}'      class: 'media'      width: '100%'      height: 350      frameborder: 0      style: 'max-width: 600px; outline: none;'      allow: 'encrypted-media; picture-in-picture'  emoji-processor:    css:      class: emoji    src: https://github.githubassets.com/images/icons/emoji/"
  },
  
  {
    "title": "Dockerfile使用和技巧",
    "url": "/posts/dockerfile/",
    "categories": "Other",
    "tags": "docker",
    "date": "2022-08-19 12:30:00 +0800",
    





    "snippet": "Dockerfile 创建和指令如果需要能够正常build，规定文件名必须要为DockerfileFROMFROM可以指定基础镜像，需要作为Dockerfile的第一个命令。基础镜像作为后续命令的基础，例如ubuntu，java等镜像。当什么基础都不需要时，可以使用scratch作为基础镜像，这是一个空白的镜像RUN在基础镜像上，当我们需要搭建适合自己的环境时，就可以使用RUN命令来运行shell命令例如FROM ubuntuRUN apt-get updateRUN apt-get install -y vim wget COPY当镜像中依赖外部文件时，就需要把外部文件复制到镜像内。这是就可以使用COPY命令，把上下文环境中的文件拷贝到工作目录中。ADDADD命令相当于UNZIP + COPY命令，若需要解压的情况可以使用，但若是直接的复制，可以直接使用COPY命令。WORKDIR当我们需要把文件拷贝到镜像中的指定目录下时，我们就需要使用WORKDIR来切换工作目录，当我们想进入对应的复制之后的文件夹下时，也需要使用WORKDIR来切换工作目录。当然，我们也可以使用CMD cd /home这种切换只对当前COMMIT有效，也就是当前命令，后续的命令工作目录仍为之前的工作目录。CMD作为Dockerfile的最后一个命令，将会在容器运行时启动。例如启动容器，运行java服务。CMD [\"java\", \"-jar\", \"app.jar\"]构建镜像docker build -t jiangker/jekyllbook:1.0 .此目录为Dockerfile所在的目录，当需要把文件复制到镜像里面的文件需要在这个工作目录下，不可以采用../或/home的形式去查找文件。最后的\".\"就是来指定构建镜像的工作路径。技巧ENV和 RUN export由于Dockerfile中每提交一条指令，都会基于已有的中间容器创建一个新的容器，而RUN export ROOT_DIR=”/your_root/dir”这样的命令只在运行该指令时拥有ROOT_DIR变量，到下一个中间容器就不存在了ENV指令维护的变量会存在于所有的中间容器中但是！ 划重点：这些环境变量都会在真正后来docker run启动的容器中消失！例如配置PATH操作就不可以用上述命令进行那么Dockerfile配置环境  Linux中很多环境变量配置文件，bashrc,bash_profile等等。可以在Dokcerfile中写 RUN echo xx » ~/.bashrc的方式来追加需要添加的环境变量路径  echo的字符串中若存在双引号，则需要增加反斜杠      RUN echo \\\"export PATH='$HOME/gems/bin:$PATH'\\\" &gt;&gt; ~/.bashrc        需要使用WORKDIR切换工作目录，cd切换只对单行有用，所以也可以使用&amp;&amp;连接命令  使配置的环境生效使用，直接使用RUN source /dir/bashrc会报source not found，需要调整，使用RUN /bin/bash -c “source /dir/bashrc”参考      使用 Dockerfile 定制镜像        Dockerfile奇技淫巧  "
  },
  
  {
    "title": "Java反射的使用",
    "url": "/posts/reflex/",
    "categories": "Java",
    "tags": "反射",
    "date": "2022-06-29 20:33:00 +0800",
    





    "snippet": "Class定义@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface AnnotationA {}@AnnotationApublic class A {    private String value1;    public String value2;    private A() {        this(\"\");    }    A(String str1) {        this(str1, \"\");    }    public A(String str1, String str2) {        this.value1 = str1;        this.value2 = str2;    }    public String getValue1() {        return value1;    }    void setValue1(String value1) {        this.value1 = value1;    }    public String getValue2() {        return value2;    }    private void setValue2(String value2) {        this.value2 = value2;    }}@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface AnnotationB {}@AnnotationBpublic class B extends A {    String value3;    public String value4;    private B() {        this(\"\");    }    protected B(String str1) {        this(str1, \"\");    }    public B(String str1, String str2) {        super(str1, str2);        this.value3 = str1;        this.value4 = str2;    }    public String getValue3() {        return value3;    }    void setValue3(String value3) {        this.value3 = value3;    }    public String getValue4() {        return value4;    }    private void setValue4(String value4) {        this.value4 = value4;    }    @Override    public String toString() {        return \"B{\" +                \"value3='\" + value3 + '\\'' +                \", value4='\" + value4 + '\\'' +                '}';    }}class类型Class&lt;B&gt; bClass = B.class;System.out.println(\"B class 类型：\" + bClass);System.out.println(\"B class 的 supperClass 类型：\" +bClass.getSuperclass());// 输出// B class 类型：class B// B class 的 supperClass 类型：class A获取构造函数Class&lt;B&gt; bClass = B.class;// 获取public构造函数Constructor&lt;?&gt;[] constructors = bClass.getConstructors();System.out.println(\"B class public 构造函数：\" + Arrays.toString(constructors));// 获取所有构造函数Constructor&lt;?&gt;[] declaredConstructors = bClass.getDeclaredConstructors();System.out.println(\"B class 所有构造函数：\" + Arrays.toString(declaredConstructors));// 输出// B class public 构造函数：[public B(java.lang.String,java.lang.String)]// B class 所有构造函数：[public B(java.lang.String,java.lang.String), protected B(java.lang.String), private B()]方法(不包括构造函数)// 获取public方法（包括父类的）Method[] methods = bClass.getMethods();System.out.println(\"B class public 函数：\" + Arrays.toString(methods));// 获取所有方法（不包括父类）Method[] declaredMethods = bClass.getDeclaredMethods();System.out.println(\"B class 所有函数：\" + Arrays.toString(declaredMethods));// 输出//B class public 函数：[public java.lang.String B.toString(), public java.lang.String B.getValue3(), public java.lang.String B.getValue4(), public java.lang.String A.getValue1(), public java.lang.String A.getValue2(), public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException, public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException, public final void java.lang.Object.wait() throws java.lang.InterruptedException, public boolean java.lang.Object.equals(java.lang.Object), public native int java.lang.Object.hashCode(), public final native java.lang.Class java.lang.Object.getClass(), public final native void java.lang.Object.notify(), public final native void java.lang.Object.notifyAll()]//B class 所有函数：[public java.lang.String B.toString(), public java.lang.String B.getValue3(), void B.setValue3(java.lang.String), public java.lang.String B.getValue4(), private void B.setValue4(java.lang.String)]Method method = bClass.getDeclaredMethod(\"setValue3\", String.class);method.setAccessible(true);// 若此方法是静态方法，则第一个参数穿null也可以method.invoke(new B(\"str13\", \"str24\"), \"method_str1\");method.getReturnType();method.getParameterTypes();成员变量// 获取public参数（包括父类的）Field[] fields = bClass.getFields();System.out.println(\"B class public 参数：\" + Arrays.toString(fields));// 获取所有成员变量（不包括父类）Field[] declaredFields = bClass.getDeclaredFields();System.out.println(\"B class 所有参数：\" + Arrays.toString(declaredFields));// 输出// B class public 参数：[public java.lang.String B.value4, public java.lang.String A.value2]// B class 所有参数：[java.lang.String B.value3, public java.lang.String B.value4]Field field = bClass.getDeclaredField(\"value3\");field.setAccessible(true);// 设置值field.set(new B(\"str13\", \"str24\"), \"method_str1\");// 获取变量注解Annotation[] fieldAnnotations = field.getAnnotations();注解// 获取public参数（包括父类的）Annotation[] annotations = bClass.getAnnotations();System.out.println(\"B class public 参数：\" + Arrays.toString(annotations));// 获取所有成员变量（不包括父类）Annotation[] declaredAnnotations = bClass.getDeclaredAnnotations();System.out.println(\"B class 所有参数：\" + Arrays.toString(declaredAnnotations));// 输出// B class public 参数：[@AnnotationB()]//B class 所有参数：[@AnnotationB()]// 获取typeSystem.out.println(annotations[0].annotationType());// 输出：interface AnnotationB"
  },
  
  {
    "title": "Docker Compose安装Nginx Proxy Manager",
    "url": "/posts/docker_nginx_proxy_manager/",
    "categories": "Other",
    "tags": "docker, nginx",
    "date": "2022-06-15 20:12:00 +0800",
    





    "snippet": "安装  前置条件，已安装docker compose个人习惯会安装到 /root/docker目录下，所以创建并进入对应文件夹mkdir /root/docker/nginx &amp;&amp; cd /root/docker/nginx创建对应docker compose文文件vim docker-compose.yml粘贴如下内容version: \"3\"services:  app:    image: 'jc21/nginx-proxy-manager:latest'    restart: unless-stopped    ports:      # These ports are in format &lt;host-port&gt;:&lt;container-port&gt;      - '80:80' # Public HTTP Port      - '443:443' # Public HTTPS Port      - '81:81' # Admin Web Port      # Add any other Stream port you want to expose      # - '21:21' # FTP    environment:      DB_MYSQL_HOST: \"db\"      DB_MYSQL_PORT: 3306      DB_MYSQL_USER: \"npm\"      DB_MYSQL_PASSWORD: \"npm\"      DB_MYSQL_NAME: \"npm\"      # Uncomment this if IPv6 is not enabled on your host      # DISABLE_IPV6: 'true'    volumes:      - ./data:/data      - ./letsencrypt:/etc/letsencrypt    depends_on:      - db  db:    image: 'jc21/mariadb-aria:latest'    restart: unless-stopped    environment:      MYSQL_ROOT_PASSWORD: 'npm'      MYSQL_DATABASE: 'npm'      MYSQL_USER: 'npm'      MYSQL_PASSWORD: 'npm'    volumes:      - ./data/mysql:/var/lib/mysql运行docker，运行前需确保对应端口未被占用lsof -i:80docker-compose up -d登陆 http://192.168.0.199:81默认账户和密码为Email:    admin@example.comPassword: changeme设置代理  一般情况代理本机端口，所以一般不开放对应端口，从nginx在本地做转发，所以填外网IP是不好使的，所以需要获取docker的ip。查看docker的ipip addr show docker0然后在代理中填入。"
  },
  
  {
    "title": "Docker Compose安装lsky-pro",
    "url": "/posts/docker_lsky-pro/",
    "categories": "Other",
    "tags": "docker, lsky-pro",
    "date": "2022-06-15 17:41:00 +0800",
    





    "snippet": "安装  前置条件，已安装docker compose个人习惯会安装到 /root/docker目录下，所以创建并进入对应文件夹mkdir /root/docker/lsky-pro &amp;&amp; cd /root/docker/lsky-pro创建对应docker compose文文件vim docker-compose.yml粘贴如下内容version: '3'services:    lsky-pro:        container_name: lsky-pro        image: dko0/lsky-pro        restart: always        volumes:            - ./lsky-pro-data:/var/www/html  #映射到本地当前文件夹下        ports:            - 7791:80        environment:            - MYSQL_HOST=mysql            - MYSQL_DATABASE=lsky-pro            - MYSQL_USER=lsky-pro            - MYSQL_PASSWORD=lsky-pro    mysql:        image: mysql:8.0        container_name: lsky-pro-db        restart: always        environment:          - MYSQL_DATABASE=lsky-pro          - MYSQL_USER=lsky-pro          - MYSQL_PASSWORD=lsky-pro          - MYSQL_ROOT_PASSWORD=lsky-pro        volumes:          - ./db:/var/lib/mysql运行dockerdocker-compose up -d打开网址 http://192.168.0.199:7791，注意修改如下"
  },
  
  {
    "title": "Docker Compose安装及使用",
    "url": "/posts/docker_compose/",
    "categories": "Other, Docker",
    "tags": "docker",
    "date": "2022-06-15 17:29:00 +0800",
    





    "snippet": "安装下载地址gitlab: docker/compose下载并安装运行例如下载最新版本(v2.6.0, linux-x86)sudo curl -L \"https://github.com/docker/compose/releases/download/v2.6.0/docker-compose-linux-x86_64\" -o /usr/local/bin/docker-compose赋予文件权限sudo chmod +x /usr/local/bin/docker-compose创建软链sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose测试运行docker-compose --version输出Docker Compose version v2.6.0"
  },
  
  {
    "title": "MVVM介绍",
    "url": "/posts/mvvm/",
    "categories": "Android",
    "tags": "android, jetpack",
    "date": "2022-06-05 14:50:00 +0800",
    





    "snippet": "MVVM架构可以将程序结构主要分为3个部分，Model是数据的模型部分，View是界面展示部分，而ViewModel是作为链接数据模型和界面展示的桥梁，从而实现使业务逻辑和界面展示分离的程序结构设计。而官方的Jetpack中的许多组件就是专门为MVVM而量身打造的。官方的应用架构指南中有这么一副图，就可以很清晰的看出Jetpack相关组件在MVVM中充当的角色数据根据情况选择来源于本地还是远程，View持有ViewModel的相关引用来显示数据以及提供功能实现，而ViewModel通过LiveData去驱动UI。这样可以使Activity或Fragment尽量保持精简，也杜绝ViewModel对Activity或Fragment的依赖，可以有效的避免很多生命周期相关的问题。"
  },
  
  {
    "title": "ViewModel使用以及原理解析",
    "url": "/posts/viewmodel/",
    "categories": "Android",
    "tags": "android, jetpack",
    "date": "2022-06-05 14:46:00 +0800",
    





    "snippet": "因为在传统的开发模式下，Activity需要负责逻辑处理，又要控制UI显示等等，负责的内容过多，任务比较重。而ViewModel可以很好的帮Activity分担一部分工作，专注于存放于界面相关的数据，一切界面上有关的数据都应该放到ViewModel中进行管理，并且ViewModel 以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。基本使用依赖添加implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.1\"主要为界面准备数据，要实现一个ViewModel对象继承至ViewModel即可class JetPackModel : ViewModel(){    // 数据以及一些方法        override fun onCleared() {        super.onCleared()        // 当不再使用时释放一些资源和解除一些绑定    }}然后即可在Activity中初始化class JetPackActivity : AppCompatActivity() {    private val model by lazy {        ViewModelProvider(this)[JetPackModel::class.java]    }}若ViewModel需要带有参数，则不再使用默认的Factory，需要自己定义如下class JetPackModel(val value: String) : ViewModel()class JetpackModelFactory(val value:String) :ViewModelProvider.Factory{    override fun &lt;T : ViewModel?&gt; create(modelClass: Class&lt;T&gt;): T {        val constructor =modelClass.getDeclaredConstructor(String::class.java)        constructor.isAccessible = true        return constructor.newInstance(value)    }}class JetPackActivity : AppCompatActivity() {    private val model by lazy {        ViewModelProvider(this, JetpackModelFactory(\"initValue\"))[JetPackModel::class.java]    }}在Activity中的多个Fragment中访问Activity的ViewModel实例val model = ViewModelProvider(requireActivity())[JetPackModel::class.java]Fragment也可以创建自己的ViewModel，方法和Activity的相同。此外还可以添加依赖implementation \"androidx.navigation:navigation-ui-ktx:2.3.5\"还可以实现更简洁的创建ViewModel对象的形式private val model : JetPackModel by viewModels()生命周期Activity在旋转时，Activity和ViewModel生命周期的对照，在整个过程中ViewModel都是可以得已保存复用的。实现原理ViewModel是如何保证Activity销毁重建之后里面的数据得以保留的呢？首先看一下涉及到的类图      androidx.lifecycle.ViewModelStore            androidx.activity.ComponentActivity.java        android.app.Activity        首先从ViewModel的来源入手，ViewModel的创建是由ViewModelProvider的get方法得到的  // ViewModelProvider.javapublic &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) {    String canonicalName = modelClass.getCanonicalName();    // 拼出唯一的Key    return get(DEFAULT_KEY + \":\" + canonicalName, modelClass);}// ViewModelProvider.javapublic &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) {    // 尝试从mViewModelStore中获取    ViewModel viewModel = mViewModelStore.get(key);    // 如果Class类型相同则复用    if (modelClass.isInstance(viewModel)) {        return (T) viewModel;    }     // 没有就开始创建    if (mFactory instanceof KeyedFactory) {        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);    } else {        viewModel = mFactory.create(modelClass);    }    // 保存到mViewModelStore中    mViewModelStore.put(key, viewModel);    return (T) viewModel;}首次创建时会通过mFactory来创建并以key-value的形式保存到mViewModelStore中，而再次获取时只需要从mViewModelStore中获取。那么ViewModelProvider中的mViewModelStore是怎么初始化的呢？// ViewModelProvider.javapublic ViewModelProvider(@NonNull ViewModelStoreOwner owner) {    this(owner.getViewModelStore(), owner instanceof HasDefaultViewModelProviderFactory         ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()         : NewInstanceFactory.getInstance());}// ViewModelProvider.javapublic ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) {    mFactory = factory;    mViewModelStore = store;}// ComponentActivity.javapublic ViewModelStore getViewModelStore() {    if (mViewModelStore == null) {        NonConfigurationInstances nc =            (NonConfigurationInstances) getLastNonConfigurationInstance();        if (nc != null) {            mViewModelStore = nc.viewModelStore;        }        if (mViewModelStore == null) {            mViewModelStore = new ViewModelStore();        }    }    return mViewModelStore;}// Activity.javapublic Object getLastNonConfigurationInstance() {    return mLastNonConfigurationInstances != null        ? mLastNonConfigurationInstances.activity : null;}owner是由构造方法传入的Activity，则mViewModelStore和Activity对象一一对应，所以Activity中的fragment可以很方便的获取到同一个ViewModel。而Activity首先会尝试获取mLastNonConfigurationInstances值中的viewModelStore，而获取不到时再重新创建。那么mLastNonConfigurationInstances是在何时进行付值的呢？当配置改变时，若需要需要重建Activity，则App进程的Handler会收到一个ClientTransaction对象，里面会包含ClientTransactionItem抽象类的子类，最后会调用其execute方法进行具体的事件执行。例如常见的子类会有LaunchActivityItem、PauseActivityItem、ActivityRelaunchItem、DestroyActivityItem等，而重建收到的是ActivityRelaunchItem对象，他的execute方法如下：@Overridepublic void execute(ClientTransactionHandler client, IBinder token,                    PendingTransactionActions pendingActions) {  \tclient.handleRelaunchActivity(mActivityClientRecord, pendingActions);}这里的client就是ActivityThread对象，所以先看一下整体的流程图：在App端记录Activity信息的类这个是ActivityThread的静态内部类，主要记录了Activity的关键信息，与AMS那边相对应，App端保存到一个ArrayMap中final ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities = new ArrayMap&lt;&gt;();首先是handleRelaunchActivity方法// ActivityThread.javapublic void handleRelaunchActivity(ActivityClientRecord tmp,            PendingTransactionActions pendingActions) {    //标志Activity重建是因为配置改变    r.activity.mChangingConfigurations = true;    handleRelaunchActivityInner(r, configChanges, tmp.pendingResults, tmp.pendingIntents,                pendingActions, tmp.startsNotResumed, tmp.overrideConfig, \"handleRelaunchActivity\");}// ActivityThread.javaprivate void handleRelaunchActivityInner(ActivityClientRecord r, int configChanges,        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingIntents,        PendingTransactionActions pendingActions, boolean startsNotResumed,        Configuration overrideConfig, String reason) {    // 这第四个参数很关键    handleDestroyActivity(r.token, false, configChanges, true, reason);    // 清除上一个record的信息    r.activity = null;    r.window = null;    // 重新启动一个Activity    handleLaunchActivity(r, pendingActions, customIntent);}// ActivityThread.javaActivityClientRecord performDestroyActivity(IBinder token, boolean finishing,                                            int configChanges, boolean getNonConfigInstance, String reason) {    // 再从mActivities中去把这个record查找出来    ActivityClientRecord r = mActivities.get(token);    if (r != null) {        // 这个参数为true，所以调用了activity的retainNonConfigurationInstances方法把值进行保存        if (getNonConfigInstance) {            try {                r.lastNonConfigurationInstances                    = r.activity.retainNonConfigurationInstances();            } catch (Exception e) {                if (!mInstrumentation.onException(r.activity, e)) {                    throw new RuntimeException(                        \"Unable to retain activity \"                        + r.intent.getComponent().toShortString()                        + \": \" + e.toString(), e);                }            }        }        r.setState(ON_DESTROY);    }    synchronized (mResourcesManager) {        mActivities.remove(token);    }    return r;}做对比看一下正常Activity销毁时调用的方法。// DestroyActivityItem.javapublic void execute(ClientTransactionHandler client, IBinder token,        PendingTransactionActions pendingActions) {    // 这里直接调用handleDestroyActivity且getNonConfigInstance为false，则不会保存    client.handleDestroyActivity(token, mFinished, mConfigChanges,            false /* getNonConfigInstance */, \"DestroyActivityItem\");}然后再看Activity的retainNonConfigurationInstances方法具体是如何进行保存的// Activity.javaNonConfigurationInstances retainNonConfigurationInstances() {    // 获取要保存的对象并保存到nci中    Object activity = onRetainNonConfigurationInstance();    NonConfigurationInstances nci = new NonConfigurationInstances();    if (activity == null &amp;&amp; children == null &amp;&amp; fragments == null &amp;&amp; loaders == null        &amp;&amp; mVoiceInteractor == null) {        return null;    }    nci.activity = activity;    return nci;}// ComponentActivity.javapublic final Object onRetainNonConfigurationInstance() {    ViewModelStore viewModelStore = mViewModelStore;    if (viewModelStore == null) {        NonConfigurationInstances nc =            (NonConfigurationInstances) getLastNonConfigurationInstance();        if (nc != null) {            viewModelStore = nc.viewModelStore;        }    }    if (viewModelStore == null &amp;&amp; custom == null) {        return null;    }    NonConfigurationInstances nci = new NonConfigurationInstances();    nci.viewModelStore = viewModelStore;    return nci;}在ComponentActivity中重写了Activity的onRetainNonConfigurationInstance方法，使viewModelStore保存到NonConfigurationInstances中进行返回。然后接下来是重新创建新的Activity实例// ActivityThread.javaprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {    Activity activity = null;    try {        // 创建一个新的Activity        activity = mInstrumentation.newActivity(                cl, component.getClassName(), r.intent);    } catch (Exception e) {    }    try {        Application app = r.packageInfo.makeApplication(false, mInstrumentation);        if (activity != null) {            // 把r.lastNonConfigurationInstances传递给新创建的activity            activity.attach(appContext, this, getInstrumentation(), r.token,                    r.ident, app, r.intent, r.activityInfo, title, r.parent,                    r.embeddedID, r.lastNonConfigurationInstances, config,                    r.referrer, r.voiceInteractor, window, r.configCallback,                    r.assistToken);            // 清空record中的lastNonConfigurationInstances信息            r.lastNonConfigurationInstances = null;            r.activity = activity;        }        r.setState(ON_CREATE);        synchronized (mResourcesManager) {            mActivities.put(r.token, r);        }    } catch (SuperNotCalledException e) {    } catch (Exception e) {    }    return activity;}// Activity.javafinal void attach(Context context, ActivityThread aThread,        Instrumentation instr, IBinder token, int ident,        Application application, Intent intent, ActivityInfo info,        CharSequence title, Activity parent, String id,        NonConfigurationInstances lastNonConfigurationInstances,        Configuration config, String referrer, IVoiceInteractor voiceInteractor,        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) {    attachBaseContext(context);    mUiThread = Thread.currentThread();    // 保存到activity对象中    mLastNonConfigurationInstances = lastNonConfigurationInstances;}performLaunchActivity方法中主要是创建一个新的activity，然后对activity进行初始化，然后清空lastNonConfigurationInstances，以及保存record到mActivities中，最后activity对lastNonConfigurationInstances参数进行保存，所以mLastNonConfigurationInstances就有值了，在onCreate方法时再进行ViewModelStore的获取时即可拿到之前的ViewModel对象。但在Activity中搜索mLastNonConfigurationInstances会发现这样一段代码// Activity.javafinal void performResume(boolean followedByPause, String reason) {    mLastNonConfigurationInstances = null;    // 会执行activity的onResume方法    mInstrumentation.callActivityOnResume(this);}在调用Activity的onResume方法前就会把mLastNonConfigurationInstances设置为空，那ViewModel的初始化若是在onResume中进行的那么就保存不了了呢？若写下如下代码进行测试，发现结果并不会像上面分析的一样，旋转屏幕之后仍然可以获取到之前的ViewModel对象override fun onResume() {    super.onResume()    model.count.observe(this) {        binding.tvClickTime.text = \"click time $it\"    }    binding.tvClickTime.setOnClickListener {        model.click()    }}继续分析代码可以发现在FragmentActivity的onCreate中有这么一段代码// FragmentActivity.javafinal FragmentController mFragments = FragmentController.createController(new HostCallbacks());protected void onCreate(@Nullable Bundle savedInstanceState) {    mFragments.attachHost(null /*parent*/);}// androidx.fragment.app.FragmentController.javapublic void attachHost(@Nullable Fragment parent) {\tmHost.mFragmentManager.attachController(mHost, mHost /*container*/, parent);}// androidx.fragment.appFragmentManagerImpl.javapublic void attachController(@NonNull FragmentHostCallback host,                             @NonNull FragmentContainer container, @Nullable final Fragment parent) {  if (mHost != null) throw new IllegalStateException(\"Already attached\");  mHost = host;  if (parent != null) {    mNonConfig = parent.mFragmentManager.getChildNonConfig(parent);  } else if (host instanceof ViewModelStoreOwner) {    //调用了host的getViewModelStore()    ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore();    mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);  } else {    mNonConfig = new FragmentManagerViewModel(false);  }}因为host其实实现了ViewModelStoreOwner接口然后桥接了Activity的getViewModelStore()方法，所以这里调用的其实是Activity的getViewModelStore()方法，Activity的mViewModelStore在onCreate中得到了初始化，故ViewModel在onResume中也可以正常使用，同理，若继承的是FragmentActivity的父Activity则就不能正常获取到mViewModelStore对象了。最后看一下ViewModel的onCleared()是怎么被调用的，怎么保证只有在正常销毁时做数据清理的。在ComponentActivity的构造方法中// androidx.activity.ComponentActivity.javapublic ComponentActivity() {    Lifecycle lifecycle = getLifecycle();    //noinspection ConstantConditions    if (lifecycle == null) {        throw new IllegalStateException(\"getLifecycle() returned null in ComponentActivity's \"                + \"constructor. Please make sure you are lazily constructing your Lifecycle \"                + \"in the first call to getLifecycle() rather than relying on field \"                + \"initialization.\");    }    // 在Activity执行onDestroy时，调用ViewModel的clear方法    getLifecycle().addObserver(new LifecycleEventObserver() {        @Override        public void onStateChanged(@NonNull LifecycleOwner source,                @NonNull Lifecycle.Event event) {            if (event == Lifecycle.Event.ON_DESTROY) {                // 仅在非配置改变的情况下                if (!isChangingConfigurations()) {                    getViewModelStore().clear();                }            }        }    });}// ViewModelStore.javapublic final void clear() {    for (ViewModel vm : mMap.values()) {        vm.clear();    }    mMap.clear();}总结总的来说ViewModel可以总结为以下几点      mViewModelStore实际是以键值对的形式储存着ViewModel，key为与类名相关或自定义的字符串，而值则为ViewModel    一个Activity对象对应于一个mViewModelStore对象  在Activity销毁重建时，ActivityThread使用lastNonConfigurationInstances来将被销毁Activity的数据传递给重建的Activity。  在配置改变导致的重建Activity会避免去清除mViewModelStore"
  },
  
  {
    "title": "Room使用以及原理解析",
    "url": "/posts/room/",
    "categories": "Android",
    "tags": "android, jetpack",
    "date": "2022-06-05 14:46:00 +0800",
    





    "snippet": "依赖apply plugin: 'kotlin-kapt'implementation \"androidx.room:room-runtime:2.3.0\"kapt \"androidx.room:room-compiler:2.3.0\"@Entity  用于定义封装实际数据的实体类，每个实体类都会在数据库中对应一张表，并且表中的列是根据实体类中的字段自动生成的。常用注解  @Entity 的常用属性          tableName 指定对呀的数据库表名      primaryKeys 指定主键      ignoredColunms 指定忽略的字段，父类的也可以        @PrimaryKey 指定主键，autoGenerate设置为自增长      @ColumnInfo 指定字段在数据库中的名称，name 名称    @Ignore 表示字段不用存入数据库// User就是表名，可以单独指定表名，复合主键@Entity(primaryKeys = arrayOf(\"firstName\", \"lastName\"))@Entity(tableName = \"User\")data class User(    var firstName: String,    var lastName: String,    var age: Int) {    // 将id设置为自增长的主键，每个实体至少得有一个主键    @PrimaryKey(autoGenerate = true)    var id: Long = 0}数据必须是public的或者是提供javabean的方法@Dao  数据访问对象，通常会在这里对数据库的各项操作进行封装，逻辑层主要是和Dao打交道。/** * 如果是作为实体对象来传入的参数，是不需要SQL语句 * @Update 和 @Delete是根据数据id去执行操作的 */@Daointerface UserDao {    // 若插入的是多个，则数据为List&lt;Long&gt;    @Insert    fun insertUser(user: User): Long    @Update    fun updateUser(newUser: User)    @Query(\"select * from User\")    fun loadAllUser(): List&lt;User&gt;    @Query(\"select * from User where age &gt; :age\")    fun loadUserOlderThan(age: Int): List&lt;User&gt;    @Delete    fun deleteUser(user: User)    @Query(\"delete from User where lastName = :lastName\")    fun deleteUserByLastName(lastName: String): Int}@Database  数据库的关键信息，版本号、包含的实体类，以及对外提供Dao的实例。@Database(version = 2, entities = [User::class, Book::class])abstract class AppDatabase : RoomDatabase() {    abstract fun userDao(): UserDao    abstract fun bookDao(): BookDao    companion object {        // 数据库名        private const val DATABASE_NAME = \"app_database\"        private var instance: AppDatabase? = null        val MIGRATION_1_2 = object : Migration(1, 2) {            override fun migrate(database: SupportSQLiteDatabase) {                database.execSQL(                    \"\"\"create table Book (                    id integer primary key autoincrement not null,                    name text not null,pages integer not null                    )\"\"\".trimMargin()                )            }        }        fun getDatabase(context: Context): AppDatabase = instance ?: synchronized(this) {            instance ?: Room.databaseBuilder(                context.applicationContext,                AppDatabase::class.java,                DATABASE_NAME            )//                .allowMainThreadQueries() 设置可以在主现场执行数据库操作                .addMigrations(MIGRATION_1_2)                .build()                .also { instance = it }        }    }}参考            [使用 Room 将数据保存到本地数据库      Android 开发者      Android Developers (google.cn)](https://developer.android.google.cn/training/data-storage/room?hl=zh-cn)      定义对象之间的关系"
  },
  
  {
    "title": "Livedata使用以及原理解析",
    "url": "/posts/livedata/",
    "categories": "Android",
    "tags": "android, jetpack",
    "date": "2022-06-05 14:46:00 +0800",
    





    "snippet": "  LiveData 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者，也会在应用组件销毁时自动取消关联。基础使用LiveData作为一个支持范型的数据对象，一般是放置在ViewModel中的。并且LiveData是一个抽象类，不能直接使用，只能使用其子类class JetPackModel : ViewModel() {    val count = MutableLiveData(0)}于此同时LiveData是一个被观察者，可以向其添加观察者对象，当内部的数据发生变化时会主动去通知观察者。所以被观察者一般都会具有以下类型的方法：      添加观察者的方法，observeForever(Observer&lt;? super T&gt; observer)向LiveData添加一个观察者        改变其内部的数据的方法，对应LiveData有setValue (必须主线程调用)和postValue(可以在子线程调用)，数据更改之后会去通知观察者，而这两个方法是protected的，不可以直接使用，需要使用其子类MutableLiveData  class JetPackModel : ViewModel() {    private val _count = MutableLiveData(0)    // 对外暴露不可变的LiveData    val count: LiveData&lt;Int&gt; = _count    fun click() {        val value = _count.value ?: 0        // setValue方法只能在主线程调用，会立即触发活跃状态观察者的Obsrever方法        _count.value = value + 1    }    fun postClick(){        val value = _count.value ?: 0        // 会post到主线程中进行        _count.postValue(value + 1)    }}override fun onCreate(savedInstanceState: Bundle?) {    // 当数据改变时会回调onChanged方法    model.count.observeForever(object :Observer&lt;Int&gt;{        override fun onChanged(t: Int?) {          }    })}但是这样的被观察者在使用中需要在onDestory中主动去移除，否则会存在一些问题  当Activity销毁时，LiveData依旧会持有Observer对象，造成Activity的泄漏  此时LiveData的更新，很可能因为Activity的销毁而导致崩溃但作为LiveData而言，是一个具有生命的Data，要解决上面的问题可以使用他的observe(LifecycleOwner owner, Observer&lt;? super T&gt; observer)，结合Lifecycle实现自动解绑可以有效的防止内存泄漏。与此同时，结合Lifecycle之后的LiveData还具有如下优势  只会去通知处于活跃状态的观察者。  当由非活跃状态改变为活跃状态时，若有新的数据会立即更新。override fun onCreate(savedInstanceState: Bundle?) {    // 当数据改变时会回调onChanged方法    model.count.observe(this, object :Observer&lt;Int&gt;{        override fun onChanged(t: Int?) {        }    })}当LiveData所装载的数据和想对外暴露的数据有所区别时，可以对其进行一定的转化。private val _count = MutableLiveData&lt;Int&gt;()val clickText: LiveData&lt;String&gt; = Transformations.map(_count){    \"this button click $it times\"}当一个界面的数据依赖于多个数据源时，可以使用LiveData还可以结合网络请求、Room、DataStore来使用，有助于界面上显示的数据与数据库中的保持一致。实现原理Q：LiveData作为一个可以结合生命周期使用的被观察者，他是怎么协同Lifecycle处理如下问题的呢？  生命周期结束时自动解绑  如何区分活跃状态于非活跃状态的观察者，指定更新活跃状态的观察者  观察者变为活跃状态时更新最新的数据因为一个LiveData可以在绑定多个具有生命周期的观察者对象，且生命周期Lifecycle很可能是不同的，所以大致对应关系可能如下为了区别观察者的状态去选择性的更新以及对Lifecycle状态改变时做出处理，LiveData就需要对observer进行包装，大概会涉及到如下几个类，都是LiveData的内部类并且添加进来的观察者有两种类型（带不带生命周期），所以LiveData对其进行了区分，使用了ObserverWrapper来约定了观察者的基础特性，以及两个子类扩展其自己的特性。  ObserverWrapper：含有几个关键的标志属性和方法          mObserver - 真正的观察者对象      mActive - 是否活跃的标志      mLastVersion - 当前观察者数据的version        AlwaysActiveObserver 无生命周期的观察者，改变了就得收到通知，所以属于一直是活跃的  LifecycleBoundObserver 带生命周期的观察者，实现了LifecycleEventObserver接口，所以同时也是Lifecycle的观察者首先从对应的方法入手，observe方法就把生命周期对象LifecycleOwner传入了进去。// LiveData.javapublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) {    // LiveData的相关操作都是必须在主线程完成的    assertMainThread(\"observe\");    if (owner.getLifecycle().getCurrentState() == DESTROYED) {        // ignore        return;    }    // 用LifecycleBoundObserver对observer进行代理    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);    // 一个LiveData中不能重复添加同一个observer    if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) {        throw new IllegalArgumentException(\"Cannot add the same observer\"                + \" with different lifecycles\");    }    if (existing != null) {        return;    }    // 然后与lifecycle绑定，生命周期状态改变时就会通知wrapper了    owner.getLifecycle().addObserver(wrapper);}LiveData真正通知观察者主要有两种情况：  进行了setValue或postValue： 遍历所有观察者，若活跃才通知  lifecycle状态改变，观察者状态由非活跃切换为活跃状态： 判断是否是变成的活跃状态，若是才去通知所以我们先看lifecycle状态改变时的调用流程所以当lifecycle的状态改变的时候，会把消息传递给部分observer对象，下面是LifecycleBoundObserver的onStateChanged方法// LiveData$LifecycleBoundObserver.classpublic void onStateChanged(@NonNull LifecycleOwner source,        @NonNull Lifecycle.Event event) {    Lifecycle.State currentState = mOwner.getLifecycle().getCurrentState();    // 如果当前状态是destroyed，则移除观察。    if (currentState == DESTROYED) {        removeObserver(mObserver);        return;    }    // 同步状态    Lifecycle.State prevState = null;    while (prevState != currentState) {        prevState = currentState;        activeStateChanged(shouldBeActive());        currentState = mOwner.getLifecycle().getCurrentState();    }    // 大于等于started状态即start和resume    boolean shouldBeActive() {        return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);    }}首先会获取当前的状态，若已经是destroy状态则移除观察直接返回然后开始更新状态。LiveData的具有惰性：如果是若变为活跃状态，有需要更新的数据才通知观察者。对于带状态的观察者来说，并不需要很细的生命周期状态，只需要是否活跃的区分。再看activeStateChanged方法// LiveData$ObserverWrapper.classvoid activeStateChanged(boolean newActive) {\t// 如果状态已经一样了，直接返回    if (newActive == mActive) {        return;    }    mActive = newActive;    // 改变活跃的观察者数量，如果这个变为活跃则加一否则减一    changeActiveCounter(mActive ? 1 : -1);    if (mActive) {        // 如果当前是变更为活跃状态，则开始通知观察者        dispatchingValue(this);    }}因为没有状态的改变，所以直接返回即可。changeActiveCounter方法主要统计活跃的观察者数量。当从非活跃状态变为活跃状态时，则去判断是否需要同步数据给观察者。// LiveData.javavoid changeActiveCounter(int change) {    int previousActiveCount = mActiveCount;    mActiveCount += change;    // 如果是正在改变，则直接返回    if (mChangingActiveState) {        return;    }    mChangingActiveState = true;    try {        while (previousActiveCount != mActiveCount) {            // 如果活跃的观察者数量由没有变成了有            boolean needToCallActive = previousActiveCount == 0 &amp;&amp; mActiveCount &gt; 0;            // 如果活跃的观察者一个都没有了            boolean needToCallInactive = previousActiveCount &gt; 0 &amp;&amp; mActiveCount == 0;            previousActiveCount = mActiveCount;            // 调用LiveData的状态切换方法            if (needToCallActive) {                onActive();            } else if (needToCallInactive) {                onInactive();            }        }    } finally {        mChangingActiveState = false;    }}这里主要是对活跃的观察者数量由0到1或由1到0时触发LiveData的两个状态切换方法：onActive()和onInactive()，这个类似与ProcessLifecycleOwner中观察activity状态切换来控制应用进程状态切换。然后接下来是dispatchingValue方法// LiveData.javavoid dispatchingValue(@Nullable ObserverWrapper initiator) {    if (mDispatchingValue) {        mDispatchInvalidated = true;        return;    }    mDispatchingValue = true;    do {        mDispatchInvalidated = false;        if (initiator != null) {        \t// 如果initiator不为空则去看是否调用观察者            considerNotify(initiator);            initiator = null;        } else {        \t// 如果为空则考虑通知全部观察者            for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator =                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {                considerNotify(iterator.next().getValue());                if (mDispatchInvalidated) {                    break;                }            }        }    } while (mDispatchInvalidated);    mDispatchingValue = false;}dispatchingValue是LiveData中的一个综合分发方法，若initiator不为空则尝试指定推送，若为空的话会尝试通知全部。并且mDispatchingValue表示是否正在进行这个方法，而mDispatchInvalidated用于中断遍历，重新全部更新。接下来是considerNotify方法，主要判断是否真正调用observer的onChanged方法private void considerNotify(ObserverWrapper observer) {    if (!observer.mActive) {        return;    }    if (!observer.shouldBeActive()) {        observer.activeStateChanged(false);        return;    }    // 是否有最新的数据    if (observer.mLastVersion &gt;= mVersion) {        return;    }    observer.mLastVersion = mVersion;    // 真正通知    observer.mObserver.onChanged((T) mData);}这里进行几次状态的检验，保证是Observer是活跃并且LiveData有新的消息才去调用onChanged。setValue触发更新的流程// LiveData.javaprotected void setValue(T value) {    assertMainThread(\"setValue\");    // 设置最新的数据版本    mVersion++;    mData = value;    // 全局遍历通知    dispatchingValue(null);}然后post的设置方式// LiveData.javaprotected void postValue(T value) {    boolean postTask;    synchronized (mDataLock) {        postTask = mPendingData == NOT_SET;        mPendingData = value;    }    if (!postTask) {        return;    }    // 通过Handler切换回主线程执行    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);}private final Runnable mPostValueRunnable = new Runnable() {    @SuppressWarnings(\"unchecked\")    @Override    public void run() {        Object newValue;        synchronized (mDataLock) {            newValue = mPendingData;            mPendingData = NOT_SET;        }        setValue((T) newValue);    }};通过mPendingData来标志现在是否有没执行的更新操作，若有的话就直接更新值不用再发handler事件了。最后看一下observeForever方法// LiveData.javapublic void observeForever(@NonNull Observer&lt;? super T&gt; observer) {    assertMainThread(\"observeForever\");    // 生成代理对象    AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);    if (existing instanceof LiveData.LifecycleBoundObserver) {        throw new IllegalArgumentException(\"Cannot add the same observer\"                + \" with different lifecycles\");    }    if (existing != null) {        return;    }    // 设置状态为active    wrapper.activeStateChanged(true);}// LiveData$AlwaysActiveObserver.classboolean shouldBeActive() {    // 表示一致都需要同步，LiveData改变就要通知    return true;}总结  LiveData会对添加进来的方法进行包装，增加mActive等属性  若传入了LifecycleOwner，则也会作为lifecycle的观察者，观察Lifecycle的生命周期变化，在合适的时候进行解绑以及通知更新数据等操作  当setValue时会对所有包装的观察者对象进行遍历，通知活跃的观察者"
  },
  
  {
    "title": "Lifecycle使用以及原理解析",
    "url": "/posts/lifecycle/",
    "categories": "Android",
    "tags": "android, jetpack",
    "date": "2022-06-05 14:07:00 +0800",
    





    "snippet": "基础使用在Android框架中定义的许多应用组件都存在着生命周期（例如Activity、Fragment）。组件的生命周期由操作系统中运行的框架代码管理。它们是Android工作原理的核心，应用必须遵守规则，否则会造成内存泄露以及应用的崩溃。应用中有很多组件需要在创建时注册绑定，在可见时运作，在不可见时停止，在销毁时解除绑定，许许多多的操作都与生命周期密切相关。所以这时如果需要添加到生命周期的方法过多时就很容易混乱、难以维护，所以通常我们可以如下做// 定义生命周期方法interface LifeListener {    fun onCreate()    fun onStart()    fun onStop()    fun onDestroy()}// 基类中集成open class BaseActivity : AppCompatActivity() {    protected val list = mutableListOf&lt;LifeListener&gt;()    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        list.forEach { it.onCreate() }    }    override fun onStart() {        super.onStart()        list.forEach { it.onStart() }    }    override fun onStop() {        super.onStop()        list.forEach { it.onStop() }    }    override fun onDestroy() {        super.onDestroy()        list.forEach { it.onStop() }    }}而现在的AppCompatActivity已经集成了相关可以很方便管理组件生命周期的方法的内容，那就是LifecycleLifecycleLifecycle可以用于储存相关组件的生命周期状态信息，是一个被观察者并允许其他实现了LifecycleObserver的对象观察此状态。Lifecycle中有两种主要的枚举用于表示生命周期状态以及变化动作      Events 生命周期事件，对应于Activity和Fragment中的回调事件        States 表示当前所处生命周期状态  官网有一张图，很清晰的表明了State与Event的关系State从左到右表示状态的提升对应up，从右往左即为状态的下降对应downLifecycleOwner这是一个接口，实现这个接口的类表示具有Lifecycle。实现LifecycleObserver的组件可以很完美的与实现LifecycleOwner的组件配合，LifecycleOwner提供生命周期Lifecycle，LifecycleObserver可以注册以观察生命周期。lifecycle.addObserver(object :LifecycleEventObserver{    override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) {\t\t    }})也可以添加依赖implementation \"android.arch.lifecycle:common-java8:1.1.1\"然后重写自己想要监听的生命周期方法lifecycle.addObserver(object :DefaultLifecycleObserver{    override fun onCreate(owner: LifecycleOwner) {        super.onCreate(owner)    }})这样就可以很方便的制作自己生命周期相关的组件class EventBusLifecycleObserver(    private val activity: AppCompatActivity) : DefaultLifecycleObserver {    override fun onCreate(owner: LifecycleOwner) {        super.onCreate(owner)        EventBus.getDefault().register(activity)    }    override fun onDestroy(owner: LifecycleOwner) {        super.onDestroy(owner)        EventBus.getDefault().unregister(activity)    }}override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    DataBindingUtil.setContentView&lt;ActivityMainBinding&gt;(this, R.layout.activity_main)    lifecycle.addObserver(EventBusLifecycleObserver(this))}目前Android默认实现了LifecycleOwner的只有Activity和Fragment，我们也可以继承LifecycleOwner接口，然后主动把事件转发到LifecycleRegistry。class MyActivity : Activity(), LifecycleOwner {    private lateinit var lifecycleRegistry: LifecycleRegistry    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        lifecycleRegistry = LifecycleRegistry(this)        lifecycleRegistry.setCurrentState(Lifecycle.State.CREATED)    }    public override fun onStart() {        super.onStart()        lifecycleRegistry.setCurrentState(Lifecycle.State.STARTED)    }    override fun getLifecycle(): Lifecycle {        return lifecycleRegistry    }}实现原理：主要可以从两个方面去看lifecycle怎么实现的  注册观察者时怎么把被观察者当前已有的状态同步过去的  以及lifecycle怎么得到生命周期事件并转发给观察者的。首先看一下涉及到的主要类图​LifecycleRegistry是Lifecycle的实现类，  mState表示的是组件当前所处的生命周期状态  mObserverMap是观察者对象以及观察者对象的包装类的容器  以及一些同步生命周期状态的方法，方法状态给观察者ObserverWithState是观察者的包装类  mState记录当前观察者已经同步到的状态  mLifecycleObserver：当前观察者的代理类，方便把生命周期事件传递给观察者中正确的方法FullLifecycleObserverAdapter主要处理观察者是FullLifecycleObserver的情况，把onStateChanged事件划分转发给FullLifecycleObserver对应的方法class FullLifecycleObserverAdapter implements LifecycleEventObserver {    private final FullLifecycleObserver mFullLifecycleObserver;    private final LifecycleEventObserver mLifecycleEventObserver;    FullLifecycleObserverAdapter(FullLifecycleObserver fullLifecycleObserver,            LifecycleEventObserver lifecycleEventObserver) {        mFullLifecycleObserver = fullLifecycleObserver;        mLifecycleEventObserver = lifecycleEventObserver;    }    @Override    public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) {        switch (event) {            case ON_CREATE:                mFullLifecycleObserver.onCreate(source);                break;            case ON_START:                mFullLifecycleObserver.onStart(source);                break;            case ON_RESUME:                mFullLifecycleObserver.onResume(source);                break;            case ON_PAUSE:                mFullLifecycleObserver.onPause(source);                break;            case ON_STOP:                mFullLifecycleObserver.onStop(source);                break;            case ON_DESTROY:                mFullLifecycleObserver.onDestroy(source);                break;            case ON_ANY:                throw new IllegalArgumentException(\"ON_ANY must not been send by anybody\");        }        if (mLifecycleEventObserver != null) {            mLifecycleEventObserver.onStateChanged(source, event);        }    }}首先我们从addObserver方法开始看起，这个是在Lifecycle的接口当中的方法，而实现类为LifecycleRegistry，流程图大概如下代码流程// LifecycleRegistry.java@Overridepublic void addObserver(@NonNull LifecycleObserver observer) {  \t// 若当前状态不是销毁状态，则为初始状态    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;  \t// 生成一个带状态的事件转发的管理对象    ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);\t\t// 若之前这个observer不存在则继续进行    if (previous != null) {        return;    }    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();    if (lifecycleOwner == null) {        // it is null we should be destroyed. Fallback quickly        return;    }\t// 是否需要进行sync    boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;    // 计算要达到的状态    State targetState = calculateTargetState(observer);    mAddingObserverCounter++;  \t// 把statefulObserver的状态连续推进到页面当前状态，只有小于当前状态才推进    while ((statefulObserver.mState.compareTo(targetState) &lt; 0            &amp;&amp; mObserverMap.contains(observer))) {        pushParentState(statefulObserver.mState);        // 计算这个状态变化的下一个事件        final Event event = Event.upFrom(statefulObserver.mState);\t\tstatefulObserver.dispatchEvent(lifecycleOwner, event);        popParentState();        targetState = calculateTargetState(observer);    }    if (!isReentrance) {        sync();    }    mAddingObserverCounter--;}所以这里最关键的就是ObserverWithState，这个包含了生命周期状态以及一个观察者的代理对象mLifecycleObserver。// LifecycleRegistry.ObserverWithStateObserverWithState(LifecycleObserver observer, State initialState) {  \t// 根据observer的实际类型生成代理对象    mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);  \t// 初始化状态    mState = initialState;}// Lifecyclingstatic LifecycleEventObserver lifecycleEventObserver(Object object) {    boolean isLifecycleEventObserver = object instanceof LifecycleEventObserver;    boolean isFullLifecycleObserver = object instanceof FullLifecycleObserver;    if (isLifecycleEventObserver &amp;&amp; isFullLifecycleObserver) {        return new FullLifecycleObserverAdapter((FullLifecycleObserver) object,                (LifecycleEventObserver) object);    }    if (isFullLifecycleObserver) {        return new FullLifecycleObserverAdapter((FullLifecycleObserver) object, null);    }    if (isLifecycleEventObserver) {        return (LifecycleEventObserver) object;    }    // 处理注解类型为OnLifecycleEvent.class的对象    return new ReflectiveGenericLifecycleObserver(object);}执行生命周期事件传递// LifecycleRegistry.ObserverWithStatevoid dispatchEvent(LifecycleOwner owner, Event event) {\t\t// 获取执行event事件后的下一个生命周期状态    State newState = getStateAfter(event);    mState = min(mState, newState);    // 使用刚才生成的代理状态分发生命周期事件    mLifecycleObserver.onStateChanged(owner, event);    mState = newState;}//Lifecycle.javapublic State getTargetState() {    switch (this) {        case ON_CREATE:        case ON_STOP:            return State.CREATED;        case ON_START:        case ON_PAUSE:            return State.STARTED;        case ON_RESUME:            return State.RESUMED;        case ON_DESTROY:            return State.DESTROYED;        case ON_ANY:            break;    }    throw new IllegalArgumentException(this + \" has no target state\");} 至此一个Lifecycle对象的观察者就添加完成了，那么Activity作为一个LifecycleOwner对象，怎么把生命周期改变的状态传递给LifecycleRegistry对象的呢。这里主要使用了常用的三方库的方式，使用一个Fragment来分发相关的生命周期状态。这里使用的是ReportFragment，下面是ReportFragment的相关代码// public class ReportFragment extends Fragment {    private static final String REPORT_FRAGMENT_TAG = \"androidx.lifecycle\"            + \".LifecycleDispatcher.report_fragment_tag\";    public static void injectIfNeededIn(Activity activity) {        // FragmentActivity from support lib, so we use framework fragments for activities        android.app.FragmentManager manager = activity.getFragmentManager();        if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {            manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();            // Hopefully, we are the first to make a transaction.            manager.executePendingTransactions();        }    }    static ReportFragment get(Activity activity) {        return (ReportFragment) activity.getFragmentManager().findFragmentByTag(                REPORT_FRAGMENT_TAG);    }    private ActivityInitializationListener mProcessListener;    @Override    public void onActivityCreated(Bundle savedInstanceState) {        super.onActivityCreated(savedInstanceState);        dispatch(Lifecycle.Event.ON_CREATE);    }    @Override    public void onStart() {        super.onStart();        dispatch(Lifecycle.Event.ON_START);    }    @Override    public void onResume() {        super.onResume();        dispatch(Lifecycle.Event.ON_RESUME);    }    @Override    public void onPause() {        super.onPause();        dispatch(Lifecycle.Event.ON_PAUSE);    }    @Override    public void onStop() {        super.onStop();        dispatch(Lifecycle.Event.ON_STOP);    }    @Override    public void onDestroy() {        super.onDestroy();        dispatch(Lifecycle.Event.ON_DESTROY);    }    private void dispatch(Lifecycle.Event event) {        Activity activity = getActivity();        // 分发事件        if (activity instanceof LifecycleOwner) {            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();            if (lifecycle instanceof LifecycleRegistry) {                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);            }        }    }}通过injectIfNeededIn方法，使Fragment添加到Activity中，然后生命周期变化的时候，通过handleLifecycleEvent把生命周期方法转发给LifecycleRegistrypublic void handleLifecycleEvent(@NonNull Lifecycle.Event event) {    enforceMainThreadIfNeeded(\"handleLifecycleEvent\");    moveToState(event.getTargetState());}private void moveToState(State next) {    if (mState == next) {        return;    }    mState = next;    // 如果正在进行事件的分发，则就不用重复进行了    if (mHandlingEvent || mAddingObserverCounter != 0) {        mNewEventOccurred = true;        // we will figure out what to do on upper level.        return;    }    mHandlingEvent = true;    // 通知每一个观察者    sync();    mHandlingEvent = false;}private void sync() {    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();    if (lifecycleOwner == null) {        throw new IllegalStateException(\"LifecycleOwner of this LifecycleRegistry is already\"                                        + \"garbage collected. It is too late to change lifecycle state.\");    }    while (!isSynced()) {        mNewEventOccurred = false;        // mObserverMap内部有一个hashMap储存元素同时也会储存到一个双链表中        // 如果当前状态小于最后添加元素的状态，则倒序同步        if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) {            backwardPass(lifecycleOwner);        }        Map.Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();        if (!mNewEventOccurred &amp;&amp; newest != null            &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) {            // 从前往后同步            forwardPass(lifecycleOwner);        }    }    mNewEventOccurred = false;}private boolean isSynced() {    if (mObserverMap.size() == 0) {        return true;    }    State eldestObserverState = mObserverMap.eldest().getValue().mState;    State newestObserverState = mObserverMap.newest().getValue().mState;    // 首位元素都等于当前元素了表示同步完成了    return eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState;}"
  },
  
  {
    "title": "Android文件目录概览",
    "url": "/posts/storage-path/",
    "categories": "Android",
    "tags": "android, storage",
    "date": "2022-05-24 22:33:00 +0800",
    





    "snippet": "外部储存可以在手机中直接查看的目录，目录为Android/data/&lt;package name&gt;/xxx 下的系列文件  传入的参数不要以“/”开始//主要对应`Android/data/&lt;package name&gt;/files/`下的文件目录,传入空则为根目录val externalFilesDir = getExternalFilesDir(\"plugin/app-debug.apk\")//path: /storage/emulated/0/Android/data/com.jiangker.testapplication/files/plugin/app-debug.apkLog.i(TAG, \"path: ${externalFilesDir?.path}\")//name: app-debug.apkLog.i(TAG, \"name: ${externalFilesDir?.name}\")//absolutePath: /storage/emulated/0/Android/data/com.jiangker.testapplication/files/plugin/app-debug.apkLog.i(TAG, \"absolutePath: ${externalFilesDir?.absolutePath}\")//canonicalPath: /storage/emulated/0/Android/data/com.jiangker.testapplication/files/plugin/app-debug.apkLog.i(TAG, \"canonicalPath: ${externalFilesDir?.canonicalPath}\")另外还有缓存目录//主要对应Android/data/&lt;package name&gt;/cache/下的文件目录val externalCacheDir = externalCacheDir内部储存只能在as中看到的目录，对应在/data/data/&lt;package name&gt;/ 下的系列文件  对应的sp目录也是在这个下，对应/data/data/&lt;package name&gt;/shared_prefs/getDir(String name, int mode)方法//调用这个方法会在根目录下生成一个文件夹，在对应的名字前会加上app_,现在模式只有这一个可以使用了val dir = getDir(\"pulgin\", Context.MODE_PRIVATE)//path: /data/user/0/com.jiangker.testapplication/app_pulginLog.i(TAG, \"path: ${dir?.path}\")//name: app_pulginLog.i(TAG, \"name: ${dir?.name}\")//absolutePath: /data/user/0/com.jiangker.testapplication/app_pulginLog.i(TAG, \"absolutePath: ${dir?.absolutePath}\")//canonicalPath: /data/data/com.jiangker.testapplication/app_pulginLog.i(TAG, \"canonicalPath: ${dir?.canonicalPath}\")getCacheDir()方法//直接获取其下的cache目录val dir = cacheDir//path: /data/user/0/com.jiangker.testapplication/cacheLog.i(TAG, \"path: ${dir?.path}\")//name: cacheLog.i(TAG, \"name: ${dir?.name}\")//absolutePath: /data/user/0/com.jiangker.testapplication/cacheLog.i(TAG, \"absolutePath: ${dir?.absolutePath}\")//canonicalPath: /data/data/com.jiangker.testapplication/cacheLog.i(TAG, \"canonicalPath: ${dir?.canonicalPath}\")getFilesDir()方法与cache类似，对应文件夹files//直接获取其下的files目录val dir = filesDir//path: /data/user/0/com.jiangker.testapplication/filesLog.i(TAG, \"path: ${dir?.path}\")//name: filesLog.i(TAG, \"name: ${dir?.name}\")//absolutePath: /data/user/0/com.jiangker.testapplication/filesLog.i(TAG, \"absolutePath: ${dir?.absolutePath}\")//canonicalPath: /data/data/com.jiangker.testapplication/filesLog.i(TAG, \"canonicalPath: ${dir?.canonicalPath}\")getCodeCacheDir()方法与cache类似，对应文件夹code_cache//直接获取其下的code_cache目录val dir = codeCacheDir//path: /data/user/0/com.jiangker.testapplication/code_cacheLog.i(TAG, \"path: ${dir?.path}\")//name: code_cacheLog.i(TAG, \"name: ${dir?.name}\")//absolutePath: /data/user/0/com.jiangker.testapplication/code_cacheLog.i(TAG, \"absolutePath: ${dir?.absolutePath}\")//canonicalPath: /data/data/com.jiangker.testapplication/code_cacheLog.i(TAG, \"canonicalPath: ${dir?.canonicalPath}\")getFileStreamPath(String name)方法对应的files中的文件路径//对应files中存放了一个app-debug.apk文件val fileStreamPath = getFileStreamPath(\"app-debug.apk\")//path: /data/user/0/com.jiangker.testapplication/files/app-debug.apkLog.i(TAG, \"path: ${fileStreamPath?.path}\")//name: app-debug.apkLog.i(TAG, \"name: ${fileStreamPath?.name}\")//absolutePath: /data/user/0/com.jiangker.testapplication/files/app-debug.apkLog.i(TAG, \"absolutePath: ${fileStreamPath?.absolutePath}\")//canonicalPath: /data/data/com.jiangker.testapplication/files/app-debug.apkLog.i(TAG, \"canonicalPath: ${fileStreamPath?.canonicalPath}\")"
  },
  
  {
    "title": "SharePreferences的基础使用",
    "url": "/posts/shared-preferences/",
    "categories": "Android",
    "tags": "android, sharedpreferences",
    "date": "2022-05-24 22:23:00 +0800",
    





    "snippet": "获取SharedPreferences对象要想使用SharedPrefernces储存数据，首先要获取SharedPreferences对象。主要获取方式有以下两种Context类中的getSharedPreferences()方法//第一个参数为储存的文件名，第二个参数是操作模式，现只有一种val edit : SharedPreferences = getSharedPreferences(\"data\", Context.MODE_PRIVATE)Activity类中的getPreferences()方法//默认储存的文件名为Activity的类名val edit : SharedPreferences = getPreferences(Context.MODE_PRIVATE)SharedPrefernces文件都是存放在/data/data//shared_prefs/目录下的写入数据//获取操作对象val edit : SharedPreferences.Editor = getSharedPreferences(\"data\", Context.MODE_PRIVATE).edit()//设置键值对edit.putString(\"name\",\"jiangker\")//原子操作，无返回值，先同步写入到内存，异步写入到磁盘，效率高，但写入是阻塞操作，线程安全edit.apply()//原子操作，有返回值，都是同步的操作//edit.commit()读取数据val sharedPreferences = getSharedPreferences(\"data\", Context.MODE_PRIVATE)//第一个参数为查找的key，第二个参数为查找失败的返回值val name = sharedPreferences.getString(\"name\", \"admin\")"
  },
  
  {
    "title": "树莓派使用docker安装homeassistant",
    "url": "/posts/homeassistant/",
    "categories": "RaspberryPi, application",
    "tags": "raspberrypi, homeassistant",
    "date": "2022-04-15 15:38:00 +0800",
    





    "snippet": "使用Docker安装homeassistantRaspberry Pi Install Home Assistant Operating Systemsudo docker run -d \\  --name homeassistant \\  --privileged \\  --restart=unless-stopped \\  -e TZ=MY_TIME_ZONE \\  -v /PATH_TO_YOUR_CONFIG:/config \\  --network=host \\  ghcr.io/home-assistant/home-assistant:stable      /PATH_TO_YOUR_CONFIG config文件挂载位置        MY_TIME_ZONE is a tz database name, like TZ=Asia/Shanghai.  例如sudo docker run -d \\  --name homeassistant \\  --privileged \\  --restart=unless-stopped \\  -e TZ=Asia/Shanghai \\  -v /home/docker/homeassistant/:/config \\  --network=host \\  ghcr.io/home-assistant/home-assistant:stable待安装完成，访问http://:8123就可以看到网站了局域网nginx转发端口Nginx安装因为默认是运行在8123端口的，因为没有使用docker的端口挂载，使用这里使用nginx配置80转发8123端口在nginx的conf.d目录下创建文件sudo vim /etc/nginx/conf.d/homeassistant.conf写入转发规则server {        listen 80;        server_name 192.168.0.100;        location / {                proxy_pass http://127.0.0.1:8123/;\t\t# websocket support\t\tproxy_http_version 1.1;\t\tproxy_set_header Upgrade $http_upgrade;\t\tproxy_set_header Connection \"upgrade\";        }}如果未设置websocket支持，则会出现Unable to connect to Home Assistant提示，如下图增加转发头的配置server {        listen 80;        server_name 192.168.0.100;        location / {                proxy_pass http://127.0.0.1:8123/;\t\tproxy_set_header Host $host;        \tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\t\t# websocket support\t\tproxy_http_version 1.1;\t\tproxy_set_header Upgrade $http_upgrade;\t\tproxy_set_header Connection \"upgrade\";        }}这样的配置还需要配置一下允许转发否则会出现400: Bad Requesthomeassistant-http进入到配置文件目录cd /home/docker/homeassistant打开配置文件sudo vim configuration.yaml在文件中追加http:  use_x_forwarded_for: true  trusted_proxies:    - 127.0.0.1验证有效性并且重新启动命令重启homeassistantsudo docker restart homeassistant"
  },
  
  {
    "title": "树莓派安装docker",
    "url": "/posts/docker/",
    "categories": "RaspberryPi, application",
    "tags": "raspberrypi, docker",
    "date": "2022-04-15 12:18:00 +0800",
    





    "snippet": "树莓派系统树莓派版本 - 树莓派 4b 8g系统版本 - Raspberry Pi OS Lite(64-bit) 2022-04-04 Raspberry OsInstall Docker Engine在Install Docker Engine中选择支持的平台，这里选择Raspbian，可以看到其实也是 Debian 的路径。以下步骤与官网相同卸载旧版本sudo apt-get remove docker docker-engine docker.io containerd runc开始安装设置源sudo apt-get install \\    ca-certificates \\    curl \\    gnupg \\    lsb-releasecurl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpgecho \\  \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\  $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt-get update下载Engine查看apt中有哪些版本apt-cache madison docker-ce输出➜  ~ apt-cache madison docker-cedocker-ce | 5:20.10.14~3-0~debian-bullseye | https://download.docker.com/linux/debian bullseye/stable arm64 Packagesdocker-ce | 5:20.10.13~3-0~debian-bullseye | https://download.docker.com/linux/debian bullseye/stable arm64 Packagesdocker-ce | 5:20.10.12~3-0~debian-bullseye | https://download.docker.com/linux/debian bullseye/stable arm64 Packagesdocker-ce | 5:20.10.11~3-0~debian-bullseye | https://download.docker.com/linux/debian bullseye/stable arm64 Packagesdocker-ce | 5:20.10.10~3-0~debian-bullseye | https://download.docker.com/linux/debian bullseye/stable arm64 Packagesdocker-ce | 5:20.10.9~3-0~debian-bullseye | https://download.docker.com/linux/debian bullseye/stable arm64 Packagesdocker-ce | 5:20.10.8~3-0~debian-bullseye | https://download.docker.com/linux/debian bullseye/stable arm64 Packagesdocker-ce | 5:20.10.7~3-0~debian-bullseye | https://download.docker.com/linux/debian bullseye/stable arm64 Packagesdocker-ce | 5:20.10.6~3-0~debian-bullseye | https://download.docker.com/linux/debian bullseye/stable arm64 Packages下载指定版本的enginesudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io例如下载5:20.10.14~3-0~debian-bullseye的sudo apt-get install docker-ce=5:20.10.14~3-0~debian-bullseye docker-ce-cli=5:20.10.14~3-0~debian-bullseye containerd.io直接下载最新版sudo apt-get install docker-ce docker-ce-cli containerd.io这里下载docker-ce时可能提示有错(如果没错就表示安装完成了，可以直接下一步了)➜  ~ sudo apt-get install docker-ce docker-ce-cli containerd.ioReading package lists... DoneBuilding dependency tree... DoneReading state information... DoneSome packages could not be installed. This may mean that you haverequested an impossible situation or if you are using the unstabledistribution that some required packages have not yet been createdor been moved out of Incoming.The following information may help to resolve the situation:The following packages have unmet dependencies: docker-ce : Depends: iptablesE: Unable to correct problems, you have held broken packages.可以看出docker-ce : Depends: iptables提示iptables需要先下载，那么就先下载iptablessudo apt-get install iptables输出➜  ~ sudo apt-get install iptablesReading package lists... DoneBuilding dependency tree... DoneReading state information... DoneSome packages could not be installed. This may mean that you haverequested an impossible situation or if you are using the unstabledistribution that some required packages have not yet been createdor been moved out of Incoming.The following information may help to resolve the situation:The following packages have unmet dependencies: iptables : Depends: libxtables12 (= 1.8.2-4) but 1.8.7-1 is to be installedE: Unable to correct problems, you have held broken packages.可以看出这里依赖的libxtables12版本不是最新的，使用apt-cache madison libxtables12查看可用版本➜  ~ apt-cache madison libxtables12libxtables12 | 1.8.5-3~bpo10+1 | https://mirrors.tuna.tsinghua.edu.cn/debian buster-backports/main arm64 Packageslibxtables12 |    1.8.2-4 | https://mirrors.tuna.tsinghua.edu.cn/debian buster/main arm64 Packages直接下载对应版本sudo apt-get install libxtables12=1.8.2-4再下载sudo apt-get install iptables最后下载enginesudo apt-get install docker-ce docker-ce-cli containerd.io上面的选择了更旧的版本，但是这里测试过也可以都更新成最新的版本，只要版本号一直都按范围匹配就行了，这里就不再啰嗦的都列上了测试安装效果sudo docker run hello-world输出，可以看到已经可以正常运行了➜  ~ sudo docker run hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-world7050e35b49f5: Pull completeDigest: sha256:10d7d58d5ebd2a652f4d93fdd86da8f265f5318c6a73cc5b6a9798ff6d2b2e67Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.    (arm64v8) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/修改镜像源创建文件sudo vim /etc/docker/daemon.json添加{    \"registry-mirrors\": [        \"https://docker.mirrors.ustc.edu.cn\", # 中国技术大学        \"https://registry.docker-cn.com\" # docker中国    ]}重启sudo service docker restart"
  },
  
  {
    "title": "树莓派数据源",
    "url": "/posts/mirrors/",
    "categories": "RaspberryPi, Init",
    "tags": "raspberrypi, mirrors",
    "date": "2022-04-10 22:54:00 +0800",
    





    "snippet": "arm64系统源  现在的主流编辑文件/etc/apt/sources.list，增加以下内容# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free配置官方源，修改文件/etc/apt/sources.list.d/raspi.list，增加以下内容deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui32位arm编辑文件/etc/apt/sources.list，增加以下内容deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpideb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpi修改文件/etc/apt/sources.list.d/raspi.list，增加以下内容deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui最后更新源和软件sudo apt updatesudo apt upgrade -y参考树莓派4B 64位（arm64）系统配置系统源"
  },
  
  {
    "title": "Rsync-文件同步",
    "url": "/posts/rsync/",
    "categories": "Ubuntu",
    "tags": "rsync",
    "date": "2022-03-27 13:25:00 +0800",
    





    "snippet": "安装  服务器和本地都需要安装的有sudo apt-get install rsync远程同步到本地# dir文件夹同步到home目录下，即 /home/dirsudo rsync -avz root@xxx.xxx.xxx.xxx:/root/dir /home# dir文件夹里的内容同步到/home/dir目录下，即 /home/dirsudo rsync -avz root@xxx.xxx.xxx.xxx:/root/dir/ /home/dir"
  },
  
  {
    "title": "Nginx反向代理",
    "url": "/posts/nginx/",
    "categories": "Ubuntu",
    "tags": "nginx",
    "date": "2022-03-26 20:23:00 +0800",
    





    "snippet": "安装Nginxsudo apt updatesudo apt install nginxsudo systemctl status nginx打开http://&lt;host&gt;:80即刻看到nginx的欢迎页面主要配置  确认nginx.conf文件的config配置引入，配置开启websocket前往目录cd /etc/nginx打开文件sudo vim nginx.conf确保没有注释掉config引入http {        include /etc/nginx/conf.d/*.conf;        include /etc/nginx/sites-enabled/*;}开启支持websocket打开文件sudo vim nginx.conf在http域中增加map $http_upgrade $connection_upgrade {        default upgrade;        ''      close;}例如http {        #...        map $http_upgrade $connection_upgrade {                default upgrade;                ''      close;        }        #...}创建端口和路由转发创建文件sudo vim /etc/nginx/conf.d/server.conf添加server {        # 局域网端口        listen 80;        # 局域网ip        server_name 192.168.0.108;        # 匹配 http://192.168.0.108:80/test/tv =&gt; http://192.168.0.108:8081/tv        location /test/ {                proxy_pass http://192.168.0.108:8081/;        }        location / {                proxy_pass http://192.168.0.108:8080/;        }        # 匹配 http://192.168.0.108:80/test/tv =&gt; http://192.168.0.108:8081/test/tv        #location /test/ {        #        proxy_pass http://192.168.0.108:8081;        #}}控制操作重新加载配置sudo nginx -s reload启动nginxsudo systemctl start nginx关闭nginxsudo systemctl stop nginx"
  },
  
  {
    "title": "Frp-内网穿透",
    "url": "/posts/frp/",
    "categories": "Ubuntu",
    "tags": "frp",
    "date": "2022-03-26 19:34:00 +0800",
    





    "snippet": "1. 下载安装程序  需区分不同平台      gofrp官网        gitlab        dowload地址  2. 准备# scp 发送到对应服务器sudo scp frp_xxx.tar.gz root@xx.xx.xx.xx:/root/frp# 解压sudo tar -zxvf frp_xxx.tar.gz .3. 服务器端  frps.ini （server）为服务器配置文件# vim frps.ini# 增加[common]# frp依赖的端口bind_port = 7000token = xxxx-xxxx# 控制地址的端口和账号密码dashboard_port = 7500dashboard_user = jiangkerdashboard_pwd = xxxx# http端口vhost_http_port = 8080运行服务器# 后台运行./frps -c ./frps.ini &amp;!# 搜索进程ps aux | grep frps# 关闭kill xxx4. 内网机器  frpc.ini （client）为客户端配置文件vim frpc.ini# 修改内容[common]# server_addr = xx.xx.xx.xxserver_port = 7000token = xxxx-xxxx[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 8888[web2]type = httplocal_port = 80custom_domains = www.jiangker.cn也可以使用更简洁的方式配置二级域名# 公网 frps.inisubdomain_host = jiangker.cn# 内网 frpc.inisubdomain = www运行客户端# 后台运行./frpc -c ./frpc.ini &amp;!# 搜索进程ps aux | grep frpc# 关闭kill xxx远程访问ssh时使用ssh -p 8888 root@xxx.xxx.xxx.xxx"
  },
  
  {
    "title": "Interceptor的使用",
    "url": "/posts/interceptor/",
    "categories": "SpringBoot",
    "tags": "interceptor",
    "date": "2022-03-22 23:30:00 +0800",
    





    "snippet": "定义拦截器@Slf4jpublic class CustomHandlerInterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(@NotNull HttpServletRequest request,                             @NotNull HttpServletResponse response,                             @NotNull Object handler) throws Exception {        log.info(\"preHandle:请求前调用\");        //返回 false 则请求中断        return true;    }    @Override    public void postHandle(@NotNull HttpServletRequest request,                           @NotNull HttpServletResponse response,                           @NotNull Object handler,                           ModelAndView modelAndView) throws Exception {        log.info(\"postHandle:请求后调用\");    }    @Override    public void afterCompletion(            @NotNull HttpServletRequest request,            @NotNull HttpServletResponse response,            @NotNull Object handler, Exception ex    ) throws Exception {        log.info(\"afterCompletion:请求调用完成后回调方法，即在视图渲染完成后回调\");    }}注册@Configurationpublic class MyWebMvcConfigurer implements WebMvcConfigurer {    @Override    public void addInterceptors(InterceptorRegistry registry) {        //注册拦截器 拦截规则        //多个拦截器时 以此添加 执行顺序按添加顺序        registry.addInterceptor(new CustomHandlerInterceptor()).addPathPatterns(\"/**\");    }}单次请求数据共享class DemoInterceptor : HandlerInterceptor {    companion object {        val demoLocalThread = object : ThreadLocal&lt;String&gt;() {            override fun initialValue(): String {                return \"\"            }        }    }    @Throws(Exception::class)    override fun preHandle(request: HttpServletRequest, response: HttpServletResponse, handler: Any): Boolean {        val init = demoLocalThread.get()        val name = request.getHeader(\"name\")        demoLocalThread.set(init + \"name: $name\" + \"\\npreHandle thread ${Thread.currentThread()}\")        return true    }    @Throws(Exception::class)    override fun postHandle(request: HttpServletRequest, response: HttpServletResponse, handler: Any, modelAndView: ModelAndView?) {        val init = demoLocalThread.get()        demoLocalThread.set(init + \"\\npostHandler thread ${Thread.currentThread()}\")    }    @Throws(Exception::class)    override fun afterCompletion(request: HttpServletRequest, response: HttpServletResponse, handler: Any, ex: Exception?) {        val init = demoLocalThread.get()        demoLocalThread.set(init + \"\\nafterCompletion thread ${Thread.currentThread()}\")        println(demoLocalThread.get())        demoLocalThread.remove()    }}使用threadlocal实现，用户登陆信息获取到时可以存入threadLocal，这样在controller中就可以直接获取来使用了。"
  },
  
  {
    "title": "Filter的使用",
    "url": "/posts/servelet-filter/",
    "categories": "SpringBoot",
    "tags": "filter",
    "date": "2022-03-22 22:43:00 +0800",
    





    "snippet": "1. 自动注册  触发顺序依赖文件名A-Z@Slf4j@WebFilter(filterName = \"CustomFilter\",urlPatterns = {\"/*\"})public class CustomFilter implements Filter {    @Override    public void init(FilterConfig filterConfig) throws ServletException {        log.info(\"init -&gt; \" + filterConfig);    }    @Override    public void doFilter(        ServletRequest servletRequest,         ServletResponse servletResponse,         FilterChain filterChain    ) throws IOException, ServletException {        log.info(\"customFilter 请求处理之前----doFilter方法之前过滤请求\");        //对request、response进行一些预处理        // 比如设置请求编码        // request.setCharacterEncoding(\"UTF-8\");        // response.setCharacterEncoding(\"UTF-8\");        //链路 直接传给下一个过滤器        filterChain.doFilter(servletRequest, servletResponse);        log.info(\"customFilter 请求处理之后----doFilter方法之后处理响应\");    }    @Override    public void destroy() {        log.info(\"filter 销毁\");    }}启动器增加 @ServletComponentScan@SpringBootApplication@ServletComponentScanpublic class SpringBootStudyApplication {    public static void main(String[] args) {        SpringApplication.run(SpringBootStudyApplication.class, args);    }}2. 手动注册  需去掉Filter中的 @WebFilter 注解@Configurationpublic class FilterRegistration {    @Bean    public FilterRegistrationBean&lt;CustomFilter&gt; filterRegistrationBean() {        FilterRegistrationBean&lt;CustomFilter&gt; registration = new FilterRegistrationBean&lt;&gt;();        //Filter可以new，也可以使用依赖注入Bean        registration.setFilter(new CustomFilter());        //过滤器名称        registration.setName(\"customFilter\");        //拦截路径        registration.addUrlPatterns(\"/*\");        //设置顺序        registration.setOrder(10);        return registration;    }}"
  },
  
  {
    "title": "SpringBoot接入Lombok",
    "url": "/posts/lombok/",
    "categories": "SpringBoot",
    "tags": "lombok",
    "date": "2022-03-21 09:50:00 +0800",
    





    "snippet": "添加依赖&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;增加plugin常用注解  @Data  会自动为数据类增加 get &amp; set &amp; equals &amp; canEqual &amp; hashCode &amp; toString 方法@Datapublic class User {    private String name;    private String uid;    private String email;}  @Slf4j  自动引入类相关的log参数@Slf4jpublic class User {    private String name;    private String uid;    private String email;}等价public class User {    private static final Logger log = LoggerFactory.getLogger(User.class);    // ...}  @Builder@Builderpublic class User {    private String name;    private String uid;    private String email;}就可以使用builder模式来构造对象了User user1 = User.builder()        .uid(uid)        .name(uid + \": \" + System.currentTimeMillis())        .email(uid + \"@definesys.com\").build();会导致类变成全参的构造方法，并且是default的构造函数  @AllArgsConstructor &amp; @NoArgsConstructor  一个是全参构造函数，一个是无参构造函数@NoArgsConstructor@AllArgsConstructorpublic class User {    private String name;    private String uid;    private String email;}等价于增加构造函数public User() {}public User(final String name, final String uid, final String email) {    this.name = name;    this.uid = uid;    this.email = email;}"
  },
  
  {
    "title": "SpringBoot接入Redis",
    "url": "/posts/redis/",
    "categories": "SpringBoot",
    "tags": "redis",
    "date": "2022-03-20 23:50:00 +0800",
    





    "snippet": "配置依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt;dependencies {    implementation(\"org.springframework.boot:spring-boot-starter-data-redis\")    implementation(\"org.apache.commons:commons-pool2\")}application.yml配置server:  port: 8082  servlet:    context-path: /demospring:  redis:    # 远程的地址，如果为本地可以不写    host: xx.xx.xx.xx    port: 6379    # 远程密码，可以不写    password: xxxx    # 连接超时时间    timeout: 10000ms    database: 0    lettuce:      pool:        # 连接池最大连接数 ，默认8，写负数表示没有限制        max-active: 20        # 连接池最大空闲连接，默认8        max-idle: 5        # 连接池最大阻塞等待时间        max-wait: 5000ms        # 连接池中的最小空闲连接，默认0        min-idle: 20基础命令链接本地redis服务redis-cli如果有设置密码，则使用来登录redis-cli -a &lt;password&gt;代码获取操作对象直接依赖注入@Autowiredprivate lateinit var redisTemplate: StringRedisTemplate存储字符串类似map，根据key存储字符串，也提供对于数字的增加或减少操作，可以用于统计热度等需要频繁更新的数据，减少数据库访问客户端命令# 设置指定 key 的值。SET key value# 根据key获取值，如果为空返回(nil)GET key# 给 key 设置新 value ，并返回旧值GETSET key value# 给key的value加一，必须要是整数INCR key代码访问// 获取字符串操作对象val operations = redisTemplate.opsForValue()operations.get(\"key\")operations.set(\"key\",\"value\")// 给定加一，没有的默认为0operations.increment(\"key\", 1L)ListRedis列表类似与双向队列，可以从左边或者右边插入元素，会保持元素插入顺序。客户端命令# 将值添加到列表头部LPUSH key value# 获取指定列表范围元素LRANGE key start stop# 移除列表元素LREM key count value# 移出并获取列表的第一个元素LPOP key代码访问val list = redisTemplate.opsForList()list.leftPush(\"list\", \"value0\")list.leftPop(\"list\")// 是左indexlist.index(\"list\", 1)SET和Java的set类似，使用Hash表实现，不能有重复元素，也是无序的。客户端命令# 添加元素SADD key member# 获取sizeSCARD key# 返回所有元素SMEMBERS key# 获取一个元素SPOP key代码访问val set = redisTemplate.opsForSet()set.add(\"set\", \"value\")val member: Boolean? = set.isMember(\"set\",\"value\")val members: Set&lt;String&gt;? = set.members(\"set\")ZSET带有顺序的set，关联一个score来进行排序，score可以重复，元素不可以重复客户端命令# 向有序集合添加一个元素，或更新分数ZADD key score1 member1# 获取有序集合的成员数ZCARD key代码访问val set = redisTemplate.opsForZSet()set.add(\"set\", \"value1\", 1.0)set.add(\"set\", \"value2\", 1.0)set.popMin(\"set\")set.popMax(\"set\")Hash# 获取存储在哈希表中指定字段的值。HGET key fieldval map = redisTemplate.opsForHash&lt;String, String&gt;()map.put(\"map\", \"key\", \"value\")map.get(\"map\",\"key\")Cache启动类添加注解@EnableCaching@SpringBootApplication@EnableCachingpublic class SpringBootStudyApplication {    public static void main(String[] args) {        SpringApplication.run(SpringBootStudyApplication.class, args);    }}配置类package com.jfp.study;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.cache.RedisCacheWriter;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.*;import java.time.Duration;import java.util.HashMap;import java.util.Map;@Configurationpublic class RedisConfig {    @Bean    RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();        redisTemplate.setConnectionFactory(redisConnectionFactory);        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());        redisTemplate.setKeySerializer(new StringRedisSerializer());        redisTemplate.setHashKeySerializer(new StringRedisSerializer());        redisTemplate.afterPropertiesSet();        return redisTemplate;    }    @Bean    public RedisCacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory) {        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));        redisCacheConfiguration.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()));        Map&lt;String, RedisCacheConfiguration&gt; redisExpireConfig = new HashMap&lt;&gt;();        //这里设置了一个一分钟的超时配置，如果需要增加更多超时配置参考这个新增即可        redisExpireConfig.put(\"1min\", RedisCacheConfiguration.defaultCacheConfig()                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()))                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))                .entryTtl(Duration.ofMinutes(1)).disableCachingNullValues());        RedisCacheManager redisCacheManager = RedisCacheManager.builder(RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory))                .cacheDefaults(redisCacheConfiguration)                .withInitialCacheConfigurations(redisExpireConfig)                .transactionAware()                .build();        return redisCacheManager;    }}实体类  此处如果直接使用kotlin的data class，需要结合@JsonTypeInfopublic class User {    private String name;    private String uid;    private String email;        //get &amp;&amp; set ....}使用@RestController@RequestMapping(value = \"/user\")public class UserController {    @GetMapping(value = \"/info\")    @Cacheable(value = \"user\", key = \"#uid\")    public User getUser(@RequestParam(value = \"uid\") String uid) {        System.out.println(\"getUser====&gt;\" + uid);        User user = new User();        user.setUid(uid);        user.setEmail(uid + \"@definesys.com\");        user.setName(uid + \":\" + System.currentTimeMillis());        return user;    }}校验## 输入curl 192.168.0.108:8082/demo/user/info?uid=jiangker01## 输出{\"name\":\"jiangker01: 1647752522128\",\"uid\":\"jiangker01\",\"email\":\"jiangker01@definesys.com\"}缓存过期//这里设置了一个一分钟的超时配置，如果需要增加更多超时配置参考这个新增即可redisExpireConfig.put(\"1min\", RedisCacheConfiguration.defaultCacheConfig()        .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()))        .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))        .entryTtl(Duration.ofMinutes(1)).disableCachingNullValues());@GetMapping(value = \"/info\")@Cacheable(value = \"1min\", key = \"#uid\")public User getUser(@RequestParam(value = \"uid\") String uid) {    //...}则存入的数据会在一分钟之后过期。缓存相关注解除了Cacheable还有其他跟缓存相关的注解      CachePut    CachePut可以将数据放入缓存，一般insert操作和update操作可以使用该注解，如果指定的key数据存在就更新数据        CacheEvict    CacheEvict可以删除缓存数据，一般delete操作的接口可以使用该注解        Caching    Caching是三个的集合，定义如下  public @interface Caching {    Cacheable[] cacheable() default {};    CachePut[] put() default {};    CacheEvict[] evict() default {};}完整案例@RestController@RequestMapping(\"user\")public class RedisController {    @Autowired    private UserMapper userMapper;    @PostMapping(\"/add\")    @CachePut(value = \"neverExpire\", key = \"#user.uid\")    public User add(@RequestBody User user) {        userMapper.insert(user);        return user;    }    @PostMapping(\"/update\")    @CachePut(value = \"neverExpire\", key = \"#user.uid\")    public User update(@RequestBody User user) {        return user;    }    @GetMapping(\"/delete\")    @CacheEvict(value = \"neverExpire\", key = \"#uid\")    public String delete(@RequestParam(value = \"uid\") String uid) {        return uid;    }    @GetMapping(\"/detail\")    @Cacheable(value = \"neverExpire\", key = \"#result\")    public User deteail(@RequestParam(value = \"uid\") String uid) {        QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();        queryWrapper.eq(\"uid\", uid);        return userMapper.selectOne(queryWrapper);    }}参考Spring boot 集成Redis"
  },
  
  {
    "title": "docker安装redis",
    "url": "/posts/docker-redis/",
    "categories": "Other, Docker",
    "tags": "docker, redis",
    "date": "2022-03-20 14:36:00 +0800",
    





    "snippet": "获取镜像docker search redisdocker pull redis创建容器1. 创建相关文件夹# 这里我们在 /home/docker 下创建mkdir /home/docker/redis/{conf,data} -p2. 进入文件夹目录下cd /home/docker/redis3. 获取 redis 的默认配置文件模版# 获取 redis 的默认配置模版# 这里主要是想设置下 redis 的 log / password / appendonly# redis 的 docker 运行参数提供了 --appendonly yes 但没 passwordwget https://gitee.com/hanxt/boot-launch/raw/master/src/main/resources/otherconfig/redis.conf -O conf/redis.conf# 直接替换编辑sed -i 's/logfile \"\"/logfile \"access.log\"/' conf/redis.conf;sed -i 's/# requirepass foobared/requirepass 123456/' conf/redis.conf;sed -i 's/appendonly no/appendonly yes/' conf/redis.conf;sed -i 's/bind 127.0.0.1/bind 0.0.0.0/' conf/redis.conf;  sed -i是linux文件替换命令，替换格式为s/被替换的内容/替换之后的内容/  替换logfile ““为logfile “access.log”,指定日志文件名称为access.log  替换# requirepass foobared为requirepass 123456,指定访问密码为123456  替换“appendonly no“为”appendonly yes”，开启appendonly模式  替换绑定IP“bind 127.0.0.1”为“bind 0.0.0.0”          protected-mode 是在没有显式定义 bind 地址（即监听全网段），又没有设置密码 requirepass时，protected-mode 只允许本地回环 127.0.0.1 访问。所以改为bind 0.0.0.0      4. 创建容器# 创建并运行一个名为 myredis 的容器docker run \\-p 6379:6379 \\-v $PWD/data:/data \\-v $PWD/conf/redis.conf:/etc/redis/redis.conf \\--privileged=true \\--name myredis \\-d redis:5.0.5 redis-server /etc/redis/redis.conf命令含义# 命令分解docker run \\-p 6379:6379 \\ # 端口映射 宿主机:容器-v $PWD/data:/data:rw \\ # 映射磁盘目录 rw 为读写，宿主机目录：容器目录-v $PWD/conf/redis.conf:/etc/redis/redis.conf:ro \\ # 挂载配置文件 ro 为readonly--privileged=true \\ # 给与一些权限--name myredis \\ # 给容器起个名字-d redis redis-server /etc/redis/redis.conf # deamon 运行容器 并使用配置文件启动容器内的 redis-server ## $PWD是当前目录，也就是/home/docker/redis查看容器情况# 查看活跃的容器docker ps# 如果没有 myredis 说明启动失败 查看错误日志docker logs myredis# 查看 myredis 的 ip 挂载 端口映射等信息docker inspect myredis# 查看 myredis 的端口映射docker port myredis访问测试docker exec -it myredis bashredis-cli"
  },
  
  {
    "title": "SpringBoot常用注解",
    "url": "/posts/anotations/",
    "categories": "SpringBoot",
    "tags": "anitations",
    "date": "2022-03-20 02:43:00 +0800",
    





    "snippet": "1. @SpringBootApplication@SpringBootApplicationclass WebApplicationfun main(args: Array&lt;String&gt;) {\trunApplication&lt;WebApplication&gt;(*args)}我们可以把 @SpringBootApplication看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。  @EnableAutoConfiguration：启用 SpringBoot 的自动配置机制  @ComponentScan： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类。  @Configuration：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类2. @Autowired自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。@Serviceclass UserServiceImpl : UserService@RestController@RequestMapping(\"/user\")class UserController {    @Autowired    lateinit var userService: UserService}3. @Component,@Repository,@Service, @Controller我们一般使用 @Autowired 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,可以采用以下注解实现：  @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。  @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。  @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。  @Controller : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。4. @RestController@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器 bean,并且是将函数的返回值直接填入 HTTP 响应体中,是 REST 风格的控制器。单独使用 @Controller 不加 @ResponseBody的话一般是用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。@Controller +@ResponseBody 返回 JSON 或 XML 形式数据5. @Scope声明 Spring Bean 的作用域，使用方法:import org.springframework.beans.factory.config.BeanDefinition@Scope(value = BeanDefinition.SCOPE_PROTOTYPE)四种常见的 Spring Bean 的作用域：  ConfigurableBeanFactory.SCOPE_SINGLETON : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。  ConfigurableBeanFactory.SCOPE_PROTOTYPE : 每次请求都会创建一个新的 bean 实例。  org.springframework.web.context.WebApplicationContext.SCOPE_REQUEST : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。  org.springframework.web.context.WebApplicationContext.SCOPE_SESSION : 每一个 HTTP Session 会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。6. @Configuration一般用来声明配置类，可以使用 @Component注解替代，不过使用@Configuration注解声明配置类更加语义化。@Configurationclass AppConfig {    @Bean    fun transferService() = TransferServiceImpl()}7. 常见的 HTTP 请求类型  @GetMapping(\"/users\") 等价于@RequestMapping(value=\"/users\",method=RequestMethod.GET), 请求获取数据。  @PostMapping(\"/users\") 等价于@RequestMapping(value=\"/users\",method=RequestMethod.POST), 提交创建新数据。  @PutMapping(\"/users/{userId}\") 等价于@RequestMapping(value=\"/users/{userId}\",method=RequestMethod.PUT), 更新数据  @DeleteMapping(\"/users/{userId}\")等价于@RequestMapping(value=\"/users/{userId}\",method=RequestMethod.DELETE)，删除数据8. 接口接收数据参数-@PathVariable 路径参数@RequestParam 查询参数// /hello?name=jiangfun hello(@RequestParam(name = \"name\") name: String): String {    return \"Hello $name\"}@RequestParam中有四个参数  name 和 value是相同意思，因为默认从key是这里的命名，但如果名称和前端定义不一致就可以使用这个进行映射，添加后就不能按默认参数传参了，但是不可以同时添加。否则这个请求会报错，不能正常响应。  required 表示这个参数是否必传，必传参数如果没有传就会报错，传空字符串也会报错，默认是必传的，但如果没有写@RequestParam则可以不用传，则会为null或者默认值（0）  defaultValue 表示默认参数，如果没有传则为默认参数。当有默认值时，required就无效了，因为都会有值了。注意，如果使用kotlin的默认参数，也是无效的，不能作为默认参数// /hello?name=jiangfun hello(@RequestParam(name = \"name\") name: String = \"jiang\"): String {    return \"Hello $name\"}接收对象参数当有多个参数时，可以直接用参数接收，但是不能再写@RequestParam了，其中参数也都是可以不用传的了。但必须要有无参构造函数，这样才能生效。data class User(    var name: String?,    var age: Int?)或者data class User(    var name: String = \"jiang\",    var age: Int = 18)不可以data class User(    var name: String = \"jiang\",    var age: Int)会报错java.lang.IllegalStateException: No primary or single unique constructor found for class xxx.demos.web.User因为反编译可以看到有两个构造函数了public User(@NotNull String name, int age) {  Intrinsics.checkNotNullParameter(name, \"name\");  super();  this.name = name;  this.age = age;}// $FF: synthetic methodpublic User(String var1, int var2, int var3, DefaultConstructorMarker var4) {  if ((var3 &amp; 1) != 0) {      var1 = \"\";  }  this(var1, var2);}  @RequestBody 用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且Content-Type 为 application/json 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用HttpMessageConverter或者自定义的HttpMessageConverter将请求的 body 中的 json 字符串转换为 java 对象。9. 读取配置信息数据源内容如下：application.ymlspring:  profiles:    active: prodprofiles-active设置环境，选择对应的文件application-dev.ymlapplication:  name: dev环境  version: versionIDdeveloper:  name: dev环境application-prod.ymlapplication:  name: prod环境   version: prod环境 developer:  name: prod环境 ** 使用 @Value(\"${property}\") 读取比较简单的配置信息： **@Value(\"${application.name}\")private String name;@Value(\"${application.version}\")private String version;** 通过@ConfigurationProperties读取配置信息并与 bean 绑定。 **@ConfigurationProperties(prefix = \"developer\")@Componentdata class DeveloperProperty(    name: String,)"
  },
  
  {
    "title": "服务器状态监控netdata",
    "url": "/posts/monitor/",
    "categories": "Ubuntu",
    "tags": "netdata",
    "date": "2022-03-19 10:48:00 +0800",
    





    "snippet": "安装bash &lt;(curl -Ss https://my-netdata.io/kickstart.sh)期间会有几次确认以及几次类似提示安装进度，然后安装完成使用浏览器打开address:19999，就可以看到监控的图了常用命令# 停止 systemctl stop netdata # 启动 systemctl start netdata # 重启 systemctl restart netdata # 开机启动 systemctl enable netdata#卸载netda：sudo bash /usr/libexec/netdata-uninstaller.sh监控树莓派温度# 1.启用sudo bash /etc/netdata/edit-config charts.d.conf# 2.添加sensors=force# 3.重启systemctl restart netdata "
  },
  
  {
    "title": "SSH使用",
    "url": "/posts/ssh/",
    "categories": "Ubuntu",
    "tags": "ssh",
    "date": "2022-03-18 23:05:00 +0800",
    





    "snippet": "链接远程服务器ssh user@address -p port  user 远程用户名  address 服务器地址，ip或域名  port 端口，可以不指定，则为22密钥登陆#1. 首先生成密钥ssh-keygen ## 然后一路回车#或 ssh-keygen -t rsa -C \"niklaus1996@icloud.com\" 指定一下名称#2. 传输密钥到服务端ssh-copy-id user@address -p port# 输入完密码之后，公钥就会被拷贝到服务器对应用户的.ssh/authorized_keys中  若未安装ssh-copy-id的情况，可以使用brew install ssh-copy-id安装  在windows中可以使用ssh user@remote -p port 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub来完成配置别名对于阿里云，想使用ssh ali来登陆，所以可以在 ~/.ssh/config 里面追加以下内容：Host ali    HostName address    User root    Port 22参考  SSH 基本用法"
  },
  
  {
    "title": "更改Ubuntu账户密码",
    "url": "/posts/password/",
    "categories": "Ubuntu",
    "tags": "password",
    "date": "2022-03-18 19:34:00 +0800",
    





    "snippet": "修改密码## 修改密码命令，当前用户passwd# pi➜  ~ passwd# Changing password for pi.# Current password:# New password:# Retype new password:## 重设root用户密码sudo passwd root## 切换到root用户su root"
  },
  
  {
    "title": "树莓派搭建GitLab",
    "url": "/posts/gitlab/",
    "categories": "RaspberryPi",
    "tags": "gitlab",
    "date": "2022-03-18 17:27:00 +0800",
    





    "snippet": "配置及安装  现在一般都使用docker安装了，所以基本上算是不实用了，docker安装更方便树莓派安装gitlabGitLab-ce更新依赖sudo apt-get update安装相关依赖；sudo apt-get install -y curl openssh-server ca-certificates也是安装相关依赖，这主要是用于GitLab发送电子邮件的；sudo apt-get install -y postfix下载安装包arm64位wget --content-disposition https://packages.gitlab.com/gitlab/gitlab-ce/packages/debian/buster/gitlab-ce_14.8.4-ce.0_arm64.deb/download.deb安装sudo dpkg -i gitlab-ce_14.8.4-ce.0_arm64.deb32位wget --content-disposition https://packages.gitlab.com/gitlab/raspberry-pi2/packages/raspbian/buster/gitlab-ce_14.8.4-ce.0_armhf.deb/download.deb安装sudo dpkg -i gitlab-ce_14.8.4-ce.0_armhf.deb使用64位的树莓派安装32位gitlab可能出现的问题错误解决sudo apt install libstdc++6:armhfsudo apt-get install gitlab-ce:armhf继续安装sudo apt --fix-broken install设置IP地址sudo vim /etc/gitlab/gitlab.rb替换external_url 'http://gitlab.example.com'toexternal_url 'http://192.168.0.100:8080'使配置生效sudo gitlab-ctl reconfigure重启sudo reboot # sudo gitlab-ctl restart登陆GitLab初始密码在此文件中/etc/gitlab/initial_root_password，有效24小时网址 http://192.168.0.100:8080其他指令服务控制  启用GitLab服务的开机启动功能；    sudo systemctl enable gitlab-runsvdir.service        禁用GitLab服务的开机启动功能；    sudo systemctl disable gitlab-runsvdir.service        查询GitLab服务的状态信息[选用]；    sudo gitlab-ctl service-listsudo gitlab-ctl statussudo systemctl status gitlab-runsvdir.service        # 停止GitLab服务[选用]；    sudo gitlab-ctl stop        sudo systemctl stop gitlab-runsvdir.service        启动GitLab服务[选用]；    sudo gitlab-ctl start        sudo systemctl start gitlab-runsvdir.service        重启GitLab服务[选用]；    sudo gitlab-ctl restart        sudo systemctl restart gitlab-runsvdir.service        如果GitLab服务已停止则启动服务，如果GitLab服务已启动则重启GitLab服务    sudo gitlab-ctl once      日志查询   关于GitLab的日志，默认保存在“/var/log/gitlab/”的目录下，该目录下保存着对应组件的各种类型的日志；与查询具体组件的具体类型日的写法，存在对应的关系；  查看所有GitLab日志；    sudo gitlab-ctl tail        查看某个组件的日志[nginx]；    sudo gitlab-ctl tail nginx        查看某个组件的某个类型日志；此命令基本等同于“sudo tail /var/log/gitlab/nginx/gitlab_access.log”命令；区别为此命令能实时同步显示日志的信息；    sudo gitlab-ctl tail nginx/gitlab_access.log      配置控制  重载/应用配置；    sudo gitlab-ctl reconfigure        检查配置并启动；    sudo gitlab-ctl check-config        将用户配置与包可用配置进行比较；    sudo gitlab-ctl diff-config        查看gitlab版本信息    sudo gitlab-rake gitlab:env:info      参考  树莓派搭建GitLab  GitLab密码修改"
  },
  
  {
    "title": "Ubuntu文件权限和归属",
    "url": "/posts/file-permision/",
    "categories": "Ubuntu",
    "tags": "file",
    "date": "2022-03-18 17:10:00 +0800",
    





    "snippet": "常见字符            字符      含义                  -      普通文件              d      目录文件              l      链接文件              b      块设备文件              c      字符设备文件              p      管道文件      文件权限            符号      作用      数字表示                  r      读      4              w      写      2              x      执行      1      示例ls -ldrwxr-xr-x# 可以分解为# d 目录# rwx 文件所有者 可读可写可执行# r-x 文件所属组 可读可执行不可写# r-x 其他用户 可读可执行不可写## 也可以用数字表示 # 7 可读可写可执行# 6 可读可写# 5 可读可执行# 4 可读# 3 可写可执行# 2 可写# 1 可执行设置权限  chmod [usertype] [signal] [type] [filename]            usertype      signal      type                  u（文件所有者）      +（添加权限）      r（可读）              g（文件所有者同组用户）      - （取消权限）      w（可写）              o（其他用户）      =（赋予权限并取消其他权限）      x（可执行）              a 表示所有用户（默认）                    示例# 赋予file文件所有者可执行权限chmod u+x [file]# 赋予file文件所有者所有权限，其余用户无权限chmod 700 text.txt"
  },
  
  {
    "title": "Ubuntu常用目录作用",
    "url": "/posts/directory/",
    "categories": "Ubuntu",
    "tags": "directory",
    "date": "2022-03-18 17:10:00 +0800",
    





    "snippet": "            目录名称      内容                  /boot      开机所需文件，内核、开机菜单以及所需配置文件等              /dev      以文件形式存放任何设备与接口              /etc      配置文件              /home      用户家目录              /bin      存放单用户模式下还可以操作的指令              /lib      开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数              /sbin      开机过程需要的命令              /media      用于挂载设备文件的目录              /opt      放置第三方的软件              /root      系统管理员的跟目录              /srv      一些网络服务的数据文件目录              /tmp      任何人均可使用的共享临时目录              /proc      虚拟文件系统，例如系统内核、进程、外部设备及网络状态等              /usr/local      用户自行安装的软件              /usr/sbin      Linux系统开机时不会使用到的软件/命令/脚本              /usr/share      帮助和说明文件，也可以放置共享文件              /var      主要存放经常变化的文件，如日志              /lost+found      当文件系统发生错误时，将一些丢失的文件片段存放在这里      "
  },
  
  {
    "title": "树莓派初始化指南",
    "url": "/posts/initialization/",
    "categories": "RaspberryPi, Init",
    "tags": "raspberrypi, init",
    "date": "2022-03-18 16:51:00 +0800",
    





    "snippet": "      SD卡格式化工具    SDFormatter        系统下载    Raspberry Pi        镜像烧录工具    Win32DiskImage        开启SSH    在烧录好的卡里放入ssh的空白文件        配置默认Wi-Fi    在根目录中新建文件wpa_supplicant.conf    country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network={\tssid=\"wifi name\"\tpsk=\"wifi password\"\tkey_mgmt=WPA-PSK}            扫描树莓派IP地址    Advanced IP Scanner        SSH工具    PuTTY        登陆树莓派  默认端口22，账号pi，密码raspberry      设置默认开启SSH服务    sudo raspi-config        Interfacing Options -&gt; SSH        树莓派设置静态ip    sudo vim /etc/dhcpcd.conf# 修改interface wlan0  #网卡名 或 eth0inform 192.168.2.218/24    #树莓派IPstatic routers=192.168.2.1  #路由器IPstatic domain_name_servers=192.168.2.1  #DNS，这里也是路由器IP      "
  },
  
  {
    "title": "查看CPU温度",
    "url": "/posts/temp/",
    "categories": "Ubuntu",
    "tags": "temp",
    "date": "2022-03-18 16:48:00 +0800",
    





    "snippet": "      查看CPU温度    cat /sys/class/thermal/thermal_zone0/temp      "
  },
  
  {
    "title": "Ubuntu挂载磁盘",
    "url": "/posts/mount/",
    "categories": "Ubuntu",
    "tags": "mount",
    "date": "2022-03-18 16:45:00 +0800",
    





    "snippet": "      查看移动磁盘信息    sudo fdisk -l            创建挂载目录    mkdir /fileDisk            挂载磁盘到路径    sudo mount /dev/sda /fileDisk# 增加权限，可能没有权限读写sudo chmod 777 /fileDisk            卸载挂载    sudo umount -v /dev/sdasudo umount -v /fileDisk            开机自动挂载    sudo vim /etc/fstab# 输入挂载/dev/sda /fileDisk ext4 defaults 0 0            参考          Linux 挂载移动硬盘      "
  },
  
  {
    "title": "Ubuntu常用程序安装和卸载",
    "url": "/posts/application/",
    "categories": "Ubuntu",
    "tags": "ubuntu-init",
    "date": "2022-03-18 16:41:00 +0800",
    





    "snippet": "更新aptsudo apt-get update安装vim、git、wgetsudo apt-get install vimsudo apt-get install gitsudo apt-get install wget安装htop  top命令增强版  sudo apt-get install htop  安装oh-my-zshzsh安装安装Java# jdk 11 = default-jdk =&gt; 11sudo apt-get install openjdk-11-jdk# jdk 8sudo apt-get install openjdk-8-jdk查看Java路径whereis javawhich java （java执行路径）卸载Java# 查看jdk情况dpkg --list | grep -i jd# 移除openjdk包apt-get purge openjdk*"
  },
  
  {
    "title": "Docker部署Tomcat",
    "url": "/posts/docker_tomcat/",
    "categories": "Other, Docker",
    "tags": "docker, tomcat",
    "date": "2022-03-18 15:41:00 +0800",
    





    "snippet": "# 1.下载镜像docker pull tomcat# 2.启动镜像docker run --name tomcat -v /home/jiangker/tomcat:/usr/local/tomcat/webapps -p 8080:8080 -d tomcat"
  },
  
  {
    "title": "Docker部署MySQL",
    "url": "/posts/docker_mysql/",
    "categories": "Other, Docker",
    "tags": "docker, mysql",
    "date": "2022-03-18 14:23:00 +0800",
    





    "snippet": "# 1.拉取镜像docker pull mysql# 2.启动docker run -p 3306:3306 --name mysql \\    --privileged=true \\    --restart=always \\    -v /home/docker/mysql/conf:/etc/mysql/conf.d \\    -v /home/docker/mysql/data:/var/lib/mysql \\    -v /home/docker/mysql/log:/var/log/mysql \\    -v /etc/localtime:/etc/localtime    -e MYSQL_ROOT_PASSWORD=&lt;password&gt; -d mysql### 目前运行版本1. 8.0.272. 8.0.313. 8.4.0# 3.字符编码乱码# 在conf目录下创建my.cnf输入[client]default_character_set=utf8[mysqld]collation_server = utf8_general_cicharacter_set_server = utf8"
  },
  
  {
    "title": "Docker部署Gitlab",
    "url": "/posts/docker_gitlab/",
    "categories": "Other, Docker",
    "tags": "gitlab",
    "date": "2022-03-18 14:13:00 +0800",
    





    "snippet": "1.下载镜像docker pull gitlab/gitlab-ce2.启动镜像docker run -d  -p 443:443 -p 80:80 -p 222:22 --name gitlab --restart always -v /home/gitlab/config:/etc/gitlab -v /home/gitlab/logs:/var/log/gitlab -v /home/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce3.修改配置文件打开文件vim /home/gitlab/config/gitlab.rb# 配置http协议所使用的访问地址,不加端口号默认为80external_url 'http://192.168.0.111'# 配置ssh协议所使用的访问地址和端口，配置端口，否则主机访问不到容器之中去gitlab_rails['gitlab_ssh_host'] = '192.168.0.111'gitlab_rails['gitlab_shell_ssh_port'] = 2224.重新启动docker restart gitlab5.修改密码# 查看密码cat /gitlab/config/initial_root_password登陆网站 左上角menu-&gt;admin-&gt;overview-&gt;users-&gt;edit6.相关的配置目录/etc/gitlab/var/log/gitlab/var/opt/gitlab"
  },
  
  {
    "title": "docker基础命令",
    "url": "/posts/docker-cmd/",
    "categories": "Other, Docker",
    "tags": "docker",
    "date": "2022-03-18 11:33:00 +0800",
    





    "snippet": "# 查看版本docker version# docker更详细的信息，images和容器数量等docker info# 帮助命令docker &lt;cmd&gt; --helpdocker refrence镜像相关命令# 本地所有镜像docker images -a# 所有镜像iddocker images -aq# 查询镜像docker search &lt;name&gt;\t--filter #过滤参数# 拉去镜像，默认使用最新版，可以使用[:tag]指定版本docker pull &lt;name&gt;# 删除镜像docker rmi -f &lt;id&gt;# 删除所有镜像docker rmi -f $(docker images -aq)容器相关命令# 运行容器 如果本地没有会下载 -it 进入运行 --rm 用完退出即删除，用来测试，docker run [可选参数] &lt;image&gt;\t-it # 进入运行\t--name=\"ubuntu1\" # 命名\t-d # 后台运行，如果没有前台进程，马上就会退出\t-p 3355:8080 # 外部3355映射内部8080端口\t-P #端口# 退出容器，exit #没有进程运行就会直接被关闭ctrl + p + q #退出不停止# 查看当前运行的容器docker ps\t-a #查看所有容器\t-n=[num] #查看数量\t-q #只显示编号\t# 启动、重启、停止、强制停止 容器docker start &lt;id&gt;docker restart &lt;id&gt;docker stop &lt;id&gt;docker kill &lt;id&gt;# 进入容器，开启的是新的终端docker exec -it &lt;image&gt; /bin/bash# 进入容器当前运行的进程终端docker attach &lt;image&gt; #删除容器docker rm &lt;id&gt; # 不能删除正在运行的容器docker rm -f $(docker ps -aq)# 查看容器日志docker logs -tf --tail [n] &lt;id&gt;# 查看容器内部进程信息docker top &lt;id&gt;# 查看容器的元数据，详细数据docker inspect &lt;id&gt;# 从容器内拷贝文件到主机上 容器 -&gt; 主机docker cp &lt;id&gt;:/path /path# 从主机内拷贝文件到容器上 主机 -&gt; 容器docker cp /path &lt;id&gt;:/pathcommit 镜像docker commit #提交镜像成为一个新的版本docker commit -m=\"描述信息\" -a=\"作者\" &lt;id&gt; &lt;镜像名称：版本号&gt;e.g.docker commit -a \"jiangker\" -m \"带有zsh git wegt vim的ubuntu系统\" bafe391362ee jiangker/ubuntu:0.1上传阿里云推送：https://cr.console.aliyun.com/repository/cn-beijing/jiangker/ubuntu/detailsDockerFile  将主机地址挂载到docker容器中，保证移除容器之后文件还能保存# 把主机目录挂载到容器docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=&lt;password&gt; -d -p 3306:3306 -v /home:/var/lib/mysql mysql\t-e #环境配置\t-v #挂载卷# 同步挂载的文件夹(继承)docker run -it --name ubuntuo2 --volumes-from ubuntu01 &lt;id/name:version&gt;# docker挂载若出现cannot open directory: Permission denied可以在命令后增加 --privileged=trueDockerFile的指令FROM # 基础镜像，一切从这里构建 ubuntuMAINTAINER # 镜像是谁写的，name+emailRUN # 镜像构建时候需要运行的命令ADD # 需要添加进去的工具 tomcatWORKDIR # 镜像的工作目录VOLUME # 挂载的目录EXPOSE # 指定暴露端口CMD # 指定这个容器启动的时候需要运行的命令，只有最后一个会生效ENTRYPOINT # 可以直接追加命令ONBUILD # 当构建一个被继承DockerFile这个时候就会运行这个命令COPY # 类似ADD命令，将文件拷贝到镜像中ENV # 构建时候设置环境变量# 运行dockerFiledocker build -f &lt;fileName&gt; -t &lt;name:version&gt; .# 查看构建过程docker history &lt;id&gt;"
  }
  
]

